{"meta":{"title":"谎话兔博客","subtitle":null,"description":null,"author":"谎话兔","url":"https://lierabbit.cn"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2018-08-20T12:11:23.000Z","updated":"2018-08-23T09:49:56.657Z","comments":false,"path":"/404.html","permalink":"https://lierabbit.cn//404.html","excerpt":"","text":""},{"title":"关于谎话兔","date":"2018-08-20T12:11:42.000Z","updated":"2018-08-22T09:26:10.692Z","comments":false,"path":"about/index.html","permalink":"https://lierabbit.cn/about/index.html","excerpt":"","text":"123456789101112131415161718192021222324252627&#123; name: &apos;谎话兔&apos; age: 23, gender: &apos;男&apos;, profession: &apos;业余开发者&apos;, experience: &apos;0年&apos;, address: &apos;广东省广州市&apos;, education: &apos;本科&apos;, github: &apos;https://github.com/LieRabbit&apos;, blog: &apos;http://lierabbit.cn&apos;, email: &apos;lierabbit@qq.com&apos;, description: &apos;走别人的路让别人无路可走&apos;, skills: [ [&apos;Java&apos;, &apos;Spring Cloud&apos;, &apos;Spring Boot&apos;, &apos;Spring&apos;] [&apos;Angular&apos;, &apos;TypeScript&apos;], [&apos;Html&apos;, &apos;JavaScript&apos;, &apos;JQuery&apos;, &apos;CSS&apos;, &apos;ES6&apos;, &apos;Node&apos;, &apos;Sass&apos;], [&apos;Python&apos;, &apos;Django&apos;] [&apos;Git&apos;, &apos;SVN&apos;] ], devTools: [ [&apos;Idea&apos;, &apos;WebStorm&apos;, &apos;PyCharm&apos;, &apos;Visual Studio Code&apos;], [&apos;Chrome DevTools&apos;], [&apos;Navicat&apos;], ]&#125;"},{"title":"书单","date":"2018-08-22T09:00:18.676Z","updated":"2018-08-22T09:00:18.676Z","comments":false,"path":"books/index.html","permalink":"https://lierabbit.cn/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2018-08-20T12:12:46.000Z","updated":"2018-08-20T12:32:32.265Z","comments":false,"path":"categories/index.html","permalink":"https://lierabbit.cn/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2018-08-20T12:12:13.000Z","updated":"2018-08-20T12:21:05.858Z","comments":true,"path":"links/index.html","permalink":"https://lierabbit.cn/links/index.html","excerpt":"","text":""},{"title":"项目","date":"2018-08-20T12:12:23.000Z","updated":"2018-08-20T12:29:34.573Z","comments":false,"path":"repository/index.html","permalink":"https://lierabbit.cn/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-08-18T09:59:10.592Z","updated":"2018-08-18T09:59:10.592Z","comments":false,"path":"tags/index.html","permalink":"https://lierabbit.cn/tags/index.html","excerpt":"","text":"啦啦啦"}],"posts":[{"title":"ArrayList实现原理","slug":"ArrayList实现原理","date":"2018-01-23T04:29:37.000Z","updated":"2018-08-23T11:45:28.275Z","comments":true,"path":"2018/01/23/ArrayList实现原理/","link":"","permalink":"https://lierabbit.cn/2018/01/23/ArrayList实现原理/","excerpt":"","text":"概述ArrayList可以简单的看作是动态数组，相对于普通的数组它可以动态的增加容量或者减少容量。要注意的是ArrayList并不是线程安全的，因此一般建议在单线程中使用ArrayList。 实现原理继承关系1public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable ArrayList继承AbstractList实现List, RandomAccess, Cloneable, java.io.Serializable接口 关键属性12345678910111213141516/** * The array buffer into which the elements of the ArrayList are stored. * The capacity of the ArrayList is the length of this array buffer. Any * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA * will be expanded to DEFAULT_CAPACITY when the first element is added. */// 数据的数组transient Object[] elementData; // non-private to simplify nested class access/** * The size of the ArrayList (the number of elements it contains). * * @serial */// 实际数据的数量private int size; 底层使用数组保存所有元素transient 如果用transient声明一个实例变量，当对象存储时，它的值不需要维持。换句话来说就是，用transient关键字标记的成员变量不参与序列化过程 构造方法123456789101112/** * Shared empty array instance used for default sized empty instances. We * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when * first element is added. */private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;/** * Constructs an empty list with an initial capacity of ten. */public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125; 默认情况下初始化空数组（长度为0的数组） 123456789101112131415161718192021/** * Shared empty array instance used for empty instances. */private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;/** * Constructs an empty list with the specified initial capacity. * * @param initialCapacity the initial capacity of the list * @throws IllegalArgumentException if the specified initial capacity * is negative */public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException(\"Illegal Capacity: \"+ initialCapacity); &#125;&#125; 指定数组的初始容量当指定的初始容量大于0，初始化指定大小的数组当指定的初始容量等于0，初始化空数组当指定的初始容量小于0，抛出IllegalArgumentException异常12345678910111213141516171819/** * Constructs a list containing the elements of the specified * collection, in the order they are returned by the collection's * iterator. * * @param c the collection whose elements are to be placed into this list * @throws NullPointerException if the specified collection is null */public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; &#125;&#125; 初始化指定集合的数组当指定集合不为空即长度不为0，则复制该集合，否则初始化一个空数组 E get(int index) 获取index位置的元素123456789101112131415161718192021222324252627282930313233343536373839404142// Positional Access Operations// 返回index下标的元素且强制转化为E（List&lt;E&gt;中的E）类型@SuppressWarnings(\"unchecked\")E elementData(int index) &#123; return (E) elementData[index];&#125;/** * Returns the element at the specified position in this list. * * @param index index of the element to return * @return the element at the specified position in this list * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */public E get(int index) &#123; // 检查index是否越界 rangeCheck(index); // 返回index下标的元素 return elementData(index);&#125;/** * Checks if the given index is in range. If not, throws an appropriate * runtime exception. This method does *not* check if the index is * negative: It is always used immediately prior to an array access, * which throws an ArrayIndexOutOfBoundsException if index is negative. */private void rangeCheck(int index) &#123; // 检查index是否大于等于size（数组的元素数量），因为数组下标从0开始计算，所以也不能等于元素数量 // 这里没有检查index &lt; 0的情况，因为index &lt; 0时数组会自动抛出异常，所以并未检查index&lt;0的情况 if (index &gt;= size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index));&#125;/** * Constructs an IndexOutOfBoundsException detail message. * Of the many possible refactorings of the error handling code, * this \"outlining\" performs best with both server and client VMs. */private String outOfBoundsMsg(int index) &#123; return \"Index: \"+index+\", Size: \"+size;&#125; 首先判断index是否越界，这里并没有判断是否小于0，因为下标小于0时数组会抛出异常。越界则抛出IndexOutOfBoundsException异常，反之返回数组对应index位置的元素 E set(int index, E element) 设置（覆盖）index位置的元素12345678910111213141516/** * Replaces the element at the specified position in this list with * the specified element. * * @param index index of the element to replace * @param element element to be stored at the specified position * @return the element previously at the specified position * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */public E set(int index, E element) &#123; rangeCheck(index); E oldValue = elementData(index); elementData[index] = element; return oldValue;&#125; 和get一样先判断index（下标）是否越界，不越界则先获取原来index位置上的元素，接着设置（覆盖）index位置上的元素，然后返回原来的元素，反之抛出IndexOutOfBoundsException异常 boolean add(E e) 添加一个元素到列表尾123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/** * Appends the specified element to the end of this list. * * @param e element to be appended to this list * @return &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;@link Collection#add&#125;) */public boolean add(E e) &#123; // 检查当前容量是否还可以容纳一个元素，不够则扩容 ensureCapacityInternal(size + 1); // Increments modCount!! // 添加到数组末尾 // 这个语句可以分解为 // elementData[size] = e; // size += 1; elementData[size++] = e; return true;&#125;/** * Default initial capacity. */private static final int DEFAULT_CAPACITY = 10; // 默认容量为10// 如果数据等于默认数据，返回默认容量和minCapacity（所需容量最小值）的最大值，反之返回所需容量最小值private static int calculateCapacity(Object[] elementData, int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; return Math.max(DEFAULT_CAPACITY, minCapacity); &#125; return minCapacity;&#125;private void ensureCapacityInternal(int minCapacity) &#123; ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));&#125;private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // 操作数+1 // overflow-conscious code // 如果所需容量最小值大于实际数组的长度就扩大实际数组容量 if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125;/** * The maximum size of array to allocate. * Some VMs reserve some header words in an array. * Attempts to allocate larger arrays may result in * OutOfMemoryError: Requested array size exceeds VM limit */private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; // 数组最大容量为Integer最大值-8/** * Increases the capacity to ensure that it can hold at least the * number of elements specified by the minimum capacity argument. * * @param minCapacity the desired minimum capacity */private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; // 新的容量为旧的容量的1.5倍 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); // 如果扩充容量后还是不够，则新的容量等于所需容量最小值（一般就是数组实际元素个数） if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; // 如果新的容量大于数组最大容量，再调用hugeCapacity计算新的容量 if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: // 复制原来的数据到新的数组，数组容量为新的容量 elementData = Arrays.copyOf(elementData, newCapacity);&#125;private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); // 大于数组最大容量返回Integer最大值，反之返回数组最大容量 return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;&#125; 添加一个元素到列表尾，当列表容量不足时自动扩容（通常是扩容至原来的1.5倍），添加成功返回true void add(int index, E element) 在index处放置元素123456789101112131415161718192021222324252627282930/** * Inserts the specified element at the specified position in this * list. Shifts the element currently at that position (if any) and * any subsequent elements to the right (adds one to their indices). * * @param index index at which the specified element is to be inserted * @param element element to be inserted * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */public void add(int index, E element) &#123; // 检查下标是否越界 rangeCheckForAdd(index); // 检查当前容量是否还可以在容纳一个元素，不够则扩容 ensureCapacityInternal(size + 1); // Increments modCount!! // 将elementData从index开始后面的元素往后移一位 System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++;&#125;/** * A version of rangeCheck used by add and addAll. */private void rangeCheckForAdd(int index) &#123; // 当index等于size时相当于添加元素到列表尾 if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException(outOfBoundsMsg(index));&#125; 将elementData数组从index开始后面的元素往后移一位，接着在index处放置元素模拟添加数据(lierabbit)到index=4过程如下1 初始数组 0 1 2 3 4 5 6 7 8 9 a b c d e f g h i j 2 从index开始后面的元素往后移一位 0 1 2 3 4 5 6 7 8 9 a b c d e e f g h i 3 在index处放置lierabbit 0 1 2 3 4 5 6 7 8 9 a b c d lierabbit e f g h i boolean addAll(Collection&lt;? extends E&gt; c) 添加一个集合里的所有元素到列表尾123456789101112131415161718192021222324/** * Appends all of the elements in the specified collection to the end of * this list, in the order that they are returned by the * specified collection's Iterator. The behavior of this operation is * undefined if the specified collection is modified while the operation * is in progress. (This implies that the behavior of this call is * undefined if the specified collection is this list, and this * list is nonempty.) * * @param c collection containing elements to be added to this list * @return &lt;tt&gt;true&lt;/tt&gt; if this list changed as a result of the call * @throws NullPointerException if the specified collection is null */public boolean addAll(Collection&lt;? extends E&gt; c) &#123; Object[] a = c.toArray(); int numNew = a.length; // 检查当前容量是否还可以在容纳a数组的元素，不够则扩容 ensureCapacityInternal(size + numNew); // Increments modCount // 将a数组里的元素添加到elementData末尾 System.arraycopy(a, 0, elementData, size, numNew); size += numNew; // a数组不为空（长度不为0）时返回true，反之false return numNew != 0;&#125; 将要添加的集合变为数组，然后将其复制到elementData数组末尾 boolean addAll(int index, Collection&lt;? extends E&gt; c) 添加一个集合里的所有元素到index位置123456789101112131415161718192021222324252627282930313233343536/** * Inserts all of the elements in the specified collection into this * list, starting at the specified position. Shifts the element * currently at that position (if any) and any subsequent elements to * the right (increases their indices). The new elements will appear * in the list in the order that they are returned by the * specified collection's iterator. * * @param index index at which to insert the first element from the * specified collection * @param c collection containing elements to be added to this list * @return &lt;tt&gt;true&lt;/tt&gt; if this list changed as a result of the call * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; * @throws NullPointerException if the specified collection is null */public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; // 检查下标是否越界 rangeCheckForAdd(index); Object[] a = c.toArray(); int numNew = a.length; // 检查当前容量是否还可以在容纳a数组的元素，不够则扩容 ensureCapacityInternal(size + numNew); // Increments modCount // 需要往后移动几个位置 int numMoved = size - index; if (numMoved &gt; 0) // 从index开始，往后的元素向后移动numMoved个位置 System.arraycopy(elementData, index, elementData, index + numNew, numMoved); // 将a数组里的所有元素复制到elementData从index到index + numNew -1的位置上 System.arraycopy(a, 0, elementData, index, numNew); size += numNew; // a数组不为空（长度不为0）时返回true，反之false return numNew != 0;&#125; 将要添加的集合变为数组，然后把elementData数组从index开始，往后的元素向后移动numMoved个位置，接着将要添加的数组里的所有元素复制到elementData从index到index + numNew -1的位置上 void trimToSize() 改变列表内部数组容量至列表实际元素数量123456789101112131415/** * Trims the capacity of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance to be the * list's current size. An application can use this operation to minimize * the storage of an &lt;tt&gt;ArrayList&lt;/tt&gt; instance. */public void trimToSize() &#123; modCount++; // 操作数+1 // 如果数组实际元素数量小于数组长度 if (size &lt; elementData.length) &#123; // 如果数组实际元素数量等于0则数组被赋值为空数组，反之创建一个新的元素数量等于数组长度的数组 elementData = (size == 0) ? EMPTY_ELEMENTDATA : Arrays.copyOf(elementData, size); &#125;&#125; 当数据稳定了之后可以使用这个方法来减少内存的使用 int indexOf(Object o) 查找o元素在列表第一次出现的位置123456789101112131415161718192021/** * Returns the index of the first occurrence of the specified element * in this list, or -1 if this list does not contain the element. * More formally, returns the lowest index &lt;tt&gt;i&lt;/tt&gt; such that * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt;, * or -1 if there is no such index. */public int indexOf(Object o) &#123; //元素可以为null，如果为null返回null的下标 if (o == null) &#123; for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; &#125; else &#123; for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; &#125; // 没有找到对应的元素返回-1 return -1;&#125; ArrayList中可以存放null元素，indexof是返回elementData数组中值相同的首个元素的下标，indexof中比较方法是equals而equals是比较元素的值，因此必须对null单独查找。如果未找到该元素则返回-1 E remove(int index) 删除index位置上的元素1234567891011121314151617181920212223242526/** * Removes the element at the specified position in this list. * Shifts any subsequent elements to the left (subtracts one from their * indices). * * @param index the index of the element to be removed * @return the element that was removed from the list * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */public E remove(int index) &#123; // 检查下标是否越界 rangeCheck(index); modCount++; // 操作数+1 E oldValue = elementData(index); // 获取index位置上的元素 int numMoved = size - index - 1; // 需要往前移动几个位置 if (numMoved &gt; 0) // 从index + 1开始，往后的元素向前移动1个位置 System.arraycopy(elementData, index+1, elementData, index, numMoved); // 将数组末尾元素置空 elementData[--size] = null; // clear to let GC do its work return oldValue;&#125; 模拟删除index=4（值为lierabbit）过程如下1 初始数组 0 1 2 3 4 5 6 7 8 9 a b c d lierabbit f g h i j 2 从index + 1（即index=5，值为f）开始，往后的元素向前移动1个位置 0 1 2 3 4 5 6 7 8 9 a b c d f g h i j j 3 将数组末尾元素置空 0 1 2 3 4 5 6 7 8 9 a b c d f g h i j null boolean remove(Object o) 删除o元素123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * Removes the first occurrence of the specified element from this list, * if it is present. If the list does not contain the element, it is * unchanged. More formally, removes the element with the lowest index * &lt;tt&gt;i&lt;/tt&gt; such that * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt; * (if such an element exists). Returns &lt;tt&gt;true&lt;/tt&gt; if this list * contained the specified element (or equivalently, if this list * changed as a result of the call). * * @param o element to be removed from this list, if present * @return &lt;tt&gt;true&lt;/tt&gt; if this list contained the specified element */public boolean remove(Object o) &#123; // 元素可以为null，分开搜索o if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; // 没有找到返回false return false;&#125;/* * Private remove method that skips bounds checking and does not * return the value removed. */// 由于已经找到元素，则元素必定存在，则index必定合理，所以不需要在检查index是否越界private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work&#125; 通过寻找o元素，可以获得其下标，再根据下标删除o元素 forEach(Consumer&lt;? super E&gt; action)遍历列表12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * The number of times this list has been &lt;i&gt;structurally modified&lt;/i&gt;. * Structural modifications are those that change the size of the * list, or otherwise perturb it in such a fashion that iterations in * progress may yield incorrect results. * * &lt;p&gt;This field is used by the iterator and list iterator implementation * returned by the &#123;@code iterator&#125; and &#123;@code listIterator&#125; methods. * If the value of this field changes unexpectedly, the iterator (or list * iterator) will throw a &#123;@code ConcurrentModificationException&#125; in * response to the &#123;@code next&#125;, &#123;@code remove&#125;, &#123;@code previous&#125;, * &#123;@code set&#125; or &#123;@code add&#125; operations. This provides * &lt;i&gt;fail-fast&lt;/i&gt; behavior, rather than non-deterministic behavior in * the face of concurrent modification during iteration. * * &lt;p&gt;&lt;b&gt;Use of this field by subclasses is optional.&lt;/b&gt; If a subclass * wishes to provide fail-fast iterators (and list iterators), then it * merely has to increment this field in its &#123;@code add(int, E)&#125; and * &#123;@code remove(int)&#125; methods (and any other methods that it overrides * that result in structural modifications to the list). A single call to * &#123;@code add(int, E)&#125; or &#123;@code remove(int)&#125; must add no more than * one to this field, or the iterators (and list iterators) will throw * bogus &#123;@code ConcurrentModificationExceptions&#125;. If an implementation * does not wish to provide fail-fast iterators, this field may be * ignored. */protected transient int modCount = 0;//操作数@Overridepublic void forEach(Consumer&lt;? super E&gt; action) &#123; // 确保不为空 Objects.requireNonNull(action); final int expectedModCount = modCount; @SuppressWarnings(\"unchecked\") final E[] elementData = (E[]) this.elementData; final int size = this.size; for (int i=0; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123; action.accept(elementData[i]); &#125; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125;&#125;/** * Checks that the specified object reference is not &#123;@code null&#125;. This * method is designed primarily for doing parameter validation in methods * and constructors, as demonstrated below: * &lt;blockquote&gt;&lt;pre&gt; * public Foo(Bar bar) &#123; * this.bar = Objects.requireNonNull(bar); * &#125; * &lt;/pre&gt;&lt;/blockquote&gt; * * @param obj the object reference to check for nullity * @param &lt;T&gt; the type of the reference * @return &#123;@code obj&#125; if not &#123;@code null&#125; * @throws NullPointerException if &#123;@code obj&#125; is &#123;@code null&#125; */public static &lt;T&gt; T requireNonNull(T obj) &#123; if (obj == null) throw new NullPointerException(); return obj;&#125; 这里可以看到modCount的用处，当modCount发生改变后，立刻抛出ConcurrentModificationException异常。通过之前的分析可以知道当列表内容被修改时modCount会增加。也就是说如果在遍历ArrayList的过程中有其他线程修改了ArrayList，那么将抛出ConcurrentModificationException异常 ArrayList小结 ArrayList是List接口的一个可变大小的数组的实现 ArrayList的内部是使用一个Object对象数组来存储元素的 初始化ArrayList的时候，可以指定初始化容量的大小，如果不指定，就会使用默认大小，为10 当添加一个新元素的时候，首先会检查容量是否足够添加这个元素，如果够就直接添加，如果不够就进行扩容，扩容为原数组容量的1.5倍 当在index处放置一个元素的时候，会将数组index处右边的元素全部右移 当在index处删除一个元素的时候，会将数组index处右边的元素全部左移","categories":[{"name":"Java从深入到放弃","slug":"Java从深入到放弃","permalink":"https://lierabbit.cn/categories/Java从深入到放弃/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://lierabbit.cn/tags/Java/"}]},{"title":"SpringBoot快速入门1--HelloSpringBoot","slug":"SpringBoot快速入门1-HelloSpringBoot","date":"2018-01-12T09:07:21.000Z","updated":"2018-08-23T11:42:05.866Z","comments":true,"path":"2018/01/12/SpringBoot快速入门1-HelloSpringBoot/","link":"","permalink":"https://lierabbit.cn/2018/01/12/SpringBoot快速入门1-HelloSpringBoot/","excerpt":"","text":"一、准备工作java环境：jdk 1.8开发工具：idea 二、创建项目打开idea 点击Create New Project 选择Spring Initializr，Next Group.Artifact = 你的包名type：个人喜欢选择gradle，默认的maven也可以Next 选择webNext 选择工程目录Finish 如果目录不存在，Idea将帮你创建，点击ok就行 如果没有下载过gradle，默认选择就行，点ok如果想使用已存在的gradle选择Use local gradle distribution 等待右下角（红圈部分）下载完成 添加HelloCtrl类添加如下代码1234567891011121314import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;@Controller//这是一个控制器public class HelloCtrl&#123; @RequestMapping(\"/\")//将地址映射到 / 即访问http://localhost:8080 就可以进入这个方法 @ResponseBody//返回数据,如果不添加该注解将在resources/templates下寻找与之对应的html模版 public String hello() &#123; return \"hello spring boot\"; &#125;&#125; 三、运行 点击右上角启动如果没有启动可点点击HelloSpringBootApplication左边的启动箭头即可启动 启动成功控制的打印如下图所示内容 打开浏览器，http://localhost:8080 出现hello spring boot字样则成功源码地址：https://github.com/LieRabbit/hello-spring-boot","categories":[{"name":"Spring Boot快速入门","slug":"Spring-Boot快速入门","permalink":"https://lierabbit.cn/categories/Spring-Boot快速入门/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://lierabbit.cn/tags/Spring-Boot/"}]}]}