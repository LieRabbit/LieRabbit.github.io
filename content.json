{"meta":{"title":"谎话兔博客","subtitle":"LieRabbit","description":"生命不息，奋斗不止","author":"谎话兔","url":"https://lierabbit.cn"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2018-08-20T12:11:23.000Z","updated":"2018-08-23T09:49:56.657Z","comments":false,"path":"/404.html","permalink":"https://lierabbit.cn//404.html","excerpt":"","text":""},{"title":"书单","date":"2018-08-22T09:00:18.676Z","updated":"2018-08-22T09:00:18.676Z","comments":false,"path":"books/index.html","permalink":"https://lierabbit.cn/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2018-08-20T12:12:46.000Z","updated":"2018-08-20T12:32:32.265Z","comments":false,"path":"categories/index.html","permalink":"https://lierabbit.cn/categories/index.html","excerpt":"","text":""},{"title":"关于谎话兔","date":"2018-08-20T12:11:42.000Z","updated":"2018-08-25T06:12:21.484Z","comments":false,"path":"about/index.html","permalink":"https://lierabbit.cn/about/index.html","excerpt":"","text":"123456789101112131415161718192021222324252627&#123; name: &apos;谎话兔&apos; age: 23, gender: &apos;男&apos;, profession: &apos;业余开发者&apos;, experience: &apos;0年&apos;, address: &apos;广东省广州市&apos;, education: &apos;本科&apos;, github: &apos;https://github.com/LieRabbit&apos;, blog: &apos;http://lierabbit.cn&apos;, email: &apos;lierabbit@qq.com&apos;, description: &apos;有些梦虽然遥不可及，但并不是不可能实现，只要我足够的强&apos;, skills: [ [&apos;Java&apos;, &apos;Spring Cloud&apos;, &apos;Spring Boot&apos;, &apos;Spring&apos;] [&apos;Angular&apos;, &apos;TypeScript&apos;], [&apos;Html&apos;, &apos;JavaScript&apos;, &apos;JQuery&apos;, &apos;CSS&apos;, &apos;ES6&apos;, &apos;Node&apos;, &apos;Sass&apos;], [&apos;Python&apos;, &apos;Django&apos;] [&apos;Git&apos;, &apos;SVN&apos;] ], devTools: [ [&apos;Idea&apos;, &apos;WebStorm&apos;, &apos;PyCharm&apos;, &apos;Visual Studio Code&apos;], [&apos;Chrome DevTools&apos;], [&apos;Navicat&apos;], ]&#125;"},{"title":"友情链接","date":"2018-08-20T12:12:13.000Z","updated":"2018-08-20T12:21:05.858Z","comments":true,"path":"links/index.html","permalink":"https://lierabbit.cn/links/index.html","excerpt":"","text":""},{"title":"项目","date":"2018-08-20T12:12:23.000Z","updated":"2018-08-20T12:29:34.573Z","comments":false,"path":"repository/index.html","permalink":"https://lierabbit.cn/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-08-18T09:59:10.592Z","updated":"2018-08-18T09:59:10.592Z","comments":false,"path":"tags/index.html","permalink":"https://lierabbit.cn/tags/index.html","excerpt":"","text":"啦啦啦"}],"posts":[{"title":"游戏","slug":"游戏","date":"2018-02-27T12:19:44.000Z","updated":"2018-08-25T10:04:10.032Z","comments":true,"path":"2018/02/27/游戏/","link":"","permalink":"https://lierabbit.cn/2018/02/27/游戏/","excerpt":"","text":"A与B做游戏。 在一个n*m的矩阵中的出发点是（1，m），终点是（n,1），规则是只能向左移动一格，向下一格或向左下移动一格，先走到终点的为winner。 A先走。给定两个整数n和m，请返回最后的获胜者的名字(A或B)。 测试样例：125 3返回：B 思路：最优策略是两个人每次共走2格，如果A向左下2移动一格，相当于移动2格，此时B也应该向左下移动，总共是4格 123456789public char getWinner(int n, int m) &#123; // write code here // 最优策略是两个人每次共走2格， // 如果A向左下2移动一格，相当于移动2格，此时B也应该向左下移动，总共是4格 if (m % 2 != 0 &amp;&amp; n % 2 != 0) return 'B';// // 此时B距离终点只有1格 else return 'A';&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"数组清空","slug":"数组清空","date":"2018-02-27T12:08:20.000Z","updated":"2018-08-25T10:00:51.924Z","comments":true,"path":"2018/02/27/数组清空/","link":"","permalink":"https://lierabbit.cn/2018/02/27/数组清空/","excerpt":"","text":"现在有一个整数数组，其元素值均为1-n范围内的某个整数，现在你和你的朋友在玩一个游戏，游戏的目的是把数组清空，你们轮流操作，你是先手，每次操作你可以删除数组中值为某个数的元素任意多个(当然数组中值为这个数的元素个数应大于等于你删除的个数,且你至少要删除一个数)。最先把数组清空的人获得胜利。假设你们都采取最优策略，请你计算你能否获得胜利。给定一个整数数组A和元素个数n。请返回一个整数，1代表你能获胜，0代表你不能获胜。 测试样例：12[1,1,1]返回：1 思路：最优策略为和对方删除同样数量的元素，导致最后留下只能两次删除完所有元素，这样在对方再走一步后你就获胜了 1234567891011121314151617public int getWinner(int[] A, int n) &#123; // write code here HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); // 统计所有数字出现次数 for (int num : A) map.merge(num, 1, (a, b) -&gt; a + b); // 将所有次数进行异或运算 int res = 0; for (int count : map.values()) &#123; res ^= count; &#125; // 出现次数成对则为0 return res != 0 ? 1 : 0;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"跳格子","slug":"跳格子","date":"2018-02-27T08:54:47.000Z","updated":"2018-08-25T09:54:01.466Z","comments":true,"path":"2018/02/27/跳格子/","link":"","permalink":"https://lierabbit.cn/2018/02/27/跳格子/","excerpt":"","text":"你和你的朋友正在玩棋子跳格子的游戏，而棋盘是一个由n个格子组成的长条，你们两人轮流移动一颗棋子，每次可以选择让棋子跳1-3格，先将棋子移出棋盘的人获得胜利。我们知道你们两人都会采取最优策略，现在已知格子数目，并且初始时棋子在第一格由你操作。请你计算你是否能获胜。给定格子的数目n(n为不超过300的正整数)。返回一个整数，1代表能获胜，0代表不能获胜。 测试样例：123返回：1 思路： 通过列举1、2、3、4格的情况发现，只要轮到我的时候还剩4格，我必输无疑，因为无论我选择走多少格对方都可以一次走出棋盘。更巧的是，无论我走多少格，对方都可以选择走一种格数来使这一回合凑齐4格。因此，只要总格数是4的整数倍，我就必输无疑。而在其他任何种格数下，在走第一步的时候我都可以选择走一种格数使得剩下的格数为4的整数倍，这样对方就必输无疑。 1234public int checkWin(int n) &#123; // write code here return (n - 1) % 4 == 0 ? 0 : 1;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"赛马","slug":"赛马","date":"2018-02-27T08:43:49.000Z","updated":"2018-08-25T09:50:20.935Z","comments":true,"path":"2018/02/27/赛马/","link":"","permalink":"https://lierabbit.cn/2018/02/27/赛马/","excerpt":"","text":"作为一个马场的主人，你要安排你的n匹赛马和另一个马场的n匹马比赛。你已经知道了对方马场的出战表，即参加每一场的马的强壮程度。当然你也知道你自己的所有马的强壮程度。我们假定比赛的结果直接由马的强壮程度决定，即更壮的马获胜(若相同则双方均不算获胜)，请你设计一个策略，使你能获得尽量多的场次的胜利。给定对方每场比赛的马的强壮程度oppo及你的所有马的强壮程度horses(强壮程度为整数，且数字越大越强壮)同时给定n，请返回最多能获胜的场次。 测试样例：12[1,2,3],[1,2,3],3返回：2 思路：和田忌赛马类似，用最强的马与能赢别人的最强的马比 1234567891011public int winMost(int[] oppo, int[] horses, int n) &#123; // write code here Arrays.sort(oppo); Arrays.sort(horses); int res = 0; for (int i = n - 1; i &gt;= 0; --i) if (horses[n - res - 1] &gt; oppo[i]) res++; return res;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"涂色","slug":"涂色","date":"2018-02-27T08:26:06.000Z","updated":"2018-08-25T09:45:21.943Z","comments":true,"path":"2018/02/27/涂色/","link":"","permalink":"https://lierabbit.cn/2018/02/27/涂色/","excerpt":"","text":"你要在一个nxm的格子图上涂色，你每次可以选择一个未涂色的格子涂上你开始选定的那种颜色。同时为了美观，我们要求你涂色的格子不能相邻，也就是说，不能有公共边，现在问你，在采取最优策略的情况下，你最多能涂多少个格子？给定格子图的长n和宽m。请返回最多能涂的格子数目。 测试样例：121,2返回：1 思路：只有一种颜色，要想不相邻，每行一个隔一个涂色即可，如果行数或者列数为偶数，最多的格子即为(m / 2) n或者(n / 2) m，显然就是m n / 2如果行列均不为偶数，假设多加一列，则最大格子就为((n + 1) / 2) m,然后需要减去多加的格子数为(m - 1) / 2,两式合并即为(n m + 1) / 2又由int除法特性，可以将两式合并为(n m + 1) / 2,即为所求 1234public int getMost(int n, int m) &#123; // write code here return (n * m + 1) / 2;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"最优编辑","slug":"最优编辑","date":"2018-02-27T08:03:25.000Z","updated":"2018-08-25T09:29:01.079Z","comments":true,"path":"2018/02/27/最优编辑/","link":"","permalink":"https://lierabbit.cn/2018/02/27/最优编辑/","excerpt":"","text":"对于两个字符串A和B，我们需要进行插入、删除和修改操作将A串变为B串，定义c0，c1，c2分别为三种操作的代价，请设计一个高效算法，求出将A串变为B串所需要的最少代价。给定两个字符串A和B，及它们的长度和三种操作代价，请返回将A串变为B串所需要的最小代价。保证两串长度均小于等于300，且三种代价值均小于等于100。 测试样例：12&quot;abc&quot;,3,&quot;adc&quot;,3,5,3,100返回：8 思路：下面具体说明dp矩阵每个位置的值是如何计算的: dp[0][0]设置为0，表示str1空的子串编辑成str2空的子串，故代价为0。 矩阵dp第一列即dp[0..M][0],dp[i][0]表示str1[0.i-1]编辑成空串的最小代价，即把str1[0..i-1]所有字符都删掉的代价，故dp[i][0]=dc*i。 矩阵dp第一行即dp[0][0..N]。dp[0][j]表示空串编辑成str2[0.j-1]的最小代价，即在空串里插入str2[0..j-1]的所有字符的代价，故dp[0][j]=ic*j。 其他位置按照先从左到右，再从上到下来计算，dp[i][j]的值只可能来自以下四种情况:(1) str1[0..i-1]可以先编辑成str1[0..i-2] 也就是删除字符str1[i-1],然后由str1[0..i-2]编辑成str2[0..j-1] dp[i-1][j]就表示str1[0..i-2]编辑成str2[0..j-1]的最小代价，那么dp[i][j]可能等于dc+dp[i-1][j].(2) str1[0..i-1]可以先编辑成str2[0.j-2],然后将str2[0..j-2]插入字符str2[j-1],编辑成str2[0..j-1] dp[i][j-1]表示str1[0..i-1]编辑成str2[0..j-2]的最小代价，那么dp[i][j]可能等于dp[ij][j-1]+ic.(3) 如果str1[i-1]!=str2[j-1].先把str1[0..i-1]中str1[0..i-2]的部分变成str2[0..j-2],然后把字符str1[i-1]替换成str2[j-1],这样str1[0..i-1]就编辑成str2[0..j-1]了.dp[i-1][j-1]就表示str1[0.i-2]编辑成str2[0.i-2]的最小代价，那么dp[i][j]可能等于dp[i-1][j-1] +rC。(4) 如果str1[i-1]==str2[j-1],先把str1[0..i-1]中str1[0..i-2]的部分变成str2[0.j-2],因为此时字符str1[i-1]等于str2[j-1],所以str1[0..i-1]已经编辑成str2[0.j-1]了。dp[i-1][j-1]就表示str1[0.i-2]编辑成str2[0.i-2]的最小代价，那么dp[i]j]可能等于dp[i-1j[j-1].以上四种可能的值中，选最小值作为dp[i][j]的值。 最终结果返回dp最右下角的值 123456789101112131415161718192021222324252627282930public int findMinCost(String str1, int n, String str2, int m, int ic, int dc, int rc) &#123; // write code here int[][] dp = new int[n + 1][m + 1]; int col = 0; int row = 0; // 初始化列 while (row &lt;= n) &#123; dp[row][0] = row * dc; row++; &#125; // 初始化行 while (col &lt;= m) &#123; dp[0][col] = col * ic; col++; &#125; for (row = 1; row &lt;= n; row++) &#123; for (col = 1; col &lt;= m; col++) &#123; if (str1.charAt(row - 1) == str2.charAt(col - 1)) dp[row][col] = Math.min(dp[row - 1][col] + dc, Math.min(dp[row][col - 1] + ic, dp[row - 1][col - 1])); else dp[row][col] = Math.min(dp[row - 1][col] + dc, Math.min(dp[row][col - 1] + ic, dp[row - 1][col - 1] + rc)); &#125; &#125; return dp[n][m];&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"01背包","slug":"01背包","date":"2018-02-27T05:56:21.000Z","updated":"2018-08-25T09:24:56.788Z","comments":true,"path":"2018/02/27/01背包/","link":"","permalink":"https://lierabbit.cn/2018/02/27/01背包/","excerpt":"","text":"一个背包有一定的承重cap，有N件物品，每件都有自己的价值，记录在数组v中，也都有自己的重量，记录在数组w中，每件物品只能选择要装入背包还是不装入背包，要求在不超过背包承重的前提下，选出物品的总价值最大。给定物品的重量w价值v及物品数n和承重cap。请返回最大总价值。 测试样例：12[1,2,3],[1,2,3],3,6返回：6 思路：物品编号从1到n，一件一件物品考虑是否加入背包。假设dp[x] [y]表示前x件物品，不超过重量y的时候的最大价值。枚举一下第x件物品的情况:情况一:如果选择第x件物品，则前X-1件物品得到的重量不能超过y-w[x]。情况二:如果不选第x件物品，则前X-1件物品得到的重量不能超过y。所以，dp[x] [y]可能等于dp[x-1][y],也就是不取第x件物品的时，价值和之前一样。也可能是dp[x-1][y-w[x]] +v[x]，也就是决定拿第x件物品的情况，当然会获得x物品的价值。两种可能性中，应该选择价值最大的那个。dp[x][y]=max{dp[x-1][y],dp[x-1][y-w[x]]+v[x]}。对于dp矩阵来说，行数是物品的数量n，行数是背包的重量W。从左到右，再从上到下依次计算所有的dp值即可 12345678910111213141516171819202122232425262728public int maxValue(int[] w, int[] v, int n, int cap) &#123; // write code here int[][] dp = new int[n][cap + 1]; int row; int col = 0; // 初始化列 while (col &lt;= cap) &#123; if (col &gt;= w[0]) break; col++; &#125; while (col &lt;= cap) dp[0][col++] = v[0]; for (row = 1; row &lt; n; row++) &#123; for (col = 1; col &lt;= cap; col++) &#123; if (col - w[row] &lt; 0) dp[row][col] = dp[row - 1][col]; else dp[row][col] = Math.max(dp[row - 1][col - w[row]] + v[row], dp[row - 1][col]); &#125; &#125; return dp[n - 1][cap];&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"LCS（最长公共子序列）","slug":"LCS（最长公共子序列）","date":"2018-02-27T05:14:01.000Z","updated":"2018-08-25T09:20:13.004Z","comments":true,"path":"2018/02/27/LCS（最长公共子序列）/","link":"","permalink":"https://lierabbit.cn/2018/02/27/LCS（最长公共子序列）/","excerpt":"","text":"给定两个字符串A和B，返回两个字符串的最长公共子序列的长度。例如，A=”1A2C3D4B56”，B=”B1D23CA45B6A”，”123456”或者”12C4B6”都是最长公共子序列。给定两个字符串A和B，同时给定两个串的长度n和m，请返回最长公共子序列的长度。保证两串长度均小于等于300。 测试样例：12&quot;1A2C3D4B56&quot;,10,&quot;B1D23CA45B6A&quot;,12返回：6 思路： 矩阵dp第一列，即dp[i][0],代表str1[0..i]与str2[0]的最长公共子序列长度。str2[0]只有一个字符，所以dp[i][0]最大为1。如果str1[i]==str2[0],则令dp[i][0]为1，一旦dp[i][0]被设为1，则令dp[i+1..M][0]全部为1 矩阵dp第一行，即dp[0][j]，与步骤1同理。如果str1[0]==str2[j],则令dp[0][j]为1，一旦dp[0][j]被设为1，则令dp[0][j+1..N]全部为1 其他位置，dp[i][j]的值只可能来自以下三种情况:情况一:可能是dp[i-1][j]的值。这代表str1[0..i-1]与str2[0..j]的最长公共子序列长度。举例:str1=”A1BC2”，str2=”AB34C”。str1[0..3]为” A1BC”,str2[0..4]为” AB34C”，这两部分最长公共子序列为”ABC”即dp[3][4]为3。str1整体和str2整体最长公共子序列也是”ABC”，所以dp[4][4]可能来自dp[3][4].情况二:同理可知，dp[i][j]的值也可能是dp[i][j-1].情况三:如果str1[i]==str2[j],还可能是dp[i-1][j-1]+1的值。举例:比如str1=”ABCD”,str2=”ABCD”.str1[0..2]即”ABC”与str2[0..2]即”ABC”的最长公共子序列为”ABC”，也就是dp[2][2]为3。因为str1和str2的最后一个字符都是” D”，所以dp[i][j]=dp[i-1][j-1]+1.三种可能的值中，选最大值作为dp[i][j]的值。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public int findLCS(String A, int n, String B, int m) &#123; // write code here if (A == null || A.length() == 0 || B == null || B.length() == 0) return 0; int[][] dp = new int[n][m]; // 初始化列 int row = 0; while (row &lt; n) &#123; if (B.charAt(0) == A.charAt(row)) &#123; dp[row][0] = 1; row++; break; &#125; else dp[row][0] = 0; row++; &#125; while (row &lt; n) dp[row++][0] = 1; // 初始化行 int col = 0; while (col &lt; m) &#123; if (A.charAt(0) == B.charAt(col)) &#123; dp[0][col] = 1; col++; break; &#125; else dp[0][col] = 0; col++; &#125; while (col &lt; m) dp[0][col++] = 1; for (row = 1; row &lt; n; row++) &#123; for (col = 1; col &lt; m; col++) &#123; int max = Math.max(dp[row - 1][col], dp[row][col - 1]); if (A.charAt(row) == B.charAt(col)) max = Math.max(max, dp[row - 1][col - 1] + 1); dp[row][col] = max; &#125; &#125; return dp[row - 1][col - 1];&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"LIS（最长上升子序列）","slug":"LIS（最长上升子序列）","date":"2018-02-27T05:06:20.000Z","updated":"2018-08-25T09:12:31.522Z","comments":true,"path":"2018/02/27/LIS（最长上升子序列）/","link":"","permalink":"https://lierabbit.cn/2018/02/27/LIS（最长上升子序列）/","excerpt":"","text":"这是一个经典的LIS(即最长上升子序列)问题，请设计一个尽量优的解法求出序列的最长上升子序列的长度。给定一个序列A及它的长度n(长度小于等于500)，请返回LIS的长度。 测试样例：12[1,4,2,5,3],5返回：3 思路：记录以每一个数结尾的最大上升子序列长度，取最大的即为结果maxs[i]表示以maxs[i]结尾的最大上升子序列长度，maxs[i] = 前面所有比它小的数的最大上升子序列长度中最大的+1 1234567891011121314151617181920public int getLIS(int[] arr, int n) &#123; // write code here if (arr == null || arr.length == 0) return 0; int[] maxs = new int[n]; maxs[0] = 1; int maxLen = 1; for (int i = 1; i &lt; n; i++) &#123; int max = 1; for (int k = 0; k &lt; i; k++) &#123; if (arr[i] &gt; arr[k]) max = Math.max(max, maxs[k] + 1); &#125; maxs[i] = max; maxLen = Math.max(maxLen, max); &#125; return maxLen;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"矩阵最小路径和","slug":"矩阵最小路径和","date":"2018-02-26T15:34:42.000Z","updated":"2018-08-25T09:08:32.395Z","comments":true,"path":"2018/02/26/矩阵最小路径和/","link":"","permalink":"https://lierabbit.cn/2018/02/26/矩阵最小路径和/","excerpt":"","text":"有一个矩阵map，它每个格子有一个权值。从左上角的格子开始每次只能向右或者向下走，最后到达右下角的位置，路径上所有的数字累加起来就是路径和，返回所有的路径中最小的路径和。给定一个矩阵map及它的行数n和列数m，请返回最小路径和。保证行列数均小于等于100. 测试样例：12[[1,2,3],[1,1,1]],2,3返回：4 思路： 1234567891011121314151617181920public int getMin(int[][] map, int n, int m) &#123; // write code here int[][] dp = new int[n][m]; for (int row = 0; row &lt; n; row++) &#123; if (row == 0) dp[row][0] = map[row][0]; else dp[row][0] = dp[row - 1][0] + map[row][0]; &#125; for (int col = 1; col &lt; m; col++) dp[0][col] = dp[0][col - 1] + map[0][col]; for (int row = 1; row &lt; n; row++) &#123; for (int col = 1; col &lt; m; col++) &#123; dp[row][col] = map[row][col] + Math.min(dp[row - 1][col], dp[row][col - 1]); &#125; &#125; return dp[n - 1][m - 1];&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"台阶问题","slug":"台阶问题","date":"2018-02-26T15:00:08.000Z","updated":"2018-08-25T09:05:48.592Z","comments":true,"path":"2018/02/26/台阶问题/","link":"","permalink":"https://lierabbit.cn/2018/02/26/台阶问题/","excerpt":"","text":"有n级台阶，一个人每次上一级或者两级，问有多少种走完n级台阶的方法。为了防止溢出，请将结果Mod 1000000007给定一个正整数int n，请返回一个数，代表上楼的方式数。保证n小于等于100000。测试样例： 121返回：1 思路： 1级台阶只有一种方式：往上走一级 2级台阶2种方式：往上走两级 3级及以上台阶：f(i)=f(i-1)+f(i-2) 1234567891011121314151617public int countWays(int n) &#123; // write code here if (n == 1) return 1; else if (n == 2) return 2; else &#123; int[] a = new int[n + 1]; a[1] = 1; a[2] = 2; for (int i = 3; i &lt;= n; i++) &#123; a[i] = (a[i - 1] + a[i - 2]) % 1000000007; &#125; return a[n]; &#125;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"找零钱","slug":"找零钱","date":"2018-02-26T07:01:49.000Z","updated":"2018-08-25T08:48:12.496Z","comments":true,"path":"2018/02/26/找零钱/","link":"","permalink":"https://lierabbit.cn/2018/02/26/找零钱/","excerpt":"","text":"有数组money，money中所有的值都为正数且不重复。每个值代表一种面值的货币，每种面值的货币可以使用任意张，再给定一个整数aim(小于等于1000)代表要找的钱数，求换钱有多少种方法。给定数组money及它的大小(小于等于50)，同时给定一个整数aim，请返回有多少种方法可以凑成aim。测试样例： 12[1,2,4],3,3返回：2 假设arr={5、10、25、1},aim=1000。 暴力搜索 用0张5元的货币，让[10,25,1]组成剩下的1000 ，最终方法数记为—————- res1 用1张5元的货币，让[10,25,1]组成剩下的995 ，最终方法数记为—————- res2 用2张5元的货币，让[10,25,1]组成剩下的990 ，最终方法数记为—————- res3············································································································································································································································································································································································································ 用200张5元的货币，让[10,25,1]组成剩下的0 ，最终方法数记为————— res201res = res1 + res2 + res3 + ······+ res201 123456789101112public int process1(int[] money, int index, int aim) &#123; int res = 0; if (index == money.length) res = aim == 0 ? 1 : 0; // 是否成功组成aim else &#123; for (int i = 0; money[index] * i &lt;= aim; i++) &#123; res += process1(money, index + 1, aim - money[index] * i); &#125; &#125; return res;&#125; 记忆搜索：由于暴力搜索由许多重复计算，改进而得例如：如果已经使用0张5元和1张10元的情况下，后续将求:process1(money,2,990)2 :表示money剩下的钱为money[2,3],即[25,1]990 :表示要找的剩余钱数。当已经使用2张5元和0张10元的情况下，后续还是要求process1(money,2,990)改进方式：发现递归过程只与index与aim有关，将index与aim的结果保存起来，若已经出现，则直接返回之前计算的结果 12345678910111213141516171819202122public int process2(int[] money, int index, int aim, int[][] map) &#123; int res = 0; if (index == money.length) res = aim == 0 ? 1 : 0; else &#123; int row = index + 1; int col; int cacheWays; for (int i = 0; money[index] * i &lt;= aim; i++) &#123; col = aim - money[index] * i; cacheWays = map[row][col]; if (cacheWays != 0) &#123; res += cacheWays == -1 ? 0 : cacheWays; &#125; else res += process2(money, row, col, map); &#125; &#125; map[index][aim] = res == 0 ? -1 : res; return res;&#125; 动态规划：按序计算从简单到复杂的情况记忆搜索方法与动态规划方法的联系 记忆化搜索方法就是某种形态的动态规划方法，记忆化搜索方法不关心到达某一个递归过程的路径。 只是单纯地对计算过的递归过程进行记录，避免重复的递归过程。 动态规划的方法则是规定好每一个递归过程的计算顺序，依次进行计算，后面的计算过程严格依赖前面的计算过程。 两者都是空间换时间的方法，也都有枚举的过程，区别就在于动态规划规定计算顺序，而记忆搜索不用规定。 什么是动态规划方法 其本质是利用申请的空间来记录每一个暴力搜索的计算结果，下次要用结果的时候直接使用，而不在进行重复的递归过程。 动态规划规定每一种递归状态的计算顺序，依次进行计算。 1234567891011121314151617181920212223public int process3(int[] money, int index, int aim) &#123; int[][] dp = new int[money.length][aim + 1]; for (int i = 0; i &lt; money.length; i++) &#123; // 组成0的方法只有1种那就是不用 dp[i][0] = 1; &#125; for (int i = 0; i &lt;= aim; i++) &#123; // 只使用money[0]货币的情况下组成i的方法有几种 if (i % money[0] == 0) dp[0][i] = 1; else dp[0][i] = 0; &#125; for (int i = 1; i &lt; money.length; i++) &#123; for (int j = 1; j &lt;= aim; j++) &#123; for (int k = 0; k * money[i] &lt;= j; k++) dp[i][j] += dp[i - 1][j - money[i] * k]; &#125; &#125; return dp[money.length - 1][aim];&#125; 优化动态规划 12345678910111213141516171819202122232425public int process4(int[] money, int index, int aim) &#123; int[][] dp = new int[money.length][aim + 1]; for (int i = 0; i &lt; money.length; i++) &#123; // 组成0的方法只有1种那就是不用 dp[i][0] = 1; &#125; for (int i = 0; i &lt;= aim; i++) &#123; // 只使用money[0]货币的情况下组成i的方法有几种 if (i % money[0] == 0) dp[0][i] = 1; else dp[0][i] = 0; &#125; for (int i = 1; i &lt; money.length; i++) &#123; for (int j = 1; j &lt;= aim; j++) &#123; if (j - money[i] &gt;= 0) dp[i][j] = dp[i][j - money[i]] + dp[i - 1][j]; else dp[i][j] = dp[i - 1][j]; &#125; &#125; return dp[money.length - 1][aim];&#125; 4种方法的集合123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145public class Exchange &#123; public int countWays(int[] money, int n, int aim) &#123; // write code here if (money == null || money.length == 0 || aim &lt;= 0) return 0; // 暴力搜索// return process1(money, 0, aim); // 记忆搜索// int[][] map = new int[n + 1][aim + 1];// return process2(money, 0, aim, map); // 由记忆搜索引出的动态规划// return process3(money, n, aim); // 动态规划 return process4(money, n, aim); &#125; /** * 暴力搜索 * 用money[index...money.length-1]这里的钱组成aim，有几种方法 * * @param money * @param index * @param aim * @return */ public int process1(int[] money, int index, int aim) &#123; int res = 0; if (index == money.length) res = aim == 0 ? 1 : 0; // 是否成功组成aim else &#123; for (int i = 0; money[index] * i &lt;= aim; i++) &#123; res += process1(money, index + 1, aim - money[index] * i); &#125; &#125; return res; &#125; /** * 记忆搜索 * 用money[index...money.length-1]这里的钱组成aim，有几种方法 * * @param money * @param index * @param aim * @return */ public int process2(int[] money, int index, int aim, int[][] map) &#123; int res = 0; if (index == money.length) res = aim == 0 ? 1 : 0; else &#123; int row = index + 1; int col; int cacheWays; for (int i = 0; money[index] * i &lt;= aim; i++) &#123; col = aim - money[index] * i; cacheWays = map[row][col]; if (cacheWays != 0) &#123; res += cacheWays == -1 ? 0 : cacheWays; &#125; else res += process2(money, row, col, map); &#125; &#125; map[index][aim] = res == 0 ? -1 : res; return res; &#125; /** * 由记忆搜索引出的动态规划 * @param money * @param index * @param aim * @return */ public int process3(int[] money, int index, int aim) &#123; int[][] dp = new int[money.length][aim + 1]; for (int i = 0; i &lt; money.length; i++) &#123; // 组成0的方法只有1种那就是不用 dp[i][0] = 1; &#125; for (int i = 0; i &lt;= aim; i++) &#123; // 只使用money[0]货币的情况下组成i的方法有几种 if (i % money[0] == 0) dp[0][i] = 1; else dp[0][i] = 0; &#125; for (int i = 1; i &lt; money.length; i++) &#123; for (int j = 1; j &lt;= aim; j++) &#123; for (int k = 0; k * money[i] &lt;= j; k++) dp[i][j] += dp[i - 1][j - money[i] * k]; &#125; &#125; return dp[money.length - 1][aim]; &#125; /** * 优化后的动态规划 * @param money * @param index * @param aim * @return */ public int process4(int[] money, int index, int aim) &#123; int[][] dp = new int[money.length][aim + 1]; for (int i = 0; i &lt; money.length; i++) &#123; // 组成0的方法只有1种那就是不用 dp[i][0] = 1; &#125; for (int i = 0; i &lt;= aim; i++) &#123; // 只使用money[0]货币的情况下组成i的方法有几种 if (i % money[0] == 0) dp[0][i] = 1; else dp[0][i] = 0; &#125; for (int i = 1; i &lt; money.length; i++) &#123; for (int j = 1; j &lt;= aim; j++) &#123; if (j - money[i] &gt;= 0) dp[i][j] = dp[i][j - money[i]] + dp[i - 1][j]; else dp[i][j] = dp[i - 1][j]; &#125; &#125; return dp[money.length - 1][aim]; &#125; public static void main(String[] args) &#123; int[] money = &#123;1, 2, 5&#125;; Exchange exchange = new Exchange(); int ways = exchange.countWays(money, 3, 100); System.out.println(ways); &#125;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"机器吐球","slug":"机器吐球","date":"2018-02-25T06:36:35.000Z","updated":"2018-08-25T08:31:23.978Z","comments":true,"path":"2018/02/25/机器吐球/","link":"","permalink":"https://lierabbit.cn/2018/02/25/机器吐球/","excerpt":"","text":"有一个机器按自然数序列的方式吐出球，1号球，2号球，3号球等等。你有一个袋子，袋子里最多只能装下K个球，并且除袋子以外，你没有更多的空间，一个球一旦扔掉，就再也不可拿回。设计一种选择方式，使得当机器吐出第N号球的时候，你袋子中的球数是K个，同时可以保证从1号球到N号球中的每一个，被选进袋子的概率都是K/N。举一个更具体的例子，有一个只能装下10个球的袋子，当吐出100个球时，袋子里有10 球，并且1~100号中的每一个球被选中的概率都是10/100。然后继续吐球，当吐出1000个球时，袋子里有 10 个球，并且1~1000号中的每一个球被选中的概率都是10/1000。继续吐球，当吐出i个球时，袋子里有10个球，并且1~i号中的每一个球被选中的概率都是10/i。也就是随着N的变化，1~N号球被选中的概率动态变化成k/N。请将吐出第N个球时袋子中的球的编号返回。 思路：此题核心解法为蓄水池抽样算法，过程如下: 处理1~k号球时，直接放进袋子里 处理第i号球时，以k/i的概率决定是否将第i号球放进袋子。如果不决定将第i号球放进袋子，直接扔掉第i号球。如果决定将第i号球放进袋子，那么就从袋子里的k个球中随机扔掉一个，然后把第i号球放入袋子 处理第i+1号球时，重复步骤1或步骤2 123456789101112131415private int[] selected = null;private static Random rand = new Random(12345);// 每次拿一个球都会调用这个函数，N表示第i次调用public int[] carryBalls(int N, int k) &#123; if (selected == null) selected = new int[k]; if (N &lt;= k) &#123; selected[N - 1] = N; &#125; else &#123; if (rand.nextInt(N) &lt; k) // i/k的概率是否放入 selected[rand.nextInt(k)] = N; // 1/k的概率随机丢弃一个旧的，放入新的 &#125; return selected;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"随机数组打印","slug":"随机数组打印","date":"2018-02-25T06:05:56.000Z","updated":"2018-08-25T08:30:12.857Z","comments":true,"path":"2018/02/25/随机数组打印/","link":"","permalink":"https://lierabbit.cn/2018/02/25/随机数组打印/","excerpt":"","text":"给定一个长度为N且没有重复元素的数组arr和一个整数M，实现函数等概率随机打印arr中的M个数。 思路： 随机在[0，N-1]抽一个数打印，与N-1交换 随机在[0，N-2]抽一个数打印，与N-2交换 …… 123456789101112131415161718public int[] print(int[] arr, int N, int M) &#123; Random random = new Random(); int[] res = new int[M]; int randomValue; for (int i = 0; i &lt; M; i++) &#123; randomValue = random.nextInt(N - i); res[0] = arr[randomValue]; swap(arr, randomValue, N - i - 1); &#125; return res;&#125;public void swap(int[] arr, int i, int j) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"随机区间函数","slug":"随机区间函数","date":"2018-02-25T05:49:42.000Z","updated":"2018-08-25T08:30:17.577Z","comments":true,"path":"2018/02/25/随机区间函数/","link":"","permalink":"https://lierabbit.cn/2018/02/25/随机区间函数/","excerpt":"","text":"假设函数f()等概率随机返回一个在[0,1)范围上的浮点数，那么我们知道，在[0,x)区间上的数出现的概率为x(0&lt;x≤1)。给定一个大于0的整数k，并且可以使用f()函数，请实现一个函数依然返回在[0,1)范围上的数，但是在[0,x)区间上的数出现的概率为x的k次方。 思路：先来看看如何把[0，X )范围上的数，从概率X调整为概率X^2作法:调用两次f( )，返回较大的数即可。所以本题只用调用K次f( )，返回较大的数，即可。 12345678910111213private Random rand = new Random(12345);public double f() &#123; return rand.nextFloat();&#125;// 请调用f()函数实现public double random(int k, double x) &#123; double max = -1; for (int i = 0; i &lt; k; i++) max = Math.max(max, f()); return max;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"随机01","slug":"随机01","date":"2018-02-25T05:14:39.000Z","updated":"2018-08-25T08:16:40.812Z","comments":true,"path":"2018/02/25/随机01/","link":"","permalink":"https://lierabbit.cn/2018/02/25/随机01/","excerpt":"","text":"给定一个以p概率产生0，以1-p概率产生1的随机函数RandomP::f()，p是固定的值，但你并不知道是多少。除此之外也不能使用任何额外的随机机制，请用RandomP::f()实现等概率随机产生0和1的随机函数。 思路： f()产生0的概率P，产生1的概率1-P 产生01和10序列的概率都为P * (1-P ) 不断调用f(),直到能够产生01或10，序列终止。 如果产生了01，返回0。 如果产生了10，则返回1,即可。 123456789101112131415161718private static double p = new Random().nextFloat();// 随机概率ppublic static int f() &#123; return new Random().nextFloat() &lt; p ? 0 : 1;&#125;public int random01() &#123; // 通过f函数实现01等概率返回 int a; int b; while (true) &#123; a = f(); b = f(); if (a != b) return a &gt; b ? 1 : 0; &#125;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"随机函数","slug":"随机函数","date":"2018-02-25T05:02:24.000Z","updated":"2018-08-25T08:11:21.765Z","comments":true,"path":"2018/02/25/随机函数/","link":"","permalink":"https://lierabbit.cn/2018/02/25/随机函数/","excerpt":"","text":"给定一个等概率随机产生1~5的随机函数，除此之外，不能使用任何额外的随机机制，请实现等概率随机产生1~7的随机函数。(给定一个可调用的Random5::random()方法,可以等概率地随机产生1～5的随机函数) 思路：得到一串均匀分布且长度大于7的连续序列即可（甚至都不需要连续，只要保证能产生7个以上等概率的数即可），在这个序列里选中7个（或7的倍数个），若得到的数不是这7个中的，重新产生，这样这7个数的概率肯定是相同的。步骤：1.已经有等概率随机产生1、2、3、4、5的随机函数。2.根据步骤1得到的结果减1，将得到f( ) -&gt; 0、1、2、3、43.f( )x5 -&gt; 0、5、10、15、204.f( )x5+f () -&gt; 0、1、2、3、4…..24 注意这两个f( )是分别调用的，不要化简。5.如果步骤4产生的数大于20，则重复进行步骤4直到产生的结果在0~20之间。6.步骤5的结果将等概率随机产生0~20，所以步骤5的结果%7之后等概率产生0~6。7.步骤6的结果加1，将等概率产生1~7。 1234567891011121314private static Random rand = new Random(123456);// 随机产生[1,5]private int rand5() &#123; return 1 + rand.nextInt(5);&#125;// 通过rand5实现rand7public int randomNumber() &#123; int value = (rand5() - 1) * 5 + rand5() - 1; while (value &gt; 20) value = (rand5() - 1) * 5 + rand5() - 1; return value % 7 + 1;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"蚂蚁","slug":"蚂蚁","date":"2018-02-25T03:13:03.000Z","updated":"2018-08-25T07:48:33.014Z","comments":true,"path":"2018/02/25/蚂蚁/","link":"","permalink":"https://lierabbit.cn/2018/02/25/蚂蚁/","excerpt":"","text":"n只蚂蚁从正n边形的n个定点沿着边移动，速度是相同的，问它们碰头的概率是多少？给定一个正整数n，请返回一个数组，其中两个元素分别为结果的分子和分母，请化为最简分数。测试样例： 123返回：[3,4] 思路：如果蚂蚁移动方向不都相同，则必定碰头。只有全部顺时针或者逆时针方向移动才不会碰头 123456789101112131415161718192021222324public int[] collision(int n) &#123; // write code here int all = (int) Math.pow(2, n); int g = gcd(all, all - 2); int[] res = new int[2]; res[0] = (all - 2) / g; res[1] = all / g; return res;&#125;// 最大公约数public int gcd(int x, int y) &#123; int temp; while (y != 0) &#123; temp = y; y = x % y; x = temp; &#125; return x;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"足球比赛","slug":"足球比赛","date":"2018-02-24T04:24:20.000Z","updated":"2018-08-25T07:47:26.554Z","comments":true,"path":"2018/02/24/足球比赛/","link":"","permalink":"https://lierabbit.cn/2018/02/24/足球比赛/","excerpt":"","text":"有2k只球队，有k-1个强队，其余都是弱队，随机把它们分成k组比赛，每组两个队，问两强相遇的概率是多大？给定一个数k，请返回一个数组，其中有两个元素，分别为最终结果的分子和分母，请化成最简分数测试样例： 124返回：[3,7] 思路：1.求出全部分组情况2.求出两强不相遇的情况3.全部分组-两强不相遇=两强相遇 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public int[] calc(int k) &#123; // write code here int all = 1; // 分组全部情况 int k2 = 2 * k; while (k2 != 0) &#123; all *= k2 - 1; k2 -= 2; &#125; int noTowStrong = C(k + 1, k - 1) * A(k - 1, k - 1); // 两强不相遇的情况 int[] res = new int[2]; res[0] = all - noTowStrong; res[1] = all; int g = gcd(res[0], res[1]); res[0] /= g; res[1] /= g; return res;&#125;// 最大公约数int gcd(int x, int y) &#123; while (y != 0) &#123; int t = y; y = x % y; x = t; &#125; return x;&#125;/** * 模拟C运算 * * @param down 下标 * @param up 上标 * @return */public int C(int down, int up) &#123; return A(down, up) / A(up, up);&#125;/** * 模拟A运算 * * @param down 下标 * @param up 上标 * @return */public int A(int down, int up) &#123; int data = 1; for (int i = 0; i &lt; up; i++) data *= down--; return data;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"错装信封","slug":"错装信封","date":"2018-02-24T03:46:24.000Z","updated":"2018-08-25T07:42:57.311Z","comments":true,"path":"2018/02/24/错装信封/","link":"","permalink":"https://lierabbit.cn/2018/02/24/错装信封/","excerpt":"","text":"有n个信封，包含n封信，现在把信拿出来，再装回去，要求每封信不能装回它原来的信封，问有多少种装法?给定一个整数n，请返回装发个数，为了防止溢出，请返回结果Mod 1000000007的值。保证n的大小小于等于300。测试样例： 122返回：1 思路：对于n封信按照题目要求的装法即为f(n)假设第n封信放入了第i个信封情况一:第i封信也放入了第n个信封中，后续为f(n-2)情况二:第i封信没放入了第n个信封中，后续为f(n-1)n封信放入i个信封，i的选择有(n-1)种所以总数为f(n)= (n-1)*(f(n-1)+f(n-2)) 1234567891011121314public int countWays(int n) &#123; // write code here if (n == 1) return 0; else if (n == 2) return 1; else &#123; int pre = 0, last = 1; for (int i = 3; i &lt;= n; ++i) &#123; int tmp = (int) ((long) (i - 1) * (long) (pre + last) % 1000000007); pre = last; last = tmp; &#125; return last; &#125;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"高矮排列","slug":"高矮排列","date":"2018-02-24T02:34:11.000Z","updated":"2018-08-25T07:39:29.781Z","comments":true,"path":"2018/02/24/高矮排列/","link":"","permalink":"https://lierabbit.cn/2018/02/24/高矮排列/","excerpt":"","text":"12个高矮不同的人，排成两排，每排必须是从矮到高排列，而且第二排比对应的第一排的人高，问排列方式有多少种？ 给定一个偶数n，请返回所求的排列方式个数。保证结果在int范围内。 测试样例： 121返回：1 思路：同进出栈 1234567891011121314151617181920212223242526272829public int countWays(int n) &#123; // write code here return C(n, n / 2) / (n / 2 + 1);&#125;/** * 模拟C运算 * * @param down 下标 * @param up 上标 * @return */public int C(int down, int up) &#123; return A(down, up) / A(up, up);&#125;/** * 模拟A运算 * * @param down 下标 * @param up 上标 * @return */public int A(int down, int up) &#123; int data = 1; for (int i = 0; i &lt; up; i++) data *= down--; return data;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"二叉树统计","slug":"二叉树统计","date":"2018-02-24T02:24:22.000Z","updated":"2018-08-25T07:36:25.056Z","comments":true,"path":"2018/02/24/二叉树统计/","link":"","permalink":"https://lierabbit.cn/2018/02/24/二叉树统计/","excerpt":"","text":"求n个无差别的节点构成的二叉树有多少种不同的结构？给定一个整数n，请返回不同结构的二叉树的个数。保证结果在int范围内。测试样例： 121返回：1 思路：假设n个无差别的节点构成不同的结构数为f(n)f(0)表示空树，所以规定种数为1种。以1节点为头时，结构数为1f(n-1).以2节点为头时，结构数为1f(n-2).以3节点为头时，结构数为f(2)f(n-3).以4节点为头时，结构数为f(3)f(n-4).以5节点为头时，结构数为f(4)f(n-5).。。。。。。。。。。。。。。。。假设n个无差别的节点构成不同的结构数为f(n)f(0)=1,f(1)=1,f(2)=2,f(3)=5时f(n)=f(0)f(n-1)+f(1)f(n-2)+f(3)f(n-4)+……..+ ……..+f(n-1)*f(0)=C(2n,n)/n+1 123456789101112131415161718192021222324252627282930public int countWays(int n) &#123; // write code here return C(2 * n, n) / (n + 1);&#125;/** * 模拟C运算 * * @param down 下标 * @param up 上标 * @return */public int C(int down, int up) &#123; return A(down, up) / A(up, up);&#125;/** * 模拟A运算 * * @param down 下标 * @param up 上标 * @return */public int A(int down, int up) &#123; int data = 1; for (int i = 0; i &lt; up; i++) data *= down--; return data;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"排队买票","slug":"排队买票","date":"2018-02-24T02:00:11.000Z","updated":"2018-08-25T07:33:26.515Z","comments":true,"path":"2018/02/24/排队买票/","link":"","permalink":"https://lierabbit.cn/2018/02/24/排队买票/","excerpt":"","text":"2n个人排队买票，n个人拿5块钱，n个人拿10块钱，票价是5块钱1张，每个人买一张票，售票员手里没有零钱，问有多少种排队方法让售票员可以顺利卖票。给定一个整数n，请返回所求的排队方案个数。保证结果在int范围内。测试样例： 121返回：1 思路：同进出栈，将持5元者到达视作将5元入栈，持10元者到达视作使栈中某5元出栈 123456789101112131415161718192021222324252627282930public int countWays(int n) &#123; // write code here return C(2 * n, n) / (n + 1);&#125;/** * 模拟C运算 * * @param down 下标 * @param up 上标 * @return */public int C(int down, int up) &#123; return A(down, up) / A(up, up);&#125;/** * 模拟A运算 * * @param down 下标 * @param up 上标 * @return */public int A(int down, int up) &#123; int data = 1; for (int i = 0; i &lt; up; i++) data *= down--; return data;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"括号序列","slug":"括号序列","date":"2018-02-24T01:19:10.000Z","updated":"2018-08-25T07:30:59.912Z","comments":true,"path":"2018/02/24/括号序列/","link":"","permalink":"https://lierabbit.cn/2018/02/24/括号序列/","excerpt":"","text":"假设有n对左右括号，请求出合法的排列有多少个？合法是指每一个括号都可以找到与之配对的括号，比如n=1时，()是合法的，但是)(为不合法。给定一个整数n，请返回所求的合法排列数。保证结果在int范围内。测试样例： 121返回：1 思路：同进出栈，只需将左括号看成进栈，右括号看成出栈 123456789101112131415161718192021222324252627282930public int countLegalWays(int n) &#123; // write code here return C(2 * n, n) / (n + 1);&#125;/** * 模拟C运算 * * @param down 下标 * @param up 上标 * @return */public int C(int down, int up) &#123; return A(down, up) / A(up, up);&#125;/** * 模拟A运算 * * @param down 下标 * @param up 上标 * @return */public int A(int down, int up) &#123; int data = 1; for (int i = 0; i &lt; up; i++) data *= down--; return data;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"进出栈","slug":"进出栈","date":"2018-02-24T00:35:15.000Z","updated":"2018-08-25T07:34:53.710Z","comments":true,"path":"2018/02/24/进出栈/","link":"","permalink":"https://lierabbit.cn/2018/02/24/进出栈/","excerpt":"","text":"n个数进出栈的顺序有多少种？假设栈的容量无限大。给定一个整数n，请返回所求的进出栈顺序个数。保证结果在int范围内。测试样例： 121返回：1 常规分析：首先，我们设f（n）=序列个数为n的出栈序列种数。（我们假定，最后出栈的元素为k，显然，k取不同值时的情况是相互独立的，也就是求出每种k最后出栈的情况数后可用加法原则，由于k最后出栈，因此，在k入栈之前，比k小的值均出栈，此处情况有f(k-1)种，而之后比k大的值入栈，且都在k之前出栈，因此有f(n-k)种方式，由于比k小和比k大的值入栈出栈情况是相互独立的，此处可用乘法原则，f(n-k)*f(k-1)种，求和便是Catalan递归式）首次出空之前第一个出栈的序数k将1~n的序列分成两个序列，其中一个是1~k-1，序列个数为k-1，另外一个是k+1~n，序列个数是n-k。此时，我们若把k视为确定一个序数，那么根据乘法原理，f（n）的问题就等价于——序列个数为k-1的出栈序列种数乘以序列个数为n - k的出栈序列种数，即选择k这个序数的f（n）=f（k-1）×f（n-k）。而k可以选1到n，所以再根据加法原理，将k取不同值的序列种数相加，得到的总序列种数为：f（n）=f（0）f（n-1）+f（1）f（n-2）+……+f（n-1）f（0）。看到此处，再看看卡特兰数的递推式，答案不言而喻，即为f（n）=h（n）= C（2n,n）/（n+1）= c（2n,n）-c（2n,n-1）（n=0，1，2，……）。最后，令f（0）=1，f（1）=1。 非常规分析：对于每一个数来说，必须进栈一次、出栈一次。我们把进栈设为状态‘1’，出栈设为状态‘0’。n个数的所有状态对应n个1和n个0组成的2n位二进制数。由于等待入栈的操作数按照1‥n的顺序排列、入栈的操作数b大于等于出栈的操作数a(a≤b)，因此输出序列的总数目=由左而右扫描由n个1和n个0组成的2n位二进制数，1的累计数不小于0的累计数的方案种数。在2n位二进制数中填入n个1的方案数为c(2n,n),不填1的其余n位自动填0。从中减去不符合要求（由左而右扫描，0的累计数大于1的累计数）的方案数即为所求。不符合要求的数的特征是由左而右扫描时，必然在某一奇数位2m+1位上首先出现m+1个0的累计数和m个1的累计数，此后的2(n-m)-1位上有n-m个 1和n-m-1个0。如若把后面这2(n-m)-1位上的0和1互换，使之成为n-m个0和n-m-1个1，结果得1个由n+1个0和n-1个1组成的2n位数，即一个不合要求的数对应于一个由n+1个0和n-1个1组成的排列。反过来，任何一个由n+1个0和n-1个1组成的2n位二进制数，由于0的个数多2个，2n为偶数，故必在某一个奇数位上出现0的累计数超过1的累计数。同样在后面部分0和1互换，使之成为由n个0和n个1组成的2n位数，即n+1个0和n-1个1组成的2n位数必对应一个不符合要求的数。因而不合要求的2n位数与n+1个0，n－1个1组成的排列一一对应。显然，不符合要求的方案数为c(2n,n+1)。由此得出输出序列的总数目=c(2n,n)-c(2n,n+1)=c(2n,n)/(n+1)=h(n)。 1234567891011121314151617181920212223242526272829public int countWays(int n) &#123; // write code here return C(2 * n, n) / (n + 1);&#125;/** * 模拟C运算 * * @param down 下标 * @param up 上标 * @return */public int C(int down, int up) &#123; return A(down, up) / A(up, up);&#125;/** * 模拟A运算 * * @param down 下标 * @param up 上标 * @return */public int A(int down, int up) &#123; int data = 1; for (int i = 0; i &lt; up; i++) data *= down--; return data;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"分糖果","slug":"分糖果","date":"2018-02-23T13:18:04.000Z","updated":"2018-08-25T07:21:48.909Z","comments":true,"path":"2018/02/23/分糖果/","link":"","permalink":"https://lierabbit.cn/2018/02/23/分糖果/","excerpt":"","text":"n颗相同的糖果，分给m个人，每人至少一颗，问有多少种分法。给定n和m，请返回方案数，保证n小于等于12，且m小于等于n。测试样例： 1210,3返回：36 思路：如果有10颗，要分给3个人，则相当于在10颗糖中插入两个挡板，分出三个部分，则C(9，2) = 36种 123456789101112131415161718192021222324252627282930public int getWays(int n, int m) &#123; // write code here return C(n - 1, m - 1);&#125;/** * 模拟C运算 * * @param down 下标 * @param up 上标 * @return */public int C(int down, int up) &#123; return A(down, up) / A(up, up);&#125;/** * 模拟A运算 * * @param down 下标 * @param up 上标 * @return */public int A(int down, int up) &#123; int data = 1; for (int i = 0; i &lt; up; i++) data *= down--; return data;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"孤傲的A","slug":"孤傲的A","date":"2018-02-23T13:09:07.000Z","updated":"2018-08-25T07:16:45.859Z","comments":true,"path":"2018/02/23/孤傲的A/","link":"","permalink":"https://lierabbit.cn/2018/02/23/孤傲的A/","excerpt":"","text":"A(A也是他的编号)是一个孤傲的人，在一个n个人(其中编号依次为1到n)的队列中，他于其中的标号为b和标号c的人都有矛盾，所以他不会和他们站在相邻的位置。现在问你满足A的要求的对列有多少种？给定人数n和三个人的标号A,b和c，请返回所求答案，保证人数小于等于11且大于等于3。测试样例： 126,1,2,3288 思路：1.统计全排列情况2.统计ab，ac相邻的情况3.因为ab，ac相邻包含了bac，cab，所以要统计bac，cab的情况4.全排列-ab-ac+bac+cab即为结果 12345678910111213141516171819202122public int getWays(int n, int a, int b, int c) &#123; // write code here int ab = A(n - 1, n - 1) * 2; // ab相邻的情况分为ab,ba两种 int bac = A(n - 2, n - 2) * 2; // bac相邻的情况有bac,cab两种 int all = A(n, n); // 全排列 return all - ab * 2 + bac; // ac与ab一致所以ab*2&#125;/** * 模拟A运算 * * @param down 下标 * @param up 上标 * @return */public int A(int down, int up) &#123; int data = 1; for (int i = 0; i &lt; up; i++) data *= down--; return data;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"站队问题","slug":"站队问题","date":"2018-02-23T12:26:32.000Z","updated":"2018-08-25T07:13:27.388Z","comments":true,"path":"2018/02/23/站队问题/","link":"","permalink":"https://lierabbit.cn/2018/02/23/站队问题/","excerpt":"","text":"n个人站队，他们的编号依次从1到n，要求编号为a的人必须在编号为b的人的左边，但不要求一定相邻，请问共有多少种排法？第二问如果要求a必须在b的左边，并且一定要相邻，请问一共有多少种排法？给定人数n及两个人的编号a和b，请返回一个两个元素的数组，其中两个元素依次为两个问题的答案。保证人数小于等于10。测试样例： 127,1,2返回：[2520,720] 思路： 12345678910111213141516171819202122public int[] getWays(int n, int a, int b) &#123; // write code here int[] res = new int[2]; res[0] = A(n, n) / 2; res[1] = A(n - 1, n - 1); return res;&#125;/** * 模拟A运算 * * @param down 下标 * @param up 上标 * @return */public int A(int down, int up) &#123; int data = 1; for (int i = 0; i &lt; up; i++) data *= down--; return data;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"方格移动","slug":"方格移动","date":"2018-02-23T11:00:06.000Z","updated":"2018-08-25T07:09:42.730Z","comments":true,"path":"2018/02/23/方格移动/","link":"","permalink":"https://lierabbit.cn/2018/02/23/方格移动/","excerpt":"","text":"在XxY的方格中，以左上角格子为起点，右下角格子为终点，每次只能向下走或者向右走，请问一共有多少种不同的走法给定两个正整数int x,int y，请返回走法数目。保证x＋y小于等于12。测试样例： 122,2返回：2 思路：一共走x-1+y-1步，其中必然有y-1步向下，则C(x-1+y-1,y-1)第一个为下标，第二个为上标 1234567891011121314151617181920212223242526272829303132public int countWays(int x, int y) &#123; // write code here --x; --y; return C(x + y, y);&#125;/** * 模拟C运算 * * @param down 下标 * @param up 上标 * @return */public int C(int down, int up) &#123; return A(down, up) / A(up, up);&#125;/** * 模拟A运算 * * @param down 下标 * @param up 上标 * @return */public int A(int down, int up) &#123; int data = 1; for (int i = 0; i &lt; up; i++) data *= down--; return data;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"寻找奇数出现II","slug":"寻找奇数出现II","date":"2018-02-23T07:20:24.000Z","updated":"2018-08-25T07:08:34.798Z","comments":true,"path":"2018/02/23/寻找奇数出现II/","link":"","permalink":"https://lierabbit.cn/2018/02/23/寻找奇数出现II/","excerpt":"","text":"给定一个整型数组arr，其中有两个数出现了奇数次，其他的数都出现了偶数次，找到这两个数。要求时间复杂度为O(N)，额外空间复杂度为O(1)。给定一个整形数组arr及它的大小n，请返回一个数组，其中两个元素为两个出现了奇数次的元素,请将他们按从小到大排列。测试样例： 12[1,2,4,4,2,1,3,5],8返回：[3,5] 思路： 1234567891011121314151617181920212223public int[] findOdds(int[] arr, int n) &#123; // write code here int k1 = 0; int k2 = 0; for (int a : arr) // 假设出现奇数次的两个数为a,b则，k1 = a ^ b k1 ^= a; int rightOne = k1 &amp; (~k1 + 1); // 获取k1的二进制最右边第一个1 for (int a : arr) // 最后k2为a或者b if ((rightOne &amp; a) != 0) // 只有和rightOne在相同位一致的数才有可能是a或b k2 ^= a; int small = Math.min(k2, k1 ^ k2); int big = Math.max(k2, k1 ^ k2); int[] res = new int[2]; res[0] = small; res[1] = big; return res;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"寻找奇数出现","slug":"寻找奇数出现","date":"2018-02-23T06:53:41.000Z","updated":"2018-08-25T07:05:37.674Z","comments":true,"path":"2018/02/23/寻找奇数出现/","link":"","permalink":"https://lierabbit.cn/2018/02/23/寻找奇数出现/","excerpt":"","text":"有一个整型数组A，其中只有一个数出现了奇数次，其他的数都出现了偶数次，请打印这个数。要求时间复杂度为O(N)，额外空间复杂度为O(1)。给定整形数组A及它的大小n，请返回题目所求数字。测试样例： 12[1,2,3,2,1],5返回：3 思路：由于0 ^ n = nn ^ n = 0只要让0^数组里每个元素，最后得到的数就是只出现奇数次的数 12345678public int findOdd(int[] A, int n) &#123; // write code here int temp = 0; for (int a : A) temp ^= a; return temp;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"比较","slug":"比较","date":"2018-02-23T06:39:41.000Z","updated":"2018-08-25T07:02:17.010Z","comments":true,"path":"2018/02/23/比较/","link":"","permalink":"https://lierabbit.cn/2018/02/23/比较/","excerpt":"","text":"对于两个32位整数a和b，请设计一个算法返回a和b中较大的。但是不能用任何比较判断。若两数相同，返回任意一个。给定两个整数a和b，请返回较大的数。测试样例： 121,2返回：2 思路：本函数规定符号位：1非负，0负若a，b符号不同，返回aa符号位+bb符号位，防止溢出若a，b符号相同，使用a-b的符号位c，即返回ac+b(-c) 1234567891011121314151617181920212223public int getMax(int a, int b) &#123; // write code here int c = a - b; int as = sign(a); // 1表示非负，0表示负数 int bs = sign(b); int cs = sign(c); int disab = as ^ bs; // ab符号不相同为1，相同为0 int sameab = flip(disab); // ab符号相同为1，不相同为0 int returnA = disab * as + sameab * cs; int returnB = flip(returnA); return returnA * a + returnB * b;&#125;// 获取int符号位public int sign(int n) &#123; return flip((n &gt;&gt; 31) &amp; 1);&#125;// 反转位public int flip(int n) &#123; return n ^ 1;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"交换","slug":"交换","date":"2018-02-23T06:08:16.000Z","updated":"2018-08-25T06:45:14.594Z","comments":true,"path":"2018/02/23/交换/","link":"","permalink":"https://lierabbit.cn/2018/02/23/交换/","excerpt":"","text":"请编写一个算法，不用任何额外变量交换两个整数的值。给定一个数组num，其中包含两个值，请不用任何额外变量交换这两个值，并将交换后的数组返回。测试样例： 12[1,2]返回：[2,1] 思路：使用异或进行交换例如 a = a0, b = b0a = a ^ b，则a = a0 ^ b0b = a ^ b，则b = a0 ^ b0 ^ b0 = a0a = a ^ b，则a = a0 ^ b0 ^ a0 = b0至此交换完成 12345678public int[] getSwap(int[] num) &#123; // write code here num[0] = num[0] ^ num[1]; num[1] = num[0] ^ num[1]; num[0] = num[0] ^ num[1]; return num;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"最大二叉子树","slug":"最大二叉子树","date":"2018-02-23T05:36:11.000Z","updated":"2018-08-25T06:26:47.536Z","comments":true,"path":"2018/02/23/最大二叉子树/","link":"","permalink":"https://lierabbit.cn/2018/02/23/最大二叉子树/","excerpt":"","text":"有一棵二叉树，其中所有节点的值都不一样,找到含有节点最多 的搜索二叉子树,并返回这棵子树的头节点.给定二叉树的头结点root，请返回所求的头结点,若出现多个节点最多的子树，返回头结点权值最大的。 思路：以节点node为头的树中，最大的搜索二叉子树只可能来自以下两种情况:1.来自node左子树上的最大搜索二叉子树是以node左孩子为头的，并且来自node右子树上的最大搜索二叉子树是以node右孩子为头的，node左子树上的最大搜索二叉子树的最大值小于node的节点值，node右子树上的最大搜索二叉子树的最小值大于node的节点值，那么以节点node为头的整棵树都是搜索二叉树。2.如果不满足第1种情况，说明以节点node为头的树整体不能连成搜索二叉树。这种情况下，以node为头的树上的最大搜索二叉子树是来自node的左子树上的最大搜索二叉子树和来自node的右子树上的最大搜索二叉子树之间，节点数较多的那个。 12345678910111213141516171819202122232425262728293031323334public TreeNode getMax(TreeNode root) &#123; // write code here return getMax(root, new int[3]);&#125;public TreeNode getMax(TreeNode node, int[] temp) &#123; if (node == null) &#123; temp[0] = Integer.MAX_VALUE; // 最小值取最大值，这样所有的数都能比它小 temp[1] = Integer.MIN_VALUE; // 最大值取最小值，这样所有的数都能比它大 temp[2] = 0; return null; &#125; TreeNode lMaxNode = getMax(node.left, temp); int lMin = temp[0]; // 最小值 int lMax = temp[1]; // 最大值 int lNum = temp[2]; // 节点数 TreeNode rMaxNode = getMax(node.right, temp); int rMin = temp[0]; int rMax = temp[1]; int rNum = temp[2]; temp[0] = Math.min(lMin, node.val); // 更新最小值 temp[1] = Math.max(rMax, node.val); // 更新最大值 if (lMaxNode == node.left &amp;&amp; rMaxNode == node.right &amp;&amp; lMax &lt; node.val &amp;&amp; rMin &gt; node.val) &#123; temp[2] = lNum + rNum + 1; // 更新节点数 return node; &#125; else &#123; temp[2] = Math.max(lNum, rNum); return lNum &gt; rNum ? lMaxNode : rMaxNode; // 当相等的时候取右边的，因为右边的权值大 &#125;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"树上最远距离","slug":"树上最远距离","date":"2018-02-22T15:04:52.000Z","updated":"2018-08-24T14:30:34.072Z","comments":true,"path":"2018/02/22/树上最远距离/","link":"","permalink":"https://lierabbit.cn/2018/02/22/树上最远距离/","excerpt":"","text":"从二叉树的节点A出发，可以向上或者向下走，但沿途的节点只能经过一次，当到达节点B时，路径上的节点数叫作A到B的距离。对于给定的一棵二叉树，求整棵树上节点间的最大距离。给定一个二叉树的头结点root，请返回最大距离。保证点数大于等于2小于等于500. 思路：一个以h为头的树上,最大距离只可能来自以下三种情况:1.h的左子树上的最大距离2.h的右子树上的最大距离3.h左子树上离h左孩子最远的距离，加上h自身这个节点，再加h右子树上离h右孩子的最远距离，也就是两个节点分别来自h两侧子树的情况三个值中最大的那个就是以h为头的整棵树上最远的距离。 123456789101112131415161718192021public int findLongest(TreeNode root) &#123; int[] temp = new int[1]; return find(root, temp);&#125;public int find(TreeNode node, int[] temp) &#123; if (node == null) &#123; temp[0] = 0; return 0; &#125; int lMax = find(node.left, temp); int maxFormLeft = temp[0]; int rMax = find(node.right, temp); int maxFormRight = temp[0]; int cMax = maxFormLeft + maxFormRight + 1; temp[0] = Math.max(maxFormLeft, maxFormRight) + 1; return Math.max(Math.max(lMax, rMax), cMax);&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"寻找错误节点","slug":"寻找错误节点","date":"2018-02-22T15:01:03.000Z","updated":"2018-08-24T14:23:50.260Z","comments":true,"path":"2018/02/22/寻找错误节点/","link":"","permalink":"https://lierabbit.cn/2018/02/22/寻找错误节点/","excerpt":"","text":"一棵二叉树原本是搜索二叉树，但是其中有两个节点调换了位置，使得这棵二叉树不再是搜索二叉树，请找到这两个错误节点并返回他们的值。保证二叉树中结点的值各不相同。给定一棵树的根结点，请返回两个调换了位置的值，其中小的值在前。 思路： 对二叉树进行中序遍历，依次出现的节点值会一直升序，如果两个节点值错了，会出现降序。 如果在中序遍历时节点值出现了两次降序，第一个错误的节点为第一次降序时较大的节点，第二个错误的节点为第二次降序时较小的节点。 如果在中序遍历时节点值只出现了一次降序，第一个错误的节点为这次降序时较大的节点，第二个错误的节点为这次降序时较小的节点。 12345678910111213141516171819202122232425262728293031323334public int[] findError(TreeNode root) &#123; // write code here int[] result = new int[2]; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode cur = root; TreeNode preNode = null; // 上一个打印节点 TreeNode curNode; // 当前打印节点 int count = 0; while (cur != null || !stack.empty()) &#123; if (cur == null) &#123; curNode = stack.pop(); if (preNode != null) &#123; if (preNode.val &gt; curNode.val) &#123; count++; if (count == 1) &#123; result[0] = curNode.val; result[1] = preNode.val; &#125; else &#123; result[0] = curNode.val; &#125; &#125; &#125; preNode = curNode; cur = curNode.right; &#125; else &#123; stack.add(cur); cur = cur.left; &#125; &#125; return result;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"折纸","slug":"折纸","date":"2018-02-22T14:25:00.000Z","updated":"2018-08-24T14:21:18.670Z","comments":true,"path":"2018/02/22/折纸/","link":"","permalink":"https://lierabbit.cn/2018/02/22/折纸/","excerpt":"","text":"请把纸条竖着放在桌⼦上，然后从纸条的下边向上⽅对折，压出折痕后再展 开。此时有1条折痕，突起的⽅向指向纸条的背⾯，这条折痕叫做“下”折痕 ；突起的⽅向指向纸条正⾯的折痕叫做“上”折痕。如果每次都从下边向上⽅ 对折，对折N次。请从上到下计算出所有折痕的⽅向。给定折的次数n,请返回从上到下的折痕的数组，若为下折痕则对应元素为”down”,若为上折痕则为”up”.测试样例： 121返回：[&quot;down&quot;] 思路： 1234567891011121314151617181920212223242526272829public String[] foldPaper(int n) &#123; // write code here List&lt;String&gt; temp = new ArrayList&lt;&gt;(); fold(1, n, true, temp); int resultSize = temp.size(); String[] result = new String[resultSize]; resultSize--; while (resultSize &gt;= 0) &#123; result[resultSize] = temp.get(resultSize); resultSize--; &#125; return result;&#125;/** * 模拟右中左遍历 * @param level 层数 * @param high 高度 * @param down 是否是down * @param res 结果 */public void fold(int level, int high, boolean down, List&lt;String&gt; res) &#123; if (level &gt; high) return; fold(level + 1, high, true, res); res.add(down ? \"down\" : \"up\"); fold(level + 1, high, false, res);&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"完全二叉树判断","slug":"完全二叉树判断","date":"2018-02-22T13:35:08.000Z","updated":"2018-08-24T14:14:30.570Z","comments":true,"path":"2018/02/22/完全二叉树判断/","link":"","permalink":"https://lierabbit.cn/2018/02/22/完全二叉树判断/","excerpt":"","text":"有一棵二叉树,请设计一个算法判断它是否是完全二叉树。给定二叉树的根结点root，请返回一个bool值代表它是否为完全二叉树。树的结点个数小于等于500。 思路： 采用按层遍历二叉树的方式，从每层的左边向右边依次遍历所有的节点 如果当前节点有右孩子，但没有左孩子，直接返回false 如果当前节点并不是左右孩子全有，那之后的节点必须都为叶节点，否则返回false 遍历过程中如果不返回false，遍历结束后返回true即可 12345678910111213141516171819202122232425public boolean chk(TreeNode root) &#123; // write code here Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); TreeNode node; boolean isCheckLeaf = false; // 是否检查是叶子节点 while (!queue.isEmpty()) &#123; node = queue.poll(); if (node.left == null) &#123; // 有右孩子，必须有左孩子 if (node.right != null) return false; &#125; else &#123; if (isCheckLeaf) return false; else queue.add(node.left); &#125; if (node.right == null) &#123; // 当前节点右孩子为空则以后的节点都是叶子节点 isCheckLeaf = true; &#125; else &#123; queue.add(node.right); &#125; &#125; return true;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"平衡二叉树判断","slug":"平衡二叉树判断","date":"2018-02-22T12:25:16.000Z","updated":"2018-08-24T14:14:32.485Z","comments":true,"path":"2018/02/22/平衡二叉树判断/","link":"","permalink":"https://lierabbit.cn/2018/02/22/平衡二叉树判断/","excerpt":"","text":"有一棵二叉树,请设计一个算法判断它是否是完全二叉树。给定二叉树的根结点root，请返回一个bool值代表它是否为完全二叉树。树的结点个数小于等于500。 平衡二叉树（Self-balancing binary search tree）又被称为AVL树（有别于AVL算法），且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树 思路：递归分别获取左右子树深度，然后进行高度差判断 123456789101112131415161718192021public boolean check(TreeNode root) &#123; // write code here boolean[] result = new boolean[1]; result[0] = true; getHeight(root, 1, result); return result[0];&#125;public int getHeight(TreeNode node, int level, boolean[] res) &#123; if (node == null) return level; int lh = getHeight(node.left, level + 1, res); if (!res[0]) return level; int rh = getHeight(node.right, level + 1, res); if (!res[0]) return level; if (Math.abs(lh - rh) &gt; 1) res[0] = false; return Math.max(lh, rh);&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"二叉树的序列化","slug":"二叉树的序列化","date":"2018-02-22T09:54:03.000Z","updated":"2018-08-24T14:06:54.733Z","comments":true,"path":"2018/02/22/二叉树的序列化/","link":"","permalink":"https://lierabbit.cn/2018/02/22/二叉树的序列化/","excerpt":"","text":"首先我们介绍二叉树先序序列化的方式，假设序列化的结果字符串为str，初始时str等于空字符串。先序遍历二叉树，如果遇到空节点，就在str的末尾加上“#!”，“#”表示这个节点为空，节点值不存在，当然你也可以用其他的特殊字符，“!”表示一个值的结束。如果遇到不为空的节点，假设节点值为3，就在str的末尾加上“3!”。现在请你实现树的先序序列化。给定树的根结点root，请返回二叉树序列化后的字符串。 思路：用先序遍历即可 为什么要用“#!” 1234567891011121314151617public String toString(TreeNode root) &#123; // write code here StringBuilder stringBuilder = new StringBuilder(); preOrderWalk(root, stringBuilder); return stringBuilder.toString();&#125;public void preOrderWalk(TreeNode node, StringBuilder builder) &#123; if (node == null) builder.append(\"#!\"); else &#123; builder.append(node.val).append(\"!\"); preOrderWalk(node.left, builder); preOrderWalk(node.right, builder); &#125;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"二叉树的打印","slug":"二叉树的打印","date":"2018-02-22T09:38:22.000Z","updated":"2018-08-24T14:00:01.365Z","comments":true,"path":"2018/02/22/二叉树的打印/","link":"","permalink":"https://lierabbit.cn/2018/02/22/二叉树的打印/","excerpt":"","text":"有一棵二叉树，请设计一个算法，按照层次打印这棵二叉树。给定二叉树的根结点root，请返回打印结果，结果按照每一层一个数组进行储存，所有数组的顺序按照层数从上往下，且每一层的数组内元素按照从左往右排列。保证结点数小于等于500。 思路：使用队列保存按行从左往右的节点，使用last记录当前行的最右节点，使用nLast表示下一行的最右节点，当队列弹出的节点等于last表示当前行以打印完毕，进行换行 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public int[][] printTree(TreeNode root) &#123; // write code here Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); List&lt;List&lt;Integer&gt;&gt; datas = new ArrayList&lt;&gt;(); List&lt;Integer&gt; rowData = new ArrayList&lt;&gt;(); queue.add(root); TreeNode last = root; TreeNode nLast = null; TreeNode node; TreeNode left; TreeNode right; while (!queue.isEmpty()) &#123; node = queue.poll(); left = node.left; if (left != null) &#123; queue.add(left); nLast = left; &#125; right = node.right; if (right != null) &#123; queue.add(right); nLast = right; &#125; rowData.add(node.val); if (last == node) &#123; datas.add(rowData); rowData = new ArrayList&lt;&gt;(); last = nLast; &#125; &#125; int row = datas.size(); int[][] result = new int[row][]; for (int i = 0; i &lt; row; i++) &#123; List&lt;Integer&gt; colDatas = datas.get(i); int col = colDatas.size(); int[] colResult = new int[col]; for (int j = 0; j &lt; col; j++) &#123; colResult[j] = colDatas.get(j); &#125; result[i] = colResult; &#125; return result;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"非递归二叉树的序列打印","slug":"非递归二叉树的序列打印","date":"2018-02-22T08:31:40.000Z","updated":"2018-08-24T13:55:51.966Z","comments":true,"path":"2018/02/22/非递归二叉树的序列打印/","link":"","permalink":"https://lierabbit.cn/2018/02/22/非递归二叉树的序列打印/","excerpt":"","text":"非递归方式实现先序遍历1.首先申请一个新的栈，记为stack。2.然后将头节点head压入stack中。3.每次从stack中弹出栈顶节点，记为cur,然后打印cur节点的值。如果cur右孩子不为空的话，将cur的右孩子先压入stack中。最后如果cur的左孩子不为空的话，将cur的左孩子压入stack中。4.不断重复步骤3 ,直到stack为空，全部过程结束。 非递归方法实现中序遍历1.申请一个新的栈，记为stack,申请一个变量cur,初始时令cur等于头节点。2.先把cur节点压入栈中，对以cur节点为头的整棵子树来说，依次把整棵树的左边界压入栈中，即不断令cur=cur.left,然后重复步骤2。3.不断重复步骤2,直到发现cur为空，此时从stack中弹出一个节点，记为node。打印node的值，并让cur=node.right,然后继续重复步骤2。4.当stack为空并且cur为空时，整个过程结束。 非递归方法实现后序遍历使用两个栈实现1.申请一个栈，记为Si,然后将头节点压入si中。2.从si中弹出的节点记为cur,然后先把cur的左孩子压入si中，然后把curl的右孩子压入si中。3.在整个过程中，每一个从si中弹出的节点都放进第二个栈s2中。4.不断重复步骤2和步骤3,直到si为空，过程停止。5.从s2中依次弹出节点并打印，打印的顺序就是后序遍历的顺序了。 使用一个栈实现1.申请一个栈,记为stack,将头节点压入stack，同时设置两个变量h和C。在整个流程中,h代表最近一次弹出并打印的节点,c代表当前stack的栈顶节点,初始时令h为头节点,c为null.2.每次令c等于当前stack的栈顶节点,但是不从stack中弹出节点,此时分以下三种情况。 (1)如果c的左孩子不为空,并且h不等于c的左孩子，也不等于c的右孩子,则把c的左孩子压入stack中。 (2)如果情况1不成立,并且c的右孩子不为空，并且h不等于c的右孩子,则把c的右孩子压入stack中。 (3)如果情况1和情况2都不成立,那么从stack中弹出c并打印,然后令h等于C。3.一直重复步骤2 ,直到stack为空,过程停止。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990public int[][] convert(TreeNode root) &#123; // write code here int[][] result = new int[3][]; for (int i = 0; i &lt; 3; i++) &#123; List&lt;Integer&gt; tempList = new ArrayList&lt;&gt;(); if (i == 0) preOrderWalk(root, tempList); else if (i == 1) midOrderWalk(root, tempList); else backOrderWalk2(root, tempList); int dataSize = tempList.size(); int data[] = new int[dataSize]; for (int index = 0; index &lt; dataSize; index++) data[index] = tempList.get(index); result[i] = data; &#125; return result;&#125;// 先序遍历public void preOrderWalk(TreeNode root, List result) &#123; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.add(root); while (!stack.isEmpty()) &#123; TreeNode node = stack.pop(); result.add(node.val); if (node.right != null) stack.add(node.right); if (node.left != null) stack.add(node.left); &#125;&#125;// 中序遍历public void midOrderWalk(TreeNode root, List result) &#123; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode cur = root; TreeNode node; while (cur != null || !stack.isEmpty()) &#123; if (cur == null) &#123; node = stack.pop(); result.add(node.val); cur = node.right; &#125; else &#123; stack.add(cur); cur = cur.left; &#125; &#125;&#125;// 后序遍历1public void backOrderWalk1(TreeNode root, List result) &#123; Stack&lt;TreeNode&gt; s1 = new Stack&lt;&gt;(); Stack&lt;TreeNode&gt; s2 = new Stack&lt;&gt;(); s1.add(root); TreeNode cur; while (!s1.isEmpty()) &#123; cur = s1.pop(); s2.add(cur); if (cur.left != null) s1.add(cur.left); if (cur.right != null) s1.add(cur.right); &#125; while (!s2.isEmpty()) result.add(s2.pop().val);&#125;// 后序遍历2public void backOrderWalk2(TreeNode root, List result) &#123; Stack&lt;TreeNode&gt; s1 = new Stack&lt;&gt;(); s1.add(root); TreeNode h = root; TreeNode c; while (!s1.isEmpty()) &#123; c = s1.peek(); if (c.left != null &amp;&amp; h != c.left &amp;&amp; h != c.right) s1.add(c.left); else if (c.right != null &amp;&amp; h != c.right) s1.add(c.right); else &#123; h = s1.pop(); result.add(h.val); &#125; &#125;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"递归二叉树的序列打印","slug":"递归二叉树的序列打印","date":"2018-02-22T06:51:08.000Z","updated":"2018-08-24T13:39:51.036Z","comments":true,"path":"2018/02/22/递归二叉树的序列打印/","link":"","permalink":"https://lierabbit.cn/2018/02/22/递归二叉树的序列打印/","excerpt":"","text":"请用非递归方式实现二叉树的先序、中序和后序的遍历打印。给定一个二叉树的根结点root，请依次返回二叉树的先序，中序和后续遍历(二维数组的形式)。 思路： 前序遍历：先访问根节点，再访问左子树，最后访问右子树，简称中左右 中序遍历：先访问左子树，再访问根节点，最后访问右子树，简称左中右 后序遍历：先访问左子树，再访问右子树，最后访问根节点，简称左右中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public int[][] convert(TreeNode root) &#123; // write code here int[][] result = new int[3][]; for (int i = 0; i &lt; 3; i++) &#123; List&lt;Integer&gt; tempList = new ArrayList&lt;&gt;(); if (i == 0) preOrderWalk(root, tempList); else if (i == 1) midOrderWalk(root, tempList); else backOrderWalk(root, tempList); int dataSize = tempList.size(); int data[] = new int[dataSize]; for (int index = 0; index &lt; dataSize; index++) data[index] = tempList.get(index); result[i] = data; &#125; return result;&#125;// 前序遍历public void preOrderWalk(TreeNode node, List&lt;Integer&gt; result) &#123; if (node == null) return; result.add(node.val); preOrderWalk(node.left, result); preOrderWalk(node.right, result);&#125;// 中序遍历public void midOrderWalk(TreeNode node, List&lt;Integer&gt; result) &#123; if (node == null) return; midOrderWalk(node.left, result); result.add(node.val); midOrderWalk(node.right, result);&#125;// 后序遍历public void backOrderWalk(TreeNode node, List&lt;Integer&gt; result) &#123; if (node == null) return; backOrderWalk(node.left, result); backOrderWalk(node.right, result); result.add(node.val);&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"快速N次方","slug":"快速N次方","date":"2018-02-22T05:59:39.000Z","updated":"2018-08-24T13:38:15.553Z","comments":true,"path":"2018/02/22/快速N次方/","link":"","permalink":"https://lierabbit.cn/2018/02/22/快速N次方/","excerpt":"","text":"如果更快的求一个整数k的n次方。如果两个整数相乘并得到结果的时间复杂度为O(1)，得到整数k的N次方的过程请实现时间复杂度为O(logN)的方法。给定k和n，请返回k的n次方，为了防止溢出，请返回结果Mod 1000000007的值。测试样例： 122,3返回：8 思路： 12345678910111213141516public int getPower(int a, int n) &#123; BigInteger res = BigInteger.valueOf(1); BigInteger temp = BigInteger.valueOf(a); while (n != 0) &#123; if ((n &amp; 1) == 1) &#123; res = res.multiply(temp); &#125; temp = temp.multiply(temp); res = res.mod(BigInteger.valueOf(1000000007)); temp = temp.mod(BigInteger.valueOf(1000000007)); n &gt;&gt;= 1; &#125; return res.intValue();&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"完全二叉树计数","slug":"完全二叉树计数","date":"2018-02-21T06:56:40.000Z","updated":"2018-08-24T13:21:13.573Z","comments":true,"path":"2018/02/21/完全二叉树计数/","link":"","permalink":"https://lierabbit.cn/2018/02/21/完全二叉树计数/","excerpt":"","text":"给定一棵完全二叉树的根节点root，返回这棵树的节点个数。如果完全二叉树的节点数为N，请实现时间复杂度低于O(N)的解法。给定树的根结点root，请返回树的大小。 思路：与二分查找相似，如果右子树的高度等于左子树高度则表示左子树是一棵满二叉树，可用公示计算左子树大小，然后遍历右子树重复本操作。如果不相等表示右子树是一棵满二叉树且比左子树低一层，可用公式计算右子树大小，然后遍历左子树重复本操作 12345678910111213141516171819202122232425public int count(TreeNode head) &#123; if (head == null) &#123; return 0; &#125; return bs(head, 1, mostLeftLevel(head, 1));&#125;public int bs(TreeNode node, int level, int high) &#123; if (level == high) return 1; // 如果右子树的高度等于左子树高度则表示左子树是一棵满二叉树，可用公示计算左子树大小（带头节点），然后遍历右子树重复本操作 if (mostLeftLevel(node.right, level + 1) == high) return (int) (Math.pow(2, high - level) + bs(node.right, level + 1, high)); else return (int) (Math.pow(2, high - level - 1) + bs(node.left, level + 1, high));&#125;// 获取高度public int mostLeftLevel(TreeNode node, int level) &#123; while (node != null) &#123; level++; node = node.left; &#125; return level - 1;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"最左原位","slug":"最左原位","date":"2018-02-21T06:52:57.000Z","updated":"2018-08-24T13:13:41.623Z","comments":true,"path":"2018/02/21/最左原位/","link":"","permalink":"https://lierabbit.cn/2018/02/21/最左原位/","excerpt":"","text":"有一个有序数组arr，其中不含有重复元素，请找到满足arr[i]==i条件的最左的位置。如果所有位置上的数都不满足条件，返回-1。给定有序数组arr及它的大小n，请返回所求值。测试样例： 12[-1,0,2,3],4返回：2 思路：使用二分查找 当arr[mid] &gt; mid，由于数组有序，从左往右元素每次递增&gt;=1，下标每次递增1，所以右边不会出现arr[i]==i的情况 当arr[mid] &lt; mid，由于数组有序，从右往左元素每次递减&gt;=1，下标每次递减1，所以左边不会出现arr[i]==i的情况 123456789101112131415161718192021public int findPos(int[] arr, int n) &#123; // write code here if (arr == null || arr.length == 0) return -1; int left = 0; int right = n - 1; int mid; int result = -1; while (left &lt;= right) &#123; mid = left + (right - left) / 2; if (arr[mid] == mid) &#123; // 继续搜索左边 result = mid; right = mid - 1; &#125; else if (arr[mid] &gt; mid) // 由于数组有序，从左往右元素每次递增&gt;=1，下标每次递增1，所以右边不会出现arr[i]==i的情况 right = mid - 1; else // 由于数组有序，从右往左元素每次递减&gt;=1，下标每次递减1，所以左边不会出现arr[i]==i的情况 left = mid + 1; &#125; return result;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"循环有序数组最小值","slug":"循环有序数组最小值","date":"2018-02-21T06:20:34.000Z","updated":"2018-08-24T13:06:26.352Z","comments":true,"path":"2018/02/21/循环有序数组最小值/","link":"","permalink":"https://lierabbit.cn/2018/02/21/循环有序数组最小值/","excerpt":"","text":"对于一个有序循环数组arr，返回arr中的最小值。有序循环数组是指，有序数组左边任意长度的部分放到右边去，右边的部分拿到左边来。比如数组[1,2,3,3,4]，是有序循环数组，[4,1,2,3,3]也是。给定数组arr及它的大小n，请返回最小值。测试样例： 12[4,1,2,3,3],5返回：1 思路： 使用二分查找，当局部列表有序返回头元素 当局部列表有序返回头元素 当局部列表头元素小于中间元素，这里有循环，也就是有最小值，搜索左边 当局部列表中间元素小于尾元素，这里有循环，也就是有最小值，搜索右边 当局部列表头元素等于中间元素等于尾元素，遍历寻找最小值 1234567891011121314151617181920212223242526272829303132333435public int getMin(int[] arr, int n) &#123; // write code here if (arr == null || arr.length == 0) return -1; else &#123; int left = 0; int right = arr.length - 1; int mid; while (left &lt; right) &#123; mid = left + (right - left) / 2; if (left == right - 1) // 只剩2个数时直接比较其大小 break; else if (arr[left] &lt; arr[right]) // 当局部列表有序返回头 return arr[left]; else if (arr[left] &gt; arr[mid]) // 当局部列表头元素大于中间元素，这里有循环，也就是有最小值，搜索左边 right = mid; else if (arr[mid] &gt; arr[right]) // 当局部列表中间元素大于尾元素，这里有循环，也就是有最小值，搜索右边 left = mid; else &#123; // 当局部列表头元素等于中间元素等于尾元素，遍历寻找最小值 while (left &lt; right) &#123; if (arr[left] == arr[mid]) left++; else if (arr[left] &lt; arr[mid]) return arr[left]; else &#123; right = mid; break; &#125; &#125; &#125; &#125; return Math.min(arr[left], arr[right]); &#125;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"元素最左出现","slug":"元素最左出现","date":"2018-02-21T05:20:15.000Z","updated":"2018-08-24T13:03:52.902Z","comments":true,"path":"2018/02/21/元素最左出现/","link":"","permalink":"https://lierabbit.cn/2018/02/21/元素最左出现/","excerpt":"","text":"对于一个有序数组arr，再给定一个整数num，请在arr中找到num这个数出现的最左边的位置。给定一个数组arr及它的大小n，同时给定num。请返回所求位置。若该元素在数组中未出现，请返回-1。测试样例： 12[1,2,3,3,4],5,3返回：2 思路：使用折半查找，当找到num后使用result记录当前找到的num位置，接着再对其左边进行搜索，直到搜索完毕，返回的result就是最左位置 123456789101112131415161718192021222324public int findPos(int[] arr, int n, int num) &#123; // write code here if (arr == null || n == 0) return -1; int left = 0; int right = n - 1; int mid; int result = -1; while (left &lt;= right) &#123; mid = left + (right - left) / 2; // 如果找到num，则对其左边继续搜索 if (arr[mid] == num) &#123; result = mid; right = mid - 1; &#125; else if (arr[mid] &gt; num) right = mid - 1; else left = mid + 1; &#125; return result;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"局部最小值位置","slug":"局部最小值位置","date":"2018-02-21T04:44:42.000Z","updated":"2018-08-24T10:16:21.123Z","comments":true,"path":"2018/02/21/局部最小值位置/","link":"","permalink":"https://lierabbit.cn/2018/02/21/局部最小值位置/","excerpt":"","text":"定义局部最小的概念。arr长度为1时，arr[0]是局部最小。arr的长度为N(N&gt;1)时，如果arr[0]&lt;arr[1]，那么arr[0]是局部最小；如果arr[N-1]&lt;arr[N-2]，那么arr[N-1]是局部最小；如果0&lt;i&lt;N-1，既有arr[i]&lt;arr[i-1]又有arr[i]&lt;arr[i+1]，那么arr[i]是局部最小。 给定无序数组arr，已知arr中任意两个相邻的数都不相等，写一个函数，只需返回arr中任意一个局部最小出现的位置即可。 思路：由于相邻数不相等，所以必定能分出大小，先找两头，接着使用二分查找从中间开始找起。 123456789101112131415161718192021222324public int getLessIndex(int[] arr) &#123; if (arr == null || arr.length == 0) return -1; if (arr.length == 1 || arr[0] &lt; arr[1]) return 0; if (arr[arr.length - 1] &lt; arr[arr.length - 2]) return arr.length - 1; int left = 1; int right = arr.length - 2; int mid; while (left &lt; right) &#123; mid = left + (right - left) / 2; // 如果mid大于左边的值，从中间往左边看是递减的，则局部最小值就在左边 if (arr[mid] &gt; arr[mid - 1]) right = mid - 1; // 如果mid大于右边的值，从中间往右边看是递减的，则局部最小值就在右边 else if (arr[mid] &gt; arr[mid + 1]) left = mid + 1; // 小于相邻值就是局部最小值 else return mid; &#125; return left;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"单链表相交判断","slug":"单链表相交判断","date":"2018-02-19T05:09:45.000Z","updated":"2018-08-24T10:11:34.427Z","comments":true,"path":"2018/02/19/单链表相交判断/","link":"","permalink":"https://lierabbit.cn/2018/02/19/单链表相交判断/","excerpt":"","text":"给定两个单链表的头节点head1和head2，如何判断两个链表是否相交？相交的话返回true，不想交的话返回false。给定两个链表的头结点head1和head2(注意，另外两个参数adjust0和adjust1用于调整数据,与本题求解无关)。请返回一个bool值代表它们是否相交。 思路：3种情况 两链表都是无环链表，若相交则尾节点必定一致 两链表都是有环链表，转圈寻找相交点 一个链表有环一个链表无环，必定不相交 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class TreeNode &#123; public int val = 0; public TreeNode left = null; public TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125; public boolean chkInter(ListNode head1, ListNode head2, int adjust0, int adjust1) &#123; // write code here if (head1 == null || head2 == null) return false; ListNode entryNode1 = find(head1); ListNode entryNode2 = find(head2); if (entryNode1 == null &amp;&amp; entryNode2 == null) &#123; // 两个链表都是无环链表，若相交尾节点必定一致 ListNode node1 = head1; ListNode node2 = head2; while (node1.next != null) node1 = node1.next; while (node2.next != null) node2 = node2.next; return node1 == node2; &#125; else if (entryNode1 != null &amp;&amp; entryNode2 != null) &#123; // 两个链表都是有环链表，转圈寻找相交点 if (entryNode1 == entryNode2) return true; ListNode cur = entryNode1.next; while (cur != entryNode1) &#123; if (cur == entryNode2) return true; cur = cur.next; &#125; return false; &#125; else &#123; // 一个有环一个无环，必定不相交 return false; &#125; &#125; // 寻找入环点 public ListNode find(ListNode head) &#123; ListNode fast = head; ListNode normal = head; while (fast.next != null &amp;&amp; fast.next.next != null) &#123; normal = normal.next; fast = fast.next.next; if (normal == fast) break; &#125; if (normal == fast) &#123; // 有环 fast = head; while (fast != normal) &#123; fast = fast.next; normal = normal.next; &#125; return fast; &#125; return null; &#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"有环单链表相交判断","slug":"有环单链表相交判断","date":"2018-02-19T05:06:14.000Z","updated":"2018-08-24T10:11:47.446Z","comments":true,"path":"2018/02/19/有环单链表相交判断/","link":"","permalink":"https://lierabbit.cn/2018/02/19/有环单链表相交判断/","excerpt":"","text":"如何判断两个有环单链表是否相交？相交的话返回第一个相交的节点，不想交的话返回空。如果两个链表长度分别为N和M，请做到时间复杂度O(N+M)，额外空间复杂度O(1)。给定两个链表的头结点head1和head2(注意，另外两个参数adjust0和adjust1用于调整数据,与本题求解无关)。请返回一个bool值代表它们是否相交。 思路： 在入环前相交，则入环点一致 在环里相交，则绕环转一圈寻找一致点 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class TreeNode &#123; public int val = 0; public TreeNode left = null; public TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125; public boolean chkInter(ListNode head1, ListNode head2, int adjust0, int adjust1) &#123; // write code here ListNode node1 = find(head1); ListNode node2 = find(head2); if(node1 == node2) return true; ListNode cur = node1.next; // 在环里寻找 while (node1 != cur)&#123; if(cur == node2) return true; cur = cur.next; &#125; return false; &#125; public ListNode find(ListNode head) &#123; // 找到入环点 ListNode fast = head; ListNode normal = head; while (fast.next != null &amp;&amp; fast.next.next != null) &#123; normal = normal.next; fast = fast.next.next; if (fast == normal) break; &#125; fast = head; while (fast != normal) &#123; fast = fast.next; normal = normal.next; &#125; return fast; &#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"无环单链表判相交","slug":"无环单链表判相交","date":"2018-02-19T05:02:04.000Z","updated":"2018-08-24T09:57:08.603Z","comments":true,"path":"2018/02/19/无环单链表判相交/","link":"","permalink":"https://lierabbit.cn/2018/02/19/无环单链表判相交/","excerpt":"","text":"现在有两个无环单链表，若两个链表的长度分别为m和n，请设计一个时间复杂度为O(n + m)，额外空间复杂度为O(1)的算法，判断这两个链表是否相交。给定两个链表的头结点headA和headB，请返回一个bool值，代表这两个链表是否相交。保证两个链表长度小于等于500。 思路：如果无环单链表相交则尾节点必定一致 1234567891011121314151617181920212223public class TreeNode &#123; public int val = 0; public TreeNode left = null; public TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125; public boolean chkIntersect(ListNode headA, ListNode headB) &#123; if (headA == null || headB == null) return false; ListNode nodeA = headA; ListNode nodeB = headB; while (nodeA.next != null) nodeA = nodeA.next; while (nodeB.next != null) nodeB = nodeB.next; return nodeA == nodeB; &#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"链表判环","slug":"链表判环","date":"2018-02-19T04:57:32.000Z","updated":"2018-08-24T09:53:47.025Z","comments":true,"path":"2018/02/19/链表判环/","link":"","permalink":"https://lierabbit.cn/2018/02/19/链表判环/","excerpt":"","text":"如何判断一个单链表是否有环？有环的话返回进入环的第一个节点的值，无环的话返回-1。如果链表的长度为N，请做到时间复杂度O(N)，额外空间复杂度O(1)。给定一个单链表的头结点head（注意另一个参数adjust为加密后的数据调整参数，方便数据设置，与本题求解无关)，请返回所求值。 思路：使用快慢指针，一个每次走一步，一个每次走两步，如果快慢指针相遇则有环，令快指针等于头节点，这次快指针和慢指针同步走，当他们再次相遇时就是入环点 1234567891011121314151617181920212223242526272829303132333435363738public class TreeNode &#123; public int val = 0; public TreeNode left = null; public TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125; public int chkLoop(ListNode head, int adjust) &#123; // write code here if (head == null) return -1; ListNode fast = head; ListNode normal = head; while (fast.next != null &amp;&amp; fast.next.next != null) &#123; normal = normal.next; fast = fast.next.next; if (fast == normal) break; &#125; if(fast == normal)&#123; fast = head; while (true)&#123; if(fast == normal) return fast.val; fast = fast.next; normal = normal.next; &#125; &#125; return -1; &#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"复杂链表的复制","slug":"复杂链表的复制","date":"2018-02-19T04:44:30.000Z","updated":"2018-08-24T09:51:18.438Z","comments":true,"path":"2018/02/19/复杂链表的复制/","link":"","permalink":"https://lierabbit.cn/2018/02/19/复杂链表的复制/","excerpt":"","text":"输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点） 思路：使用在原始元素后面插入克隆元素解决难以设置随机指针问题，第一次遍历在每个元素后面添加一个克隆元素，第二次遍历设置克隆元素的随机指针即原随机指针的下一个，第三次遍历分割出克隆链表 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class RandomListNode &#123; int label; RandomListNode next = null; RandomListNode random = null; RandomListNode(int label) &#123; this.label = label; &#125;&#125; public RandomListNode Clone(RandomListNode head) &#123; if (head == null) return null; RandomListNode cur = head; while (cur != null) &#123; // 在链表每个元素后面添加一个克隆元素 RandomListNode newNode = new RandomListNode(cur.label); newNode.next = cur.next; cur.next = newNode; cur = newNode.next; &#125; cur = head; RandomListNode newNode; while (cur != null) &#123; // 给每个克隆元素设置随机指针 newNode = cur.next; newNode.random = cur.random == null ? null : cur.random.next; cur = cur.next.next; &#125; cur = head; RandomListNode newHead = cur.next; RandomListNode next; while (cur != null) &#123; // 分割出克隆链表，还原原链表 next = cur.next.next; newNode = cur.next; newNode.next = next == null ? null : next.next; cur.next = next; cur = next; &#125; return newHead; &#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"链表的回文结构","slug":"链表的回文结构","date":"2018-02-19T04:36:55.000Z","updated":"2018-08-24T09:41:13.063Z","comments":true,"path":"2018/02/19/链表的回文结构/","link":"","permalink":"https://lierabbit.cn/2018/02/19/链表的回文结构/","excerpt":"","text":"请编写一个函数，检查链表是否为回文。给定一个链表ListNode* pHead，请返回一个bool，代表链表是否为回文。测试样例： 1234&#123;1,2,3,2,1&#125;返回：true&#123;1,2,3,2,3&#125;返回：false 思路：反转链表中间节点之后的节点，然后再进行对比，最后还原链表。注意：可以用快慢指针，一个每次走一步，一个每次都两步，直到快指针到尾结束，此时慢指针就是中间节点 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class TreeNode &#123; public int val = 0; public TreeNode left = null; public TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125; public boolean isPalindrome(ListNode head) &#123; // write code here if (head == null || head.next == null) return true; ListNode leftNode = head; ListNode rightNode = head; while (rightNode.next != null &amp;&amp; rightNode.next.next != null) &#123;// 找到中间节点 leftNode = leftNode.next; // 中间节点 rightNode = rightNode.next.next; &#125; ListNode node = reserve(leftNode.next); // 反转右边部分，并获得原链表最后一个节点即反转后的第一个节点 rightNode = node; leftNode = head; boolean result = true; while (rightNode != null) &#123; if (leftNode.val != rightNode.val) &#123; result = false; break; &#125; leftNode = leftNode.next; rightNode = rightNode.next; &#125; reserve(node); // 还原右边部分 return result; &#125; public ListNode reserve(ListNode head) &#123; ListNode pre = head; ListNode cur = pre.next; pre.next = null; ListNode next; while (cur != null) &#123; next = cur.next; cur.next = pre; pre = cur; cur = next; &#125; return pre; &#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"链表指定值清除","slug":"链表指定值清除","date":"2018-02-19T04:33:42.000Z","updated":"2018-08-24T09:36:20.766Z","comments":true,"path":"2018/02/19/链表指定值清除/","link":"","permalink":"https://lierabbit.cn/2018/02/19/链表指定值清除/","excerpt":"","text":"现在有一个单链表。链表中每个节点保存一个整数，再给定一个值val，把所有等于val的节点删掉。给定一个单链表的头结点head，同时给定一个值val，请返回清除后的链表的头结点，保证链表中有不等于该值的其它值。请保证其他元素的相对顺序。测试样例： 12&#123;1,2,3,4,3,2,1&#125;,2&#123;1,3,4,3,1&#125; 思路：遍历删除指定值 1234567891011121314151617181920212223242526272829public class TreeNode &#123; public int val = 0; public TreeNode left = null; public TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125; public ListNode clear(ListNode head, int num) &#123; // 删除头节点直到头节点不为num while (head != null) &#123; if (head.val != num) break; head = head.next; &#125; ListNode pre = head; ListNode cur = head; while (cur != null) &#123; if (cur.val == num) pre.next = cur.next; else pre = cur; cur = cur.next; &#125; return head; &#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"链表的K逆序","slug":"链表的K逆序","date":"2018-02-19T04:07:11.000Z","updated":"2018-08-24T09:30:00.423Z","comments":true,"path":"2018/02/19/链表的K逆序/","link":"","permalink":"https://lierabbit.cn/2018/02/19/链表的K逆序/","excerpt":"","text":"有一个单链表，请设计一个算法，使得每K个节点之间逆序，如果最后不够K个节点一组，则不调整最后几个节点。例如链表1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;8-&gt;null，K=3这个例子。调整后为，3-&gt;2-&gt;1-&gt;6-&gt;5-&gt;4-&gt;7-&gt;8-&gt;null。因为K==3，所以每三个节点之间逆序，但其中的7，8不调整，因为只有两个节点不够一组。给定一个单链表的头指针head,同时给定K值，返回逆序后的链表的头指针。 思路：使用count计数当等于k时反转刚才遍历过的局部链表注意：反转的时候注意首尾连接 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class TreeNode &#123; public int val = 0; public TreeNode left = null; public TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125; public ListNode inverse(ListNode head, int k) &#123; // write code here if (k &lt; 2) return head; ListNode cur = head; ListNode start; ListNode pre = null; ListNode next; int count = 1; while (cur != null) &#123; next = cur.next; if (count == k) &#123; start = pre == null ? head : pre.next; head = pre == null ? cur : head; reverse(pre, start, cur, next); pre = start; count = 0; &#125; count++; cur = next; &#125; return head; &#125; /** * 反转局部链表 * @param left 局部链表头节点的前一个节点 * @param start 局部链表的头节点 * @param end 局部链表的尾节点 * @param right 局部链表尾节点的后一个节点 */ public void reverse(ListNode left, ListNode start, ListNode end, ListNode right) &#123; ListNode pre = start; ListNode cur = pre.next; ListNode next; while (cur != right) &#123; next = cur.next; cur.next = pre; pre = cur; cur = next; &#125; if (left != null) left.next = end; start.next = right; &#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"打印两个链表的公共值","slug":"打印两个链表的公共值","date":"2018-02-19T04:02:20.000Z","updated":"2018-08-24T09:22:20.954Z","comments":true,"path":"2018/02/19/打印两个链表的公共值/","link":"","permalink":"https://lierabbit.cn/2018/02/19/打印两个链表的公共值/","excerpt":"","text":"现有两个升序链表，且链表中均无重复元素。请设计一个高效的算法，打印两个链表的公共值部分。给定两个链表的头指针headA和headB，请返回一个vector，元素为两个链表的公共部分。请保证返回数组的升序。两个链表的元素个数均小于等于500。保证一定有公共值测试样例： 12&#123;1,2,3,4,5,6,7&#125;,&#123;2,4,6,8,10&#125;返回：[2.4.6] 思路：遍历2个链表进行对比，若相等则同时进一步，若A&lt;B则A进一步，直到其中一个链表遍历完成 12345678910111213141516171819202122232425262728293031323334353637383940public class TreeNode &#123; public int val = 0; public TreeNode left = null; public TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125; public int[] findCommonParts(ListNode headA, ListNode headB) &#123; // write code here if (headA == null || headB == null) return null; List&lt;Integer&gt; resultList = new ArrayList&lt;&gt;(); ListNode nodeA = headA; ListNode nodeB = headB; while (nodeA != null &amp;&amp; nodeB != null) &#123; if (nodeA.val == nodeB.val) &#123; resultList.add(nodeA.val); nodeA = nodeA.next; nodeB = nodeB.next; &#125; else if (nodeA.val &lt; nodeB.val) nodeA = nodeA.next; else nodeB = nodeB.next; &#125; int resultSize = resultList.size(); int[] result = new int[resultSize]; for (int i = 0; i &lt; resultSize; i++) &#123; result[i] = resultList.get(i); &#125; return result; &#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"链表的分化","slug":"链表的分化","date":"2018-02-19T03:42:18.000Z","updated":"2018-08-24T09:13:31.273Z","comments":true,"path":"2018/02/19/链表的分化/","link":"","permalink":"https://lierabbit.cn/2018/02/19/链表的分化/","excerpt":"","text":"对于一个链表，我们需要用一个特定阈值完成对它的分化，使得小于等于这个值的结点移到前面，大于该值的结点在后面，同时保证两类结点内部的位置关系不变。给定一个链表的头结点head，同时给定阈值val，请返回一个链表，使小于等于它的结点在前，大于等于它的在后，保证结点值不重复。测试样例： 12&#123;1,4,2,5&#125;,3&#123;1,2,4,5&#125; 思路：使用2个链表，一个放小于等于阈值的节点，一个放大于阈值的节点，最后连接2个链表注意：阈(yu)值(zhi)不是阀(fa)值(zhi) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class TreeNode &#123; public int val = 0; public TreeNode left = null; public TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125; public ListNode listDivide(ListNode head, int val) &#123; // write code here if (head == null) return head; ListNode leftHead = null; ListNode leftNode = null; ListNode rightHead = null; ListNode rightNode = null; ListNode node = head; while (node != null) &#123; if (node.val &lt;= val) &#123; if (leftHead == null) &#123; leftHead = node; leftNode = leftHead; &#125; else &#123; leftNode.next = node; leftNode = node; &#125; &#125; else &#123; if (rightHead == null) &#123; rightHead = node; rightNode = rightHead; &#125; else &#123; rightNode.next = node; rightNode = node; &#125; &#125; node = node.next; &#125; // 如果没有小于等于阈值，则只有大于阀值的部分，令头节点等于右边起始节点 if (leftHead == null) head = rightHead; else &#123; // 否则就是要连接左右部分 head = leftHead; leftNode.next = rightHead; &#125; if (rightHead != null) // 如果有右部分，则把尾节点的next置空 rightNode.next = null; return head; &#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"访问单个节点的删除","slug":"访问单个节点的删除","date":"2018-02-19T03:27:02.000Z","updated":"2018-08-24T09:10:44.470Z","comments":true,"path":"2018/02/19/访问单个节点的删除/","link":"","permalink":"https://lierabbit.cn/2018/02/19/访问单个节点的删除/","excerpt":"","text":"实现一个算法，删除单向链表中间的某个结点，假定你只能访问该结点。给定带删除的头节点和要删除的数字，请执行删除操作，返回删除后的头结点。链表中没有重复数字 思路：复制后一个节点即可，不可删除最后一个节点 1234567891011121314151617181920212223public class TreeNode &#123; public int val = 0; public TreeNode left = null; public TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125; public boolean removeNode(ListNode pNode) &#123; if (pNode == null) &#123; return false; &#125; ListNode next = pNode.next; if (next == null) &#123; return false; &#125; pNode.val = next.val; pNode.next = next.next; return true; &#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"环形链表插值","slug":"环形链表插值","date":"2018-02-19T03:21:27.000Z","updated":"2018-08-24T09:01:07.494Z","comments":true,"path":"2018/02/19/环形链表插值/","link":"","permalink":"https://lierabbit.cn/2018/02/19/环形链表插值/","excerpt":"","text":"有一个整数val，如何在节点值有序的环形链表中插入一个节点值为val的节点，并且保证这个环形单链表依然有序。给定链表的信息，及元素的值A及对应的nxt指向的元素编号同时给定val，请构造出这个环形链表，并插入该值。测试样例： 12[1,3,4,5,7],[1,2,3,4,0],2返回：&#123;1,2,3,4,5,7&#125; 思路：构建环形链表，首尾相连。插值的时候注意如果插入值小于链表中所有元素则返回该节点作为头节点 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class TreeNode &#123; public int val = 0; public TreeNode left = null; public TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125; public ListNode insert(int[] A, int[] nxt, int val) &#123; // write code here ListNode head; if (A == null || A.length == 0) &#123; head = new ListNode(val); head.next = head; &#125; else &#123; head = new ListNode(A[0]); ListNode pre = head;// 前一个节点 ListNode cur;// 当前节点 for (int next : nxt) &#123; if (next == 0) cur = head; else cur = new ListNode(A[next]); pre.next = cur; pre = cur; &#125; head = insertValue(head, val); &#125; return head; &#125; public ListNode insertValue(ListNode head, int val) &#123; ListNode pre = head; ListNode cur = head.next; while (cur != head) &#123; if (pre.val &lt;= val &amp;&amp; val &lt;= cur.val) break; pre = cur; cur = cur.next; &#125; ListNode realHead;// 插入后的头节点 // 没有在中间找到插入点，则要么val大于或者小于链表里所有数 ListNode node = new ListNode(val); pre.next = node; node.next = cur; if (cur == head) &#123; if (val &lt; head.val) realHead = node; else realHead = head; &#125; else &#123; realHead = head; &#125; return realHead; &#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"数组变树","slug":"数组变树","date":"2018-02-18T15:43:34.000Z","updated":"2018-08-24T08:51:28.356Z","comments":true,"path":"2018/02/18/数组变树/","link":"","permalink":"https://lierabbit.cn/2018/02/18/数组变树/","excerpt":"","text":"对于一个没有重复元素的整数数组，请用其中元素构造一棵MaxTree，MaxTree定义为一棵二叉树，其中的节点与数组元素一一对应，同时对于MaxTree的每棵子树，它的根的元素值为子树的最大值。现有一建树方法，对于数组中的每个元素，其在树中的父亲为数组中它左边比它大的第一个数和右边比它大的第一个数中更小的一个。若两边都不存在比它大的数，那么它就是树根。请设计O(n)的算法实现这个方法。给定一个无重复元素的数组A和它的大小n，请返回一个数组，其中每个元素为原数组中对应位置元素在树中的父亲节点的编号，若为根则值为-1。测试样例： 12[3,1,4,2],4返回：[2,0,-1,2] 思路：第一次遍历数组找到左边第一个比当前数大的下标，第二次遍历数组找到右边第一个比当前数大的下标，并和左边第一个比当前数大的数比较，取较小的 1234567891011121314151617181920212223242526272829303132333435public int[] buildMaxTree(int[] arr, int n) &#123; // write code here Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); int[] res = new int[n]; // 找到左边第一个比当前数大的下标 for (int i = 0; i &lt; n; i++) &#123; while (!stack.empty() &amp;&amp; arr[stack.peek()] &lt; arr[i]) stack.pop(); if (stack.empty()) res[i] = -1; else res[i] = stack.peek(); stack.push(i); &#125; stack.clear(); // 找到右边第一个比当前数大的下标，并和左边第一个比当前数大的数比较，取较小的 for (int i = n - 1; i &gt;= 0; i--) &#123; while (!stack.empty() &amp;&amp; arr[stack.peek()] &lt; arr[i]) stack.pop(); if (!stack.empty())&#123; if(res[i] == -1) res[i] = stack.peek(); else &#123; res[i] = arr[stack.peek()] &lt; arr[res[i]] ? stack.peek() : res[i]; &#125; &#125; stack.push(i); &#125; return res;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"滑动窗口","slug":"滑动窗口","date":"2018-02-18T15:04:52.000Z","updated":"2018-08-24T08:47:41.250Z","comments":true,"path":"2018/02/18/滑动窗口/","link":"","permalink":"https://lierabbit.cn/2018/02/18/滑动窗口/","excerpt":"","text":"有一个整型数组 arr 和一个大小为 w 的窗口从数组的最左边滑到最右边,窗口每次向右边滑一个位置。 返回一个长度为n-w+1的数组res，res[i]表示每一种窗口状态下的最大值。 以数组为[4,3,5,4,3,3,6,7]，w=3为例。因为第一个窗口[4,3,5]的最大值为5，第二个窗口[3,5,4]的最大值为5，第三个窗口[5,4,3]的最大值为5。第四个窗口[4,3,3]的最大值为4。第五个窗口[3,3,6]的最大值为6。第六个窗口[3,6,7]的最大值为7。所以最终返回[5,5,5,4,6,7]。给定整形数组arr及它的大小n，同时给定w，请返回res数组。保证w小于等于n，同时保证数组大小小于等于500。测试样例： 12[4,3,5,4,3,3,6,7],8,3返回：[5,5,5,4,6,7] 思路：使用双端队列记录访问到的最大值，判断该值是否还在窗口内 123456789101112131415161718192021public int[] slide(int[] arr, int n, int w) &#123; // write code here int result[] = new int[n - w + 1]; int resultSize = 0; // 从大到小的队列 Deque&lt;Integer&gt; qMax = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; n; i++) &#123; while (!qMax.isEmpty() &amp;&amp; arr[i] &gt;= arr[qMax.peekLast()]) qMax.pollLast(); qMax.add(i); if (i &gt;= w - 1) &#123; // 判断最大值是否在窗口内 if (qMax.peekFirst() == i - w) qMax.pollFirst(); result[resultSize++] = arr[qMax.peekFirst()]; &#125; &#125; return result;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"双栈排序","slug":"双栈排序","date":"2018-02-18T13:42:41.000Z","updated":"2018-08-24T08:42:39.080Z","comments":true,"path":"2018/02/18/双栈排序/","link":"","permalink":"https://lierabbit.cn/2018/02/18/双栈排序/","excerpt":"","text":"请编写一个程序，按升序对栈进行排序（即最大元素位于栈顶），要求最多只能使用一个额外的栈存放临时数据，但不得将元素复制到别的数据结构中。给定一个int[] numbers(C++中为vector&amp;ltint&gt;)，其中第一个元素为栈顶，请返回排序后的栈。请注意这是一个栈，意味着排序过程中你只能访问到第一个元素。测试样例： 12[1,2,3,4,5]返回：[5,4,3,2,1] 思路：用一个排序栈help，大于等于help栈顶则压入，小于则help弹出栈顶，继续比较，直到找到插入的位置 123456789101112131415161718192021222324252627282930313233343536373839404142434445public ArrayList&lt;Integer&gt; twoStacksSort(int[] numbers) &#123; // write code here Stack&lt;Integer&gt; data = new Stack&lt;&gt;(); Stack&lt;Integer&gt; help = new Stack&lt;&gt;(); for (int i = numbers.length - 1; i &gt;= 0; i--) data.push(numbers[i]); while (!data.empty()) &#123; Integer value = data.pop(); if (help.empty()) help.push(value); else &#123; if (value &lt;= help.peek()) help.push(value); else &#123; int popNumber = 0; while (!help.empty()) &#123; if (value &gt; help.peek()) &#123; data.push(help.pop()); popNumber++; &#125; else break; &#125; help.push(value); while (popNumber != 0) &#123; help.push(data.pop()); popNumber--; &#125; &#125; &#125; &#125; while (!help.empty()) &#123; data.push(help.pop()); &#125; ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); while (!data.empty()) &#123; list.add(data.pop()); &#125; return list;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"栈的反转","slug":"栈的反转","date":"2018-02-18T11:32:33.000Z","updated":"2018-08-24T08:37:53.261Z","comments":true,"path":"2018/02/18/栈的反转/","link":"","permalink":"https://lierabbit.cn/2018/02/18/栈的反转/","excerpt":"","text":"实现一个栈的逆序，但是只能用递归函数和这个栈本身的pop操作来实现，而不能自己申请另外的数据结构。给定一个整数数组A即为给定的栈，同时给定它的大小n，请返回逆序后的栈。测试样例： 12[4,3,2,1],4返回：[1,2,3,4] 思路：利用递归获取栈底，弹出-&gt;弹出-&gt;弹出（栈底）-&gt;返回栈底-&gt;返回栈底-&gt;返回栈底，栈底-&gt;栈底-&gt;栈底（最后一个）-&gt;压入栈底-&gt;压入栈底-&gt;压入栈底 1234567891011121314151617181920212223242526272829303132333435363738public class StackReverse &#123; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); public int[] reverseStack(int[] A, int n) &#123; // write code here for (int i = n - 1; i &gt;= 0; i--) stack.add(A[i]); reverse(); int index = 0; while (!stack.empty()) A[index++] = stack.pop(); return A; &#125; // 反转栈 public void reverse() &#123; if (stack.empty()) return; int i = getBottom(); reverse(); stack.push(i); &#125; // 得到栈底元素 public int getBottom() &#123; int result = stack.pop(); if (stack.empty()) return result; else &#123; int last = getBottom(); stack.push(result); return last; &#125; &#125;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"双栈队列","slug":"双栈队列","date":"2018-02-18T11:24:16.000Z","updated":"2018-08-24T08:33:04.299Z","comments":true,"path":"2018/02/18/双栈队列/","link":"","permalink":"https://lierabbit.cn/2018/02/18/双栈队列/","excerpt":"","text":"编写一个类,只能用两个栈结构实现队列,支持队列的基本操作(push，pop)。给定一个操作序列ope及它的长度n，其中元素为正数代表push操作，为0代表pop操作，保证操作序列合法且一定含pop操作，请返回pop的结果序列。测试样例： 12[1,2,3,0,4,0],6返回：[1,2] 思路：一个栈用来压入，一个栈用来弹出，先压入到压入栈，然后再全部弹出压入弹出栈即可模拟队列，注意：当弹出栈不空时不能压入弹出栈必须一次性将压入栈倒出到弹出栈 123456789101112131415161718192021222324252627282930313233343536373839public class TwoStack &#123; private Stack&lt;Integer&gt; pushStack = new Stack&lt;&gt;(); private Stack&lt;Integer&gt; popStack = new Stack&lt;&gt;(); public int[] twoStack(int[] ope, int n) &#123; // write code here List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int a : ope) &#123; if (a != 0) add(a); else &#123; list.add(pop()); &#125; &#125; int[] result = new int[list.size()]; int resultLen = 0; for(int a:list) result[resultLen++] = a; return result; &#125; private void add(int value) &#123; while (!popStack.empty()) &#123; pushStack.add(popStack.pop()); &#125; pushStack.add(value); &#125; private int pop() &#123; while (!pushStack.empty()) &#123; popStack.add(pushStack.pop()); &#125; return popStack.pop(); &#125;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"可查询最值的栈","slug":"可查询最值的栈","date":"2018-02-18T11:13:06.000Z","updated":"2018-08-24T08:30:49.577Z","comments":true,"path":"2018/02/18/可查询最值的栈/","link":"","permalink":"https://lierabbit.cn/2018/02/18/可查询最值的栈/","excerpt":"","text":"定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的min函数。 思路：使用2个栈stack和minStack，stack压入所有元素，minStack只压入最小值，弹出元素的时候，stack正常弹出，minStack只有栈顶元素==stack弹出的元素才弹出 12345678910111213141516171819202122232425262728293031public class Solution &#123; private Stack&lt;Integer&gt; stack; private Stack&lt;Integer&gt; minStack; public Solution() &#123; stack = new Stack&lt;&gt;(); minStack = new Stack&lt;&gt;(); &#125; public void push(int value) &#123; stack.add(value); if (minStack.empty()) minStack.push(value); else if (minStack.peek() &gt;= value) minStack.push(value); &#125; public void pop() &#123; Integer value = stack.pop(); if (value == minStack.peek()) minStack.pop(); &#125; public int top() &#123; return stack.peek(); &#125; public int min() &#123; return minStack.peek(); &#125;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"最长无重复字符字串","slug":"最长无重复字符字串","date":"2018-02-18T10:55:23.000Z","updated":"2018-08-24T08:19:54.321Z","comments":true,"path":"2018/02/18/最长无重复字符字串/","link":"","permalink":"https://lierabbit.cn/2018/02/18/最长无重复字符字串/","excerpt":"","text":"对于一个字符串,请设计一个高效算法，找到字符串的最长无重复字符的子串长度。给定一个字符串A及它的长度n，请返回它的最长无重复字符子串长度。保证A中字符全部为小写英文字符，且长度小于等于500。测试样例： 12&quot;aabcb&quot;,5返回：3 思路：使用数组模拟HashMap记录字符上次出现的位置，用pre记录最近重复字符出现最近的位置，则i(当前位置)-pre就是当前字符最长无重复字符的长度，取最大的就是字符串的最长无重复字符的长度 1234567891011121314151617181920212223public int longestSubstring(String A, int n) &#123; if (A == null || n == 0) &#123; return 0; &#125; int[] map = new int[256]; for (int i = 0; i &lt; 256; i++) map[i] = -1; char[] chars = A.toCharArray(); int len = 0; int pre = -1;//之前出现的地方 int cur;//当前最长无重复字符子串长度 for (int i = 0; i &lt; chars.length; i++) &#123; pre = Math.max(pre, map[chars[i]]); cur = i - pre; len = Math.max(len, cur); map[chars[i]] = i; &#125; return len;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"合法括号序列判断","slug":"合法括号序列判断","date":"2018-02-18T10:37:20.000Z","updated":"2018-08-24T08:17:16.089Z","comments":true,"path":"2018/02/18/合法括号序列判断/","link":"","permalink":"https://lierabbit.cn/2018/02/18/合法括号序列判断/","excerpt":"","text":"对于一个字符串，请设计一个算法，判断其是否为一个合法的括号串。给定一个字符串A和它的长度n，请返回一个bool值代表它是否为一个合法的括号串。测试样例： 12345678910&quot;(()())&quot;,6返回：true测试样例：&quot;()a()()&quot;,7返回：false测试样例：&quot;()(()()&quot;,7返回：false 思路：用num记录括号出现次数，出现’(‘则+1，出现’)’则-1，若num&lt;0说明’)’出现过多，若遍历完整个数组num不为0说明’(‘过多 12345678910111213141516public boolean chkParenthesis(String A, int n) &#123; // write code here int num = 0; char[] chars = A.toCharArray(); for (char ch : chars) &#123; if (ch == '(') num++; if (ch == ')') num--; if (num &lt; 0) return false; &#125; return num == 0;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"空格替换","slug":"空格替换","date":"2018-02-18T10:28:12.000Z","updated":"2018-08-24T08:14:45.950Z","comments":true,"path":"2018/02/18/空格替换/","link":"","permalink":"https://lierabbit.cn/2018/02/18/空格替换/","excerpt":"","text":"请编写一个方法，将字符串中的空格全部替换为“%20”。假定该字符串有足够的空间存放新增的字符，并且知道字符串的真实长度(小于等于1000)，同时保证字符串由大小写的英文字母组成。给定一个string iniString 为原始的串，以及串的长度 int len, 返回替换后的string。测试样例： 1234&quot;Mr John Smith”,13返回：&quot;Mr%20John%20Smith&quot;”Hello World”,12返回：”Hello%20%20World” 使用replaceAlliniString.replaceAll(“ “,”%20”) 手动实现思路：记录空格出现次数，新数组长度等于原数组长度+空格数*2，遍历原数组按规则放入新数组即可 123456789101112131415161718192021222324public String replaceSpace(String iniString, int length) &#123; // write code here if (iniString == null || iniString.length() == 0) return iniString; char[] chars = iniString.toCharArray(); int space = 0; for (char ch : chars) if (ch == ' ') space++; int resultLen = length + space * 2; char[] result = new char[resultLen]; for (int i = length - 1; i &gt;= 0; i--) &#123; if (chars[i] == ' ') &#123; result[--resultLen] = '0'; result[--resultLen] = '2'; result[--resultLen] = '%'; &#125; else result[--resultLen] = chars[i]; &#125; return String.valueOf(result);&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"拼接最小字典序","slug":"拼接最小字典序","date":"2018-02-18T10:15:44.000Z","updated":"2018-08-24T08:11:27.769Z","comments":true,"path":"2018/02/18/拼接最小字典序/","link":"","permalink":"https://lierabbit.cn/2018/02/18/拼接最小字典序/","excerpt":"","text":"对于一个给定的字符串数组，请找到一种拼接顺序，使所有小字符串拼接成的大字符串是所有可能的拼接中字典序最小的。给定一个字符串数组strs，同时给定它的大小，请返回拼接成的串。测试样例： 12[&quot;abc&quot;,&quot;de&quot;],2&quot;abcde&quot; 思路：将字符串数组排序，然后按序拼接。有字符串a和b，若a+b&lt;b+a，则a在前b在后。 123456789101112131415public String findSmallest(String[] strs, int n) &#123; // write code here if (strs == null) return null; if (strs.length == 1) return strs[0]; Arrays.sort(strs, (a, b) -&gt; (a + b).compareTo(b + a)); StringBuilder result = new StringBuilder(); for (String str : strs) result.append(str); return result.toString();&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"字符串位移","slug":"字符串位移","date":"2018-02-18T10:12:02.000Z","updated":"2018-08-24T08:00:41.927Z","comments":true,"path":"2018/02/18/字符串位移/","link":"","permalink":"https://lierabbit.cn/2018/02/18/字符串位移/","excerpt":"","text":"对于一个字符串，请设计一个算法，将字符串的长度为len的前缀平移到字符串的最后。给定一个字符串A和它的长度，同时给定len，请返回平移后的字符串。测试样例： 12&quot;ABCDE&quot;,5,3返回：&quot;DEABC&quot; 思路：首先将长度为len的字符逆序，再把len之后的字符逆序，最后把整个字符串逆序即可 123456789101112131415161718192021222324public String stringTranslation(String A, int n, int len) &#123; // write code here char[] chars = A.toCharArray(); reverse(chars, 0, len - 1); reverse(chars, len, n - 1); reverse(chars, 0, n - 1); return String.valueOf(chars);&#125;public void reverse(char[] chars, int start, int end) &#123; while (start &lt; end) &#123; swap(chars, start, end); start++; end--; &#125;&#125;public void swap(char[] chars, int i, int j) &#123; char temp = chars[i]; chars[i] = chars[j]; chars[j] = temp;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"句子的逆序","slug":"句子的逆序","date":"2018-02-18T10:04:17.000Z","updated":"2018-08-24T07:56:00.011Z","comments":true,"path":"2018/02/18/句子的逆序/","link":"","permalink":"https://lierabbit.cn/2018/02/18/句子的逆序/","excerpt":"","text":"对于一个字符串，请设计一个算法，只在字符串的单词间做逆序调整，也就是说，字符串由一些由空格分隔的部分组成，你需要将这些部分逆序。给定一个原字符串A和他的长度，请返回逆序后的字符串。测试样例： 12&quot;dog loves pig&quot;,13返回：&quot;pig loves dog&quot; 思路：首先反转整个字符串，接着一个一个的反转局部单词即可 12345678910111213141516171819202122232425262728293031323334353637383940public String reverseSentence(String A, int n) &#123; // write code here char[] chars = A.toCharArray(); // 反转整个字符串 reverse(chars, 0, chars.length - 1); int l = -1; int r = -1; for (int i = 0; i &lt; chars.length; i++) &#123; if (chars[i] != ' ') &#123; if (i == 0 || chars[i - 1] == ' ') // 寻找需要局部反转的单词的起始下标 l = i; if (i == chars.length - 1 || chars[i + 1] == ' ') // 寻找需要局部反转的单词的末尾下标 r = i; &#125; if (l != -1 &amp;&amp; r != -1) &#123; reverse(chars, l, r); l = -1; r = -1; &#125; &#125; return String.valueOf(chars);&#125;// 反转字符串public void reverse(char[] chars, int start, int end) &#123; while (start &lt; end) &#123; swap(chars, start, end); start++; end--; &#125;&#125;// 交换public void swap(char[] chars, int i, int j) &#123; char temp = chars[i]; chars[i] = chars[j]; chars[j] = temp;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"两串旋转","slug":"两串旋转","date":"2018-02-18T09:53:37.000Z","updated":"2018-08-24T07:54:19.640Z","comments":true,"path":"2018/02/18/两串旋转/","link":"","permalink":"https://lierabbit.cn/2018/02/18/两串旋转/","excerpt":"","text":"如果对于一个字符串A，将A的前面任意一部分挪到后边去形成的字符串称为A的旋转词。比如A=”12345”,A的旋转词有”12345”,”23451”,”34512”,”45123”和”51234”。对于两个字符串A和B，请判断A和B是否互为旋转词。给定两个字符串A和B及他们的长度lena，lenb，请返回一个bool值，代表他们是否互为旋转词。测试样例：12&quot;cdab&quot;,4,&quot;abcd&quot;,4返回：true 思路：如果A，B互为旋转词，则A+A必定包含B例如A=”abcd”，B=”cdab”，则A+A=”abcdabcd”，里面有”abcd”，”bcda”，”cdab”，”dabc”枚举了所有的旋转词 12345678public boolean chkRotation(String A, int lena, String B, int lenb) &#123; // write code here if (lena == lenb) &#123; String C = A + A; return C.contains(B); &#125; else return false;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"词语变形","slug":"词语变形","date":"2018-02-18T09:48:13.000Z","updated":"2018-08-24T07:46:11.079Z","comments":true,"path":"2018/02/18/词语变形/","link":"","permalink":"https://lierabbit.cn/2018/02/18/词语变形/","excerpt":"","text":"对于两个字符串A和B，如果A和B中出现的字符种类相同且每种字符出现的次数相同，则A和B互为变形词，请设计一个高效算法，检查两给定串是否互为变形词。给定两个字符串A和B及他们的长度，请返回一个bool值，代表他们是否互为变形词。测试样例： 12&quot;abc&quot;,3,&quot;bca&quot;,3返回：true 思路：使用数组模拟hashMap计数，只要字符出现次数一致就互为变形词 12345678910111213141516171819public boolean chkTransform(String str1, int lena, String str2, int lenb) &#123; // write code here if (str1 == null || str2 == null || lena != lenb) return false; char[] chars1 = str1.toCharArray(); char[] chars2 = str2.toCharArray(); int[] map = new int[256]; for (char char1 : chars1) map[char1]++; for (char char2 : chars2) &#123; if (map[char2]-- == 0) return false; &#125; return true;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"拓扑结构相同子树","slug":"拓扑结构相同子树","date":"2018-02-18T09:33:25.000Z","updated":"2018-08-24T07:41:54.834Z","comments":true,"path":"2018/02/18/拓扑结构相同子树/","link":"","permalink":"https://lierabbit.cn/2018/02/18/拓扑结构相同子树/","excerpt":"","text":"对于两棵彼此独立的二叉树A和B，请编写一个高效算法，检查A中是否存在一棵子树与B树的拓扑结构完全相同。给定两棵二叉树的头结点A和B，请返回一个bool值，代表A中是否存在一棵同构于B的子树。 思路：将树序列化成字符串。如果A树中存在一棵子树与B树的拓扑结构完全相同则A序列化后的字符串必定包含B序列化后的字符串。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class TreeNode &#123; public int val = 0; public TreeNode left = null; public TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125; public boolean chkIdentical(TreeNode A, TreeNode B) &#123; // write code here String AS = treeToStringWithStack(A); String BS = treeToStringWithStack(B); return AS.contains(BS); &#125; // 先序遍历 public String treeToStringWithStack(TreeNode root) &#123; StringBuilder result = new StringBuilder(); Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.add(root); TreeNode node; while (!stack.empty()) &#123; node = stack.pop(); if (node == null) result.append(\"#!\"); else &#123; result.append(node.val).append(\"!\"); stack.add(node.right); stack.add(node.left); &#125; &#125; return result.toString(); &#125; // 递归先序遍历 public String serialByPre(TreeNode head) &#123; if (head == null) &#123; return \"#!\"; &#125; String res = head.val + \"!\"; res += serialByPre(head.left); res += serialByPre(head.right); return res; &#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"相邻两数最大差值","slug":"相邻两数最大差值","date":"2018-02-18T08:24:09.000Z","updated":"2018-08-24T07:40:49.628Z","comments":true,"path":"2018/02/18/相邻两数最大差值/","link":"","permalink":"https://lierabbit.cn/2018/02/18/相邻两数最大差值/","excerpt":"","text":"有一个整形数组A，请设计一个复杂度为O(n)的算法，算出排序后相邻两数的最大差值。给定一个int数组A和A的大小n，请返回最大的差值。保证数组元素多于1个。测试样例： 12[1,2,5,4,6],5返回：2 思路：使用2个n+1大小的桶按区间来放置最大和最小数，第n+1个桶单独放置最大值，取每个桶之间的最大差值即可 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public int maxGap(int[] nums, int n) &#123; // write code here if (nums == null || nums.length &lt; 2) return 0; int len = nums.length; int min = Integer.MAX_VALUE; int max = Integer.MIN_VALUE; // 获取数组中最大最小值用来划分桶区间 for (int num : nums) &#123; min = Math.min(min, num); max = Math.max(max, num); &#125; if (max == min) return 0; boolean[] hasNums = new boolean[len + 1]; int[] maxs = new int[len + 1]; int[] mins = new int[len + 1]; int bid; // 将数放入桶中 for (int num : nums) &#123; bid = bucket(num, len, min, max); mins[bid] = hasNums[bid] ? Math.min(mins[bid], num) : num; maxs[bid] = hasNums[bid] ? Math.max(maxs[bid], num) : num; hasNums[bid] = true; &#125; int lastMax = 0; int index = 0; // 寻找第一个不为空的桶 while (index &lt;= len) &#123; if (hasNums[index]) &#123; lastMax = maxs[index]; break; &#125; index++; &#125; int result = 0; while (index &lt;= len) &#123; if (hasNums[index]) &#123; // 当桶的最小值减去上一个不为空的桶最大值即为2个桶的最大差值 result = Math.max(result, mins[index] - lastMax); lastMax = maxs[index]; &#125; index++; &#125; return result;&#125;// 使用long类型是为了防止相乘时溢出// 根据区间获取桶号public int bucket(long num, long len, long min, long max) &#123; return (int) ((num - min) * len / (max - min));&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"最短子数组","slug":"最短子数组","date":"2018-02-18T08:05:18.000Z","updated":"2018-08-24T07:35:29.447Z","comments":true,"path":"2018/02/18/最短子数组/","link":"","permalink":"https://lierabbit.cn/2018/02/18/最短子数组/","excerpt":"","text":"对于一个数组，请设计一个高效算法计算需要排序的最短子数组的长度。给定一个int数组A和数组的大小n，请返回一个二元组，代表所求序列的长度。(原序列位置从0开始标号,若原序列有序，返回0)。保证A中元素均为正整数。测试样例： 12[1,4,6,5,9,10],6返回：2 思路：从左往右记录最大值，并记录最大值大于当前遍历数的位置，因为排序后最大值至少在当前位置或者更右的位置。从右往左记录最小值，并记录最小值小于当前遍历数的位置，因为排序后最小值至少在当前位置或者更左的位置。 12345678910111213141516171819202122232425public int shortestSubsequence(int[] A, int n) &#123; int maxIndex = 0; int max = A[maxIndex]; int minIndex = n - 1; int min = A[n - 1]; for (int i = maxIndex + 1; i &lt; n; i++) &#123; if (max &lt;= A[i]) max = A[i]; else maxIndex = i; &#125; for (int i = minIndex - 1; i &gt;= 0; i--) &#123; if (min &gt;= A[i]) min = A[i]; else minIndex = i; &#125; if (maxIndex == 0 &amp;&amp; minIndex == n - 1) return 0; else return maxIndex - minIndex + 1;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"有序矩阵查找","slug":"有序矩阵查找","date":"2018-02-18T07:57:22.000Z","updated":"2018-08-24T07:26:53.382Z","comments":true,"path":"2018/02/18/有序矩阵查找/","link":"","permalink":"https://lierabbit.cn/2018/02/18/有序矩阵查找/","excerpt":"","text":"现在有一个行和列都排好序的矩阵，请设计一个高效算法，快速查找矩阵中是否含有值x。给定一个int矩阵mat，同时给定矩阵大小nxm及待查找的数x，请返回一个bool值，代表矩阵中是否存在x。所有矩阵中数字及x均为int范围内整数。保证n和m均小于等于1000。测试样例： 12[[1,2,3],[4,5,6],[7,8,9]],3,3,10返回：false 思路：从右上角开始找 1234567891011121314151617181920public boolean findX(int[][] mat, int n, int m, int x) &#123; // write code here int row = 0; int col = m - 1; while (row &lt; n &amp;&amp; col &gt;= 0) &#123; if (mat[row][col] == x) return true; // 比它大往左走 else if (x &lt;= mat[row][col]) &#123; col--; &#125; // 比它小往下走 else if (x &gt;= mat[row][col]) &#123; row++; &#125; &#125; return false; &#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"三色排序","slug":"三色排序","date":"2018-02-17T11:38:54.000Z","updated":"2018-08-24T07:15:50.052Z","comments":true,"path":"2018/02/17/三色排序/","link":"","permalink":"https://lierabbit.cn/2018/02/17/三色排序/","excerpt":"","text":"有一个只由0，1，2三种元素构成的整数数组，请使用交换、原地排序而不是使用计数进行排序。给定一个只含0，1，2的整数数组A及它的大小，请返回排序后的数组。保证数组大小小于等于500。测试样例：12[0,1,1,0,2,2],6返回：[0,0,1,1,2,2] 思路：类似于快排，小的放左边，大的放右边 123456789101112131415161718192021public int[] sortThreeColor(int[] arr, int n) &#123; // write code here int left = -1; int right = n; int index = 0; while (index &lt; right) &#123; if (arr[index] == 0) swap(arr, ++left, index++); // 由于前面的数已经遍历过，所以交换后可以后移即(index++) else if (arr[index] == 2) swap(arr, --right, index); // 右边的数没有遍历过，所以交换后index不增 else index++; &#125; return arr;&#125;public void swap(int[] arr, int i, int j) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"有序数组合并","slug":"有序数组合并","date":"2018-02-17T10:48:59.000Z","updated":"2018-08-24T07:13:44.641Z","comments":true,"path":"2018/02/17/有序数组合并/","link":"","permalink":"https://lierabbit.cn/2018/02/17/有序数组合并/","excerpt":"","text":"有两个从小到大排序以后的数组A和B，其中A的末端有足够的缓冲空容纳B。请编写一个方法，将B合并入A并排序。给定两个有序int数组A和B，A中的缓冲空用0填充，同时给定A和B的真实大小int n和int m，请返回合并后的数组。 思路：从后往前按序填充 12345678910111213public int[] mergeAB(int[] A, int[] B, int n, int m) &#123; // write code here while (m != 0) &#123; if (n == 0) &#123; A[m - 1] = B[m - 1]; m--; &#125; else &#123; A[m + n - 1] = A[n - 1] &gt; B[m - 1] ? A[--n] : B[--m]; &#125; &#125; return A;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"重复值判断","slug":"重复值判断","date":"2018-02-17T08:21:12.000Z","updated":"2018-08-24T07:06:17.346Z","comments":true,"path":"2018/02/17/重复值判断/","link":"","permalink":"https://lierabbit.cn/2018/02/17/重复值判断/","excerpt":"","text":"请设计一个高效算法，判断数组中是否有重复值。必须保证额外空间复杂度为O(1)。给定一个int数组A及它的大小n，请返回它是否有重复值。测试样例： 12[1,2,3,4,5,5,6],7返回：true 思路：使用堆排序后判断下一个元素是否与当前元素相等 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public boolean checkDuplicate(int[] arr, int n) &#123; // write code here makeHeap(arr); for (int i = arr.length - 1; i &gt; 0; i--) &#123; swap(arr, 0, i); adjustHeap(arr, 0, i); &#125; for (int i = 0; i &lt; arr.length - 1; i++) &#123; if (arr[i] == arr[i + 1]) return true; &#125; return false;&#125;public void makeHeap(int[] arr) &#123; for (int i = arr.length / 2 - 1; i &gt;= 0; i--) &#123; adjustHeap(arr, i, arr.length); &#125;&#125;public void adjustHeap(int[] arr, int index, int size) &#123; int max = arr[index]; for (int k = index * 2 + 1; k &lt; size; k = k * 2 + 1) &#123; if (k + 1 &lt; size &amp;&amp; arr[k] &lt; arr[k + 1]) &#123; k++; &#125; if (max &lt; arr[k]) &#123; arr[index] = arr[k]; index = k; &#125; else break; &#125; arr[index] = max;&#125;public void swap(int[] arr, int i, int j) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"小范围排序","slug":"小范围排序","date":"2018-02-13T16:44:14.000Z","updated":"2018-08-24T02:18:13.523Z","comments":true,"path":"2018/02/14/小范围排序/","link":"","permalink":"https://lierabbit.cn/2018/02/14/小范围排序/","excerpt":"","text":"已知一个几乎有序的数组，几乎有序是指，如果把数组排好顺序的话，每个元素移动的距离可以不超过k，并且k相对于数组来说比较小。请选择一个合适的排序算法针对这个数据进行排序。给定一个int数组A，同时给定A的大小n和题意中的k，请返回排序后的数组。 测试样例：12[2,1,4,3,6,5,8,7,10,9],10,2返回：[1,2,3,4,5,6,7,8,9,10] 思路：特殊版的堆排序，建立大小为K的小根堆，按照堆排序排序 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public int[] sortElement(int[] A, int n, int k) &#123; // write code here if (A == null || n &lt; 2 || n &lt; k) return A; // 获取大小为k的小根堆 int[] heap = getHeap(A, k); for (int i = k; i &lt; n; i++) &#123; A[i - k] = heap[0]; heap[0] = A[i]; adjustHeap(heap, 0, k); &#125; // 把剩余堆的值一个一个弹出 int temp; for (int i = n - k; i &lt; n; i++) &#123; A[i] = heap[0]; temp = heap[0]; heap[0] = heap[k - 1]; heap[k - 1] = temp; adjustHeap(heap, 0, --k); &#125; return A;&#125;public int[] getHeap(int[] arr, int size) &#123; int[] heap = new int[size]; for (int i = 0; i &lt; size; i++) &#123; heap[i] = arr[i]; &#125; adjustHeap(heap, 0, size); for (int i = size / 2 - 1; i &gt;= 0; i--) &#123; adjustHeap(heap, i, size); &#125; return heap;&#125;// 调整堆public void adjustHeap(int[] arr, int i, int length) &#123; int min = arr[i]; for (int k = i * 2 + 1; k &lt; length; k = k * 2 + 1) &#123; if (k + 1 &lt; length &amp;&amp; arr[k] &gt; arr[k + 1]) &#123; k++; &#125; if (min &gt; arr[k]) &#123; arr[i] = arr[k]; i = k; &#125; else &#123; break; &#125; &#125; arr[i] = min;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"基数排序","slug":"基数排序","date":"2018-02-13T16:26:46.000Z","updated":"2018-08-23T14:51:30.700Z","comments":true,"path":"2018/02/14/基数排序/","link":"","permalink":"https://lierabbit.cn/2018/02/14/基数排序/","excerpt":"","text":"对于一个int数组，请编写一个基数排序算法，对数组元素排序。给定一个int数组A及数组的大小n，请返回排序后的数组。保证元素均小于等于2000。测试样例： 12[1,2,3,5,2,3],6[1,2,2,3,3,5] 时间复杂度：O(n)空间复杂度：O(m) // m：桶的数量 思路：放置顺序的0-9号桶，将所有元素先按个位放入，按桶序倒出，再按十位放入，按桶序倒出，依次重复下去 12345678910111213141516171819202122232425262728293031323334353637public int[] radixSort(int[] A, int n) &#123; int max = A[0]; for (int a : A) &#123; max = Math.max(max, a); &#125; List&lt;List&lt;Integer&gt;&gt; boxs = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 10; i++) &#123; boxs.add(new ArrayList&lt;&gt;()); &#125; int k = 1; int index; while (max &gt; 0) &#123; for (int a : A) &#123; boxs.get(a / k % 10).add(a); &#125; index = 0; for (int i = 0; i &lt; 10; i++) &#123; List&lt;Integer&gt; box = boxs.get(i); for (int j = 0; j &lt; box.size(); j++) &#123; A[index++] = box.get(j); &#125; box.clear(); &#125; k *= 10; max /= 10; &#125; return A;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"计数排序","slug":"计数排序","date":"2018-02-13T16:22:10.000Z","updated":"2018-08-23T14:49:33.015Z","comments":true,"path":"2018/02/14/计数排序/","link":"","permalink":"https://lierabbit.cn/2018/02/14/计数排序/","excerpt":"","text":"对于一个int数组，请编写一个计数排序算法，对数组元素排序。给定一个int数组A及数组的大小n，请返回排序后的数组。测试样例： 12[1,2,3,5,2,3],6[1,2,2,3,3,5] 时间复杂度：O(n)空间复杂度：O(m) // m：桶的数量 思路：预先设置一些排好序的桶（数组），然后遍历数组将元素放入对应桶，再倒出桶里的值 12345678910111213141516171819202122232425public int[] countingSort(int[] A, int n) &#123; int min = A[0]; int max = A[0]; for (int a : A) &#123; min = Math.min(min, a); max = Math.max(max, a); &#125; int[] arr = new int[max - min + 1]; for (int a : A) &#123; arr[a - min]++; &#125; int index = 0; for (int i = 0; i &lt; arr.length; i++) &#123; while (arr[i]-- &gt; 0) &#123; A[index++] = i + min; &#125; &#125; return A;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"希尔排序","slug":"希尔排序","date":"2018-02-13T16:18:50.000Z","updated":"2018-08-23T14:49:18.623Z","comments":true,"path":"2018/02/14/希尔排序/","link":"","permalink":"https://lierabbit.cn/2018/02/14/希尔排序/","excerpt":"","text":"对于一个int数组，请编写一个希尔排序算法，对数组元素排序。给定一个int数组A及数组的大小n，请返回排序后的数组。保证元素小于等于2000。测试样例：12[1,2,3,5,2,3],6[1,2,2,3,3,5] 时间复杂度：O(nlogn)空间复杂度：O(1) 思路：动态步长的插入排序，最终步长为1 12345678910111213141516171819202122public int[] shellSort(int[] A, int n) &#123; int feet = A.length / 2; int temp; int index; while (feet &gt; 0) &#123; for (int i = feet; i &lt; A.length; i++) &#123; index = i; while (index &gt;= feet) &#123; if (A[index - feet] &gt; A[index]) &#123; temp = A[index]; A[index] = A[index - feet]; A[index - feet] = temp; index -= feet; &#125; else &#123; break; &#125; &#125; &#125; feet /= 2; &#125; return A;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"堆排序","slug":"堆排序","date":"2018-02-13T16:11:02.000Z","updated":"2018-08-23T14:44:42.579Z","comments":true,"path":"2018/02/14/堆排序/","link":"","permalink":"https://lierabbit.cn/2018/02/14/堆排序/","excerpt":"","text":"对于一个int数组，请编写一个堆排序算法，对数组元素排序。给定一个int数组A及数组的大小n，请返回排序后的数组。测试样例：12[1,2,3,5,2,3],6[1,2,2,3,3,5] 时间复杂度：O(nlogn)空间复杂度：O(1) 思路：首先建立一个大根堆。重复进行交换头尾，调整堆使其符合大根堆 123456789101112131415161718192021222324252627282930313233public int[] heapSort(int[] A, int n) &#123; //建堆 for (int i = A.length / 2 - 1; i &gt;= 0; i--) &#123; adjustHeap(A, i, A.length); &#125; int temp; //调整堆 for (int i = A.length - 1; i &gt; 0; i--) &#123; temp = A[0]; A[0] = A[i]; A[i] = temp; adjustHeap(A, 0, i); &#125; return A;&#125;public void adjustHeap(int[] arr, int i, int length) &#123; int max = arr[i]; for (int k = i * 2 + 1; k &lt; length; k = k * 2 + 1) &#123; if (k + 1 &lt; length &amp;&amp; arr[k] &lt; arr[k + 1]) &#123; k++; &#125; if (arr[k] &gt; max) &#123; arr[i] = arr[k]; i = k; &#125; else &#123; break; &#125; &#125; arr[i] = max;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"快速排序","slug":"快速排序","date":"2018-02-13T16:06:46.000Z","updated":"2018-08-23T14:41:53.705Z","comments":true,"path":"2018/02/14/快速排序/","link":"","permalink":"https://lierabbit.cn/2018/02/14/快速排序/","excerpt":"","text":"对于一个int数组，请编写一个快速排序算法，对数组元素排序。给定一个int数组A及数组的大小n，请返回排序后的数组。测试样例：12[1,2,3,5,2,3],6[1,2,2,3,3,5] 时间复杂度：O(nlogn)空间复杂度：O(logn) ~ O(n) 思路：随机获取数组内一个值，将其作为中间值，小于它的放左边，大于它的放右边。然后再对它的左边部分、右边部分分别也进行同样的操作 12345678910111213141516171819202122232425262728293031public int[] quickSort(int[] A, int n) &#123; // write code here if (A == null || A.length &lt; 2) return null; quickSort(A, 0, n - 1); return A;&#125;public void quickSort(int[] arr, int left, int right) &#123; if (left &lt; right) &#123; int mid = partition(arr, left, right); quickSort(arr, left, mid - 1); quickSort(arr, mid + 1, right); &#125;&#125;public int partition(int[] arr, int left, int right) &#123; int random = left + (int) (Math.random() * (right - left + 1)); swap(arr, random, right); int leftIndex = left - 1; int index = left; while (index &lt;= right) &#123; if (arr[index] &lt;= arr[right]) &#123; swap(arr, ++leftIndex, index); &#125; index++; &#125; return leftIndex;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"归并排序","slug":"归并排序","date":"2018-02-13T16:03:06.000Z","updated":"2018-08-23T14:39:28.169Z","comments":true,"path":"2018/02/14/归并排序/","link":"","permalink":"https://lierabbit.cn/2018/02/14/归并排序/","excerpt":"","text":"对于一个int数组，请编写一个归并排序算法，对数组元素排序。给定一个int数组A及数组的大小n，请返回排序后的数组。测试样例： 12[1,2,3,5,2,3],6[1,2,2,3,3,5] 时间复杂度：O(nlogn)空间复杂度：O(n) 思路：将数组分割成一个个独立单元，然后按序合并 1234567891011121314151617181920212223242526272829303132333435363738394041public int[] mergeSort(int[] A, int n) &#123; // write code here if (A == null || A.length &lt; 2) return null; mergeSort(A, 0, n - 1); return A;&#125;public void mergeSort(int[] array, int left, int right) &#123; if (left == right) return; int mid = (left + right) / 2; mergeSort(array, left, mid); mergeSort(array, mid + 1, right); merge(array, left, mid, right);&#125;public void merge(int[] array, int left, int mid, int right) &#123; int[] help = new int[right - left + 1]; int l = left; int r = mid + 1; int index = 0; while (l &lt;= mid &amp;&amp; r &lt;= right) &#123; if (array[l] &lt;= array[r]) help[index++] = array[l++]; else help[index++] = array[r++]; &#125; while (l &lt;= mid) &#123; help[index++] = array[l++]; &#125; while (r &lt;= right) &#123; help[index++] = array[r++]; &#125; for (int i = 0; i &lt; help.length; i++) &#123; array[left + i] = help[i]; &#125;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"插入排序","slug":"插入排序","date":"2018-02-13T15:56:24.000Z","updated":"2018-08-23T14:29:41.734Z","comments":true,"path":"2018/02/13/插入排序/","link":"","permalink":"https://lierabbit.cn/2018/02/13/插入排序/","excerpt":"","text":"对于一个int数组，请编写一个插入排序算法，对数组元素排序。给定一个int数组A及数组的大小n，请返回排序后的数组。测试样例： 12[1,2,3,5,2,3],6[1,2,2,3,3,5] 时间复杂度：O(n2)空间复杂度：O(1) 思路：在数组头构建一个已排好序的小数组，依次插入 123456789101112131415public int[] insertionSort(int[] A, int n) &#123; // write code here for (int i = 1; i &lt; n; i++) &#123; for (int j = i; j &gt; 0; j--) &#123; if (A[j] &lt; A[j - 1]) &#123; int temp = A[j]; A[j] = A[j - 1]; A[j - 1] = temp; &#125; else break; &#125; &#125; return A;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"选择排序","slug":"选择排序","date":"2018-02-13T14:56:46.000Z","updated":"2018-08-23T14:27:19.222Z","comments":true,"path":"2018/02/13/选择排序/","link":"","permalink":"https://lierabbit.cn/2018/02/13/选择排序/","excerpt":"","text":"对于一个int数组，请编写一个选择排序算法，对数组元素排序。给定一个int数组A及数组的大小n，请返回排序后的数组。测试样例：12[1,2,3,5,2,3],6[1,2,2,3,3,5] 时间复杂度：O(n2)空间复杂度：O(1) 思路：每次找出一个最大值，将其放到末尾123456789101112131415161718192021public int[] selectionSort(int[] A, int n) &#123; // write code here int maxIndex; int temp; for (int i = n - 1; i &gt; 0; i--) &#123; maxIndex = i; for (int j = 0; j &lt; i; j++) &#123; if (A[maxIndex] &lt; A[j]) &#123; maxIndex = j; &#125; &#125; if (maxIndex != i) &#123; temp = A[i]; A[i] = A[maxIndex]; A[maxIndex] = temp; &#125; &#125; return A;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"冒泡排序","slug":"冒泡排序","date":"2018-02-13T14:50:35.000Z","updated":"2018-08-23T14:27:32.967Z","comments":true,"path":"2018/02/13/冒泡排序/","link":"","permalink":"https://lierabbit.cn/2018/02/13/冒泡排序/","excerpt":"","text":"对于一个int数组，请编写一个冒泡排序算法，对数组元素排序。给定一个int数组A及数组的大小n，请返回排序后的数组。测试样例：12[1,2,3,5,2,3],6[1,2,2,3,3,5] 时间复杂度：O(n2)空间复杂度：O(1) 思路：与下一个数进行判断交换，使最大值沉底 12345678910111213141516public int[] bubbleSort(int[] A, int n) &#123; // write code here int temp; for (int i = n - 1; i &gt; 0; i--) &#123; for (int j = 0; j &lt; i; j++) &#123; if (A[j] &gt; A[j + 1]) &#123; temp = A[j]; A[j] = A[j + 1]; A[j + 1] = temp; &#125; &#125; &#125; return A; &#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"ArrayList实现原理","slug":"ArrayList实现原理","date":"2018-01-23T04:29:37.000Z","updated":"2018-08-23T11:45:28.275Z","comments":true,"path":"2018/01/23/ArrayList实现原理/","link":"","permalink":"https://lierabbit.cn/2018/01/23/ArrayList实现原理/","excerpt":"","text":"概述ArrayList可以简单的看作是动态数组，相对于普通的数组它可以动态的增加容量或者减少容量。要注意的是ArrayList并不是线程安全的，因此一般建议在单线程中使用ArrayList。 实现原理继承关系1public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable ArrayList继承AbstractList实现List, RandomAccess, Cloneable, java.io.Serializable接口 关键属性12345678910111213141516/** * The array buffer into which the elements of the ArrayList are stored. * The capacity of the ArrayList is the length of this array buffer. Any * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA * will be expanded to DEFAULT_CAPACITY when the first element is added. */// 数据的数组transient Object[] elementData; // non-private to simplify nested class access/** * The size of the ArrayList (the number of elements it contains). * * @serial */// 实际数据的数量private int size; 底层使用数组保存所有元素transient 如果用transient声明一个实例变量，当对象存储时，它的值不需要维持。换句话来说就是，用transient关键字标记的成员变量不参与序列化过程 构造方法123456789101112/** * Shared empty array instance used for default sized empty instances. We * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when * first element is added. */private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;/** * Constructs an empty list with an initial capacity of ten. */public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125; 默认情况下初始化空数组（长度为0的数组） 123456789101112131415161718192021/** * Shared empty array instance used for empty instances. */private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;/** * Constructs an empty list with the specified initial capacity. * * @param initialCapacity the initial capacity of the list * @throws IllegalArgumentException if the specified initial capacity * is negative */public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException(\"Illegal Capacity: \"+ initialCapacity); &#125;&#125; 指定数组的初始容量当指定的初始容量大于0，初始化指定大小的数组当指定的初始容量等于0，初始化空数组当指定的初始容量小于0，抛出IllegalArgumentException异常12345678910111213141516171819/** * Constructs a list containing the elements of the specified * collection, in the order they are returned by the collection's * iterator. * * @param c the collection whose elements are to be placed into this list * @throws NullPointerException if the specified collection is null */public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; &#125;&#125; 初始化指定集合的数组当指定集合不为空即长度不为0，则复制该集合，否则初始化一个空数组 E get(int index) 获取index位置的元素123456789101112131415161718192021222324252627282930313233343536373839404142// Positional Access Operations// 返回index下标的元素且强制转化为E（List&lt;E&gt;中的E）类型@SuppressWarnings(\"unchecked\")E elementData(int index) &#123; return (E) elementData[index];&#125;/** * Returns the element at the specified position in this list. * * @param index index of the element to return * @return the element at the specified position in this list * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */public E get(int index) &#123; // 检查index是否越界 rangeCheck(index); // 返回index下标的元素 return elementData(index);&#125;/** * Checks if the given index is in range. If not, throws an appropriate * runtime exception. This method does *not* check if the index is * negative: It is always used immediately prior to an array access, * which throws an ArrayIndexOutOfBoundsException if index is negative. */private void rangeCheck(int index) &#123; // 检查index是否大于等于size（数组的元素数量），因为数组下标从0开始计算，所以也不能等于元素数量 // 这里没有检查index &lt; 0的情况，因为index &lt; 0时数组会自动抛出异常，所以并未检查index&lt;0的情况 if (index &gt;= size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index));&#125;/** * Constructs an IndexOutOfBoundsException detail message. * Of the many possible refactorings of the error handling code, * this \"outlining\" performs best with both server and client VMs. */private String outOfBoundsMsg(int index) &#123; return \"Index: \"+index+\", Size: \"+size;&#125; 首先判断index是否越界，这里并没有判断是否小于0，因为下标小于0时数组会抛出异常。越界则抛出IndexOutOfBoundsException异常，反之返回数组对应index位置的元素 E set(int index, E element) 设置（覆盖）index位置的元素12345678910111213141516/** * Replaces the element at the specified position in this list with * the specified element. * * @param index index of the element to replace * @param element element to be stored at the specified position * @return the element previously at the specified position * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */public E set(int index, E element) &#123; rangeCheck(index); E oldValue = elementData(index); elementData[index] = element; return oldValue;&#125; 和get一样先判断index（下标）是否越界，不越界则先获取原来index位置上的元素，接着设置（覆盖）index位置上的元素，然后返回原来的元素，反之抛出IndexOutOfBoundsException异常 boolean add(E e) 添加一个元素到列表尾123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/** * Appends the specified element to the end of this list. * * @param e element to be appended to this list * @return &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;@link Collection#add&#125;) */public boolean add(E e) &#123; // 检查当前容量是否还可以容纳一个元素，不够则扩容 ensureCapacityInternal(size + 1); // Increments modCount!! // 添加到数组末尾 // 这个语句可以分解为 // elementData[size] = e; // size += 1; elementData[size++] = e; return true;&#125;/** * Default initial capacity. */private static final int DEFAULT_CAPACITY = 10; // 默认容量为10// 如果数据等于默认数据，返回默认容量和minCapacity（所需容量最小值）的最大值，反之返回所需容量最小值private static int calculateCapacity(Object[] elementData, int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; return Math.max(DEFAULT_CAPACITY, minCapacity); &#125; return minCapacity;&#125;private void ensureCapacityInternal(int minCapacity) &#123; ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));&#125;private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // 操作数+1 // overflow-conscious code // 如果所需容量最小值大于实际数组的长度就扩大实际数组容量 if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125;/** * The maximum size of array to allocate. * Some VMs reserve some header words in an array. * Attempts to allocate larger arrays may result in * OutOfMemoryError: Requested array size exceeds VM limit */private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; // 数组最大容量为Integer最大值-8/** * Increases the capacity to ensure that it can hold at least the * number of elements specified by the minimum capacity argument. * * @param minCapacity the desired minimum capacity */private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; // 新的容量为旧的容量的1.5倍 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); // 如果扩充容量后还是不够，则新的容量等于所需容量最小值（一般就是数组实际元素个数） if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; // 如果新的容量大于数组最大容量，再调用hugeCapacity计算新的容量 if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: // 复制原来的数据到新的数组，数组容量为新的容量 elementData = Arrays.copyOf(elementData, newCapacity);&#125;private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); // 大于数组最大容量返回Integer最大值，反之返回数组最大容量 return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;&#125; 添加一个元素到列表尾，当列表容量不足时自动扩容（通常是扩容至原来的1.5倍），添加成功返回true void add(int index, E element) 在index处放置元素123456789101112131415161718192021222324252627282930/** * Inserts the specified element at the specified position in this * list. Shifts the element currently at that position (if any) and * any subsequent elements to the right (adds one to their indices). * * @param index index at which the specified element is to be inserted * @param element element to be inserted * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */public void add(int index, E element) &#123; // 检查下标是否越界 rangeCheckForAdd(index); // 检查当前容量是否还可以在容纳一个元素，不够则扩容 ensureCapacityInternal(size + 1); // Increments modCount!! // 将elementData从index开始后面的元素往后移一位 System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++;&#125;/** * A version of rangeCheck used by add and addAll. */private void rangeCheckForAdd(int index) &#123; // 当index等于size时相当于添加元素到列表尾 if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException(outOfBoundsMsg(index));&#125; 将elementData数组从index开始后面的元素往后移一位，接着在index处放置元素模拟添加数据(lierabbit)到index=4过程如下1 初始数组 0 1 2 3 4 5 6 7 8 9 a b c d e f g h i j 2 从index开始后面的元素往后移一位 0 1 2 3 4 5 6 7 8 9 a b c d e e f g h i 3 在index处放置lierabbit 0 1 2 3 4 5 6 7 8 9 a b c d lierabbit e f g h i boolean addAll(Collection&lt;? extends E&gt; c) 添加一个集合里的所有元素到列表尾123456789101112131415161718192021222324/** * Appends all of the elements in the specified collection to the end of * this list, in the order that they are returned by the * specified collection's Iterator. The behavior of this operation is * undefined if the specified collection is modified while the operation * is in progress. (This implies that the behavior of this call is * undefined if the specified collection is this list, and this * list is nonempty.) * * @param c collection containing elements to be added to this list * @return &lt;tt&gt;true&lt;/tt&gt; if this list changed as a result of the call * @throws NullPointerException if the specified collection is null */public boolean addAll(Collection&lt;? extends E&gt; c) &#123; Object[] a = c.toArray(); int numNew = a.length; // 检查当前容量是否还可以在容纳a数组的元素，不够则扩容 ensureCapacityInternal(size + numNew); // Increments modCount // 将a数组里的元素添加到elementData末尾 System.arraycopy(a, 0, elementData, size, numNew); size += numNew; // a数组不为空（长度不为0）时返回true，反之false return numNew != 0;&#125; 将要添加的集合变为数组，然后将其复制到elementData数组末尾 boolean addAll(int index, Collection&lt;? extends E&gt; c) 添加一个集合里的所有元素到index位置123456789101112131415161718192021222324252627282930313233343536/** * Inserts all of the elements in the specified collection into this * list, starting at the specified position. Shifts the element * currently at that position (if any) and any subsequent elements to * the right (increases their indices). The new elements will appear * in the list in the order that they are returned by the * specified collection's iterator. * * @param index index at which to insert the first element from the * specified collection * @param c collection containing elements to be added to this list * @return &lt;tt&gt;true&lt;/tt&gt; if this list changed as a result of the call * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; * @throws NullPointerException if the specified collection is null */public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; // 检查下标是否越界 rangeCheckForAdd(index); Object[] a = c.toArray(); int numNew = a.length; // 检查当前容量是否还可以在容纳a数组的元素，不够则扩容 ensureCapacityInternal(size + numNew); // Increments modCount // 需要往后移动几个位置 int numMoved = size - index; if (numMoved &gt; 0) // 从index开始，往后的元素向后移动numMoved个位置 System.arraycopy(elementData, index, elementData, index + numNew, numMoved); // 将a数组里的所有元素复制到elementData从index到index + numNew -1的位置上 System.arraycopy(a, 0, elementData, index, numNew); size += numNew; // a数组不为空（长度不为0）时返回true，反之false return numNew != 0;&#125; 将要添加的集合变为数组，然后把elementData数组从index开始，往后的元素向后移动numMoved个位置，接着将要添加的数组里的所有元素复制到elementData从index到index + numNew -1的位置上 void trimToSize() 改变列表内部数组容量至列表实际元素数量123456789101112131415/** * Trims the capacity of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance to be the * list's current size. An application can use this operation to minimize * the storage of an &lt;tt&gt;ArrayList&lt;/tt&gt; instance. */public void trimToSize() &#123; modCount++; // 操作数+1 // 如果数组实际元素数量小于数组长度 if (size &lt; elementData.length) &#123; // 如果数组实际元素数量等于0则数组被赋值为空数组，反之创建一个新的元素数量等于数组长度的数组 elementData = (size == 0) ? EMPTY_ELEMENTDATA : Arrays.copyOf(elementData, size); &#125;&#125; 当数据稳定了之后可以使用这个方法来减少内存的使用 int indexOf(Object o) 查找o元素在列表第一次出现的位置123456789101112131415161718192021/** * Returns the index of the first occurrence of the specified element * in this list, or -1 if this list does not contain the element. * More formally, returns the lowest index &lt;tt&gt;i&lt;/tt&gt; such that * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt;, * or -1 if there is no such index. */public int indexOf(Object o) &#123; //元素可以为null，如果为null返回null的下标 if (o == null) &#123; for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; &#125; else &#123; for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; &#125; // 没有找到对应的元素返回-1 return -1;&#125; ArrayList中可以存放null元素，indexof是返回elementData数组中值相同的首个元素的下标，indexof中比较方法是equals而equals是比较元素的值，因此必须对null单独查找。如果未找到该元素则返回-1 E remove(int index) 删除index位置上的元素1234567891011121314151617181920212223242526/** * Removes the element at the specified position in this list. * Shifts any subsequent elements to the left (subtracts one from their * indices). * * @param index the index of the element to be removed * @return the element that was removed from the list * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */public E remove(int index) &#123; // 检查下标是否越界 rangeCheck(index); modCount++; // 操作数+1 E oldValue = elementData(index); // 获取index位置上的元素 int numMoved = size - index - 1; // 需要往前移动几个位置 if (numMoved &gt; 0) // 从index + 1开始，往后的元素向前移动1个位置 System.arraycopy(elementData, index+1, elementData, index, numMoved); // 将数组末尾元素置空 elementData[--size] = null; // clear to let GC do its work return oldValue;&#125; 模拟删除index=4（值为lierabbit）过程如下1 初始数组 0 1 2 3 4 5 6 7 8 9 a b c d lierabbit f g h i j 2 从index + 1（即index=5，值为f）开始，往后的元素向前移动1个位置 0 1 2 3 4 5 6 7 8 9 a b c d f g h i j j 3 将数组末尾元素置空 0 1 2 3 4 5 6 7 8 9 a b c d f g h i j null boolean remove(Object o) 删除o元素123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * Removes the first occurrence of the specified element from this list, * if it is present. If the list does not contain the element, it is * unchanged. More formally, removes the element with the lowest index * &lt;tt&gt;i&lt;/tt&gt; such that * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt; * (if such an element exists). Returns &lt;tt&gt;true&lt;/tt&gt; if this list * contained the specified element (or equivalently, if this list * changed as a result of the call). * * @param o element to be removed from this list, if present * @return &lt;tt&gt;true&lt;/tt&gt; if this list contained the specified element */public boolean remove(Object o) &#123; // 元素可以为null，分开搜索o if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; // 没有找到返回false return false;&#125;/* * Private remove method that skips bounds checking and does not * return the value removed. */// 由于已经找到元素，则元素必定存在，则index必定合理，所以不需要在检查index是否越界private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work&#125; 通过寻找o元素，可以获得其下标，再根据下标删除o元素 forEach(Consumer&lt;? super E&gt; action)遍历列表12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * The number of times this list has been &lt;i&gt;structurally modified&lt;/i&gt;. * Structural modifications are those that change the size of the * list, or otherwise perturb it in such a fashion that iterations in * progress may yield incorrect results. * * &lt;p&gt;This field is used by the iterator and list iterator implementation * returned by the &#123;@code iterator&#125; and &#123;@code listIterator&#125; methods. * If the value of this field changes unexpectedly, the iterator (or list * iterator) will throw a &#123;@code ConcurrentModificationException&#125; in * response to the &#123;@code next&#125;, &#123;@code remove&#125;, &#123;@code previous&#125;, * &#123;@code set&#125; or &#123;@code add&#125; operations. This provides * &lt;i&gt;fail-fast&lt;/i&gt; behavior, rather than non-deterministic behavior in * the face of concurrent modification during iteration. * * &lt;p&gt;&lt;b&gt;Use of this field by subclasses is optional.&lt;/b&gt; If a subclass * wishes to provide fail-fast iterators (and list iterators), then it * merely has to increment this field in its &#123;@code add(int, E)&#125; and * &#123;@code remove(int)&#125; methods (and any other methods that it overrides * that result in structural modifications to the list). A single call to * &#123;@code add(int, E)&#125; or &#123;@code remove(int)&#125; must add no more than * one to this field, or the iterators (and list iterators) will throw * bogus &#123;@code ConcurrentModificationExceptions&#125;. If an implementation * does not wish to provide fail-fast iterators, this field may be * ignored. */protected transient int modCount = 0;//操作数@Overridepublic void forEach(Consumer&lt;? super E&gt; action) &#123; // 确保不为空 Objects.requireNonNull(action); final int expectedModCount = modCount; @SuppressWarnings(\"unchecked\") final E[] elementData = (E[]) this.elementData; final int size = this.size; for (int i=0; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123; action.accept(elementData[i]); &#125; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125;&#125;/** * Checks that the specified object reference is not &#123;@code null&#125;. This * method is designed primarily for doing parameter validation in methods * and constructors, as demonstrated below: * &lt;blockquote&gt;&lt;pre&gt; * public Foo(Bar bar) &#123; * this.bar = Objects.requireNonNull(bar); * &#125; * &lt;/pre&gt;&lt;/blockquote&gt; * * @param obj the object reference to check for nullity * @param &lt;T&gt; the type of the reference * @return &#123;@code obj&#125; if not &#123;@code null&#125; * @throws NullPointerException if &#123;@code obj&#125; is &#123;@code null&#125; */public static &lt;T&gt; T requireNonNull(T obj) &#123; if (obj == null) throw new NullPointerException(); return obj;&#125; 这里可以看到modCount的用处，当modCount发生改变后，立刻抛出ConcurrentModificationException异常。通过之前的分析可以知道当列表内容被修改时modCount会增加。也就是说如果在遍历ArrayList的过程中有其他线程修改了ArrayList，那么将抛出ConcurrentModificationException异常 ArrayList小结 ArrayList是List接口的一个可变大小的数组的实现 ArrayList的内部是使用一个Object对象数组来存储元素的 初始化ArrayList的时候，可以指定初始化容量的大小，如果不指定，就会使用默认大小，为10 当添加一个新元素的时候，首先会检查容量是否足够添加这个元素，如果够就直接添加，如果不够就进行扩容，扩容为原数组容量的1.5倍 当在index处放置一个元素的时候，会将数组index处右边的元素全部右移 当在index处删除一个元素的时候，会将数组index处右边的元素全部左移","categories":[{"name":"Java从深入到放弃","slug":"Java从深入到放弃","permalink":"https://lierabbit.cn/categories/Java从深入到放弃/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://lierabbit.cn/tags/Java/"}]},{"title":"SpringBoot快速入门6-thymeleaf","slug":"SpringBoot快速入门6-thymeleaf","date":"2018-01-21T13:48:52.000Z","updated":"2018-08-23T13:42:57.927Z","comments":true,"path":"2018/01/21/SpringBoot快速入门6-thymeleaf/","link":"","permalink":"https://lierabbit.cn/2018/01/21/SpringBoot快速入门6-thymeleaf/","excerpt":"","text":"静态资源在我们开发Web应用的时候，需要引用大量的js、css、图片等静态资源。Spring Boot的默认位置是resources/static 模版页面各种模版的页面，这次我们选用ThymeleafSpring Boot的默认位置是resources/templates 渲染页面在之前的示例中，我们都是通过@RestController来处理请求，所以返回的内容为json对象。当我们需要页面的时候使用@Controller，使其寻找模版页面 添加依赖对于已存在的项目可以在bulid.gradle加入12compile(&apos;org.springframework.boot:spring-boot-starter-thymeleaf&apos;)compile(&apos;org.springframework.boot:spring-boot-starter-web&apos;) 至此Thymeleaf已经引入 创建控制器新建一个ThymeleafCtrl类1234567891011121314import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;@Controller//这是一个控制器public class ThymeleafCtrl&#123; @RequestMapping(\"/\") public String hello(Model model) &#123; model.addAttribute(\"hello\",\"hello thymeleaf\");//添加一个值为\"hello thymeleaf\"的hello变量到视图 return \"hello\";//在templates下寻找hello.html &#125;&#125; 创建模版页面在resources/templates创建一个hello.html页面1234567891011&lt;!DOCTYPE html&gt;&lt;html xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;!-- xmlns:th=\"http://www.thymeleaf.org\" 减少ide报错，可以没有 --&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"/&gt; &lt;title&gt;Hello&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 th:text=\"$&#123;hello&#125;\"&gt;LieRabbit&lt;/h1&gt;&lt;!-- 使用hello变量 --&gt;&lt;img src=\"lierabbit.jpg\"/&gt;&lt;/body&gt;&lt;/html&gt; 添加图片资源在resources/static添加lierabbit.jpg 运行结果更多的Thymeleaf的语法请前往官网查看文档（http://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html）源码地址：https://github.com/LieRabbit/SpringBoot-thymeleaf","categories":[{"name":"Spring Boot快速入门","slug":"Spring-Boot快速入门","permalink":"https://lierabbit.cn/categories/Spring-Boot快速入门/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://lierabbit.cn/tags/Spring-Boot/"}]},{"title":"SpringBoot快速入门5-使用MyBatis（注解形式）进行数据库操作","slug":"SpringBoot快速入门5-使用MyBatis（注解形式）进行数据库操作","date":"2018-01-17T01:31:07.000Z","updated":"2018-08-23T13:35:33.566Z","comments":true,"path":"2018/01/17/SpringBoot快速入门5-使用MyBatis（注解形式）进行数据库操作/","link":"","permalink":"https://lierabbit.cn/2018/01/17/SpringBoot快速入门5-使用MyBatis（注解形式）进行数据库操作/","excerpt":"","text":"添加依赖新建项目选择web,MyBatis,MySQL三个依赖 对于已存在的项目可以在bulid.gradle加入，spring boot将会帮你自动配置好1234compile(&apos;org.springframework.boot:spring-boot-starter-data-jpa&apos;)compile(&apos;org.springframework.boot:spring-boot-starter-web&apos;)runtime(&apos;mysql:mysql-connector-java&apos;)testCompile(&apos;org.springframework.boot:spring-boot-starter-test&apos;) 配置基本信息然后在src/main/resources/application.properties下添加基本配置12345678#数据库连接地址spring.datasource.url=jdbc:mysql://localhost:3306/mybaits?useSSL=false#数据库账号spring.datasource.username=root#数据库密码spring.datasource.password=123456zxc#数据库驱动spring.datasource.driver-class-name=com.mysql.jdbc.Driver 创建实体创建一个User实体，包含id、name（姓名）、age（年龄）属性12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class User&#123; private Long id; private String name; private Integer age; public User() &#123; &#125; public User(String name, Integer age) &#123; this.name = name; this.age = age; &#125; public Long getId() &#123; return id; &#125; public void setId(Long id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125;&#125; 创建数据访问接口创建一个userMapper接口，进行数据库操作，添加@Mapper注解12345678910111213141516171819202122232425import org.apache.ibatis.annotations.*;import java.util.List;@Mapper//这是一个MyBatis的数据库操作接口public interface UserMapper&#123; @Select(\"SELECT * FROM user WHERE name = #&#123;name&#125;\") User findByName(@Param(\"name\") String name); @Select(\"SELECT * FROM user WHERE name LIKE #&#123;name&#125;\") List&lt;User&gt; findByNameLike(@Param(\"name\") String name); @Insert(\"INSERT INTO user(name, age) VALUES(#&#123;name&#125;, #&#123;age&#125;)\") int insert(@Param(\"name\") String name, @Param(\"age\") Integer age); @Update(\"UPDATE user SET age = #&#123;age&#125; WHERE name = #&#123;name&#125;\") int update(@Param(\"name\") String name, @Param(\"age\") Integer age); @Delete(\"DELETE FROM user WHERE name = #&#123;name&#125;\") int delete(@Param(\"name\") String name); @Select(\"SELECT COUNT(*) FROM user\") int countAll();&#125; 单元测试在src/test/java/你的包名/你的项目名ApplicationTests编写对应的单元测试来验证编写的内容是否正确12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import org.junit.Assert;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.annotation.Rollback;import org.springframework.test.context.junit4.SpringRunner;import org.springframework.transaction.annotation.Transactional;@RunWith(SpringRunner.class)@SpringBootTest@Transactional//声明事务，配合Rollbackpublic class MybatisApplicationTests&#123; @Autowired private UserMapper userMapper; @Test @Rollback//测试结束回滚数据，保证测试单元每次运行的数据环境独立 public void testUser() &#123; userMapper.insert(\"QQQ\",1); userMapper.insert(\"WWW\",2); userMapper.insert(\"EEE\",3); userMapper.insert(\"AAA\",4); userMapper.insert(\"SSS\",5); userMapper.insert(\"DDD\",6); userMapper.insert(\"ZZZ\",7); userMapper.insert(\"XXX\",8); userMapper.insert(\"CCC\",9); userMapper.insert(\"SSS213\",10); // 测试findAll, 查询所有记录 Assert.assertEquals(10, userMapper.countAll()); // 测试findByName, 查询姓名为AAA的User Assert.assertEquals(4, userMapper.findByName(\"AAA\").getAge().longValue()); // 更新CCC用户的年龄为15 userMapper.update(\"CCC\",15); // 测试findByName, 查询姓名为CCC的User的年龄是否为15 Assert.assertEquals(15, userMapper.findByName(\"CCC\").getAge().longValue()); // 测试删除姓名为AAA的User userMapper.delete(\"AAA\"); // 测试findAll, 查询所有记录, 验证上面的删除是否成功 Assert.assertEquals(9, userMapper.countAll()); // 测试findAll, 查询名字有S的有几个 Assert.assertEquals(2,userMapper.findByNameLike(\"%S%\").size()); &#125;&#125; 测试结果 源码地址：https://github.com/LieRabbit/SpringBoot-mybatis","categories":[{"name":"Spring Boot快速入门","slug":"Spring-Boot快速入门","permalink":"https://lierabbit.cn/categories/Spring-Boot快速入门/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://lierabbit.cn/tags/Spring-Boot/"}]},{"title":"SpringBoot快速入门4-使用jpa进行数据库操作","slug":"SpringBoot快速入门4-使用jpa进行数据库操作","date":"2018-01-15T15:49:41.000Z","updated":"2018-08-23T13:34:32.648Z","comments":true,"path":"2018/01/15/SpringBoot快速入门4-使用jpa进行数据库操作/","link":"","permalink":"https://lierabbit.cn/2018/01/15/SpringBoot快速入门4-使用jpa进行数据库操作/","excerpt":"","text":"添加依赖新建项目选择web,JPA,MySQL三个依赖 对于已存在的项目可以在bulid.gradle加入，spring boot将会帮你自动配置好 123compile(&apos;org.springframework.boot:spring-boot-starter-data-jpa&apos;)compile(&apos;org.springframework.boot:spring-boot-starter-web&apos;)runtime(&apos;mysql:mysql-connector-java&apos;) 配置基本信息然后在src/main/resources/application.properties下添加基本配置123456789101112#数据库连接地址spring.datasource.url=jdbc:mysql://localhost:3306/jpa?useSSL=false#数据库账号spring.datasource.username=root#数据库密码spring.datasource.password=123456zxc#数据库驱动spring.datasource.driver-class-name=com.mysql.jdbc.Driver#jpa设置spring.jpa.hibernate.ddl-auto=create#是否在控制台显示数据库语句spring.jpa.show-sql=true spring.jpa.properties.hibernate.hbm2ddl.auto 其作用是：自动创建、更新、验证数据库表结构。该参数的几种配置如下： create：每次加载hibernate时都会删除上一次的生成的表，然后根据你的model类再重新来生成新表，哪怕两次没有任何改变也要这样执行，这就是导致数据库表数据丢失的一个重要原因。 create-drop：每次加载hibernate时根据model类生成表，但是sessionFactory一关闭,表就自动删除。 update：最常用的属性，第一次加载hibernate时根据model类会自动建立起表的结构（前提是先建立好数据库），以后加载hibernate时根据model类自动更新表结构，即使表结构改变了但表中的行仍然存在不会删除以前的行。要注意的是当部署到服务器后，表结构是不会被马上建立起来的，是要等应用第一次运行起来后才会。 validate：每次加载hibernate时，验证创建数据库表结构，只会和数据库中的表进行比较，不会创建新表，但是会插入新值。 none：什么都不做至此基本配置完成 创建实体创建一个User实体，包含id（主键）、name（姓名）、age（年龄）属性，通过ORM框架其会被映射到数据库表中，由于配置了hibernate.hbm2ddl.auto，在应用启动的时候框架会自动去数据库中创建对应的表。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import javax.persistence.Column;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.Id;@Entity//这是一个和数据库表相关联的类public class User&#123; @Id//主键 @GeneratedValue//自增长 private Long id;//id @Column(length = 30)//长度30 private String name;//名称 @Column(nullable = false)//不可空 private Integer age;//年龄 public User() &#123; &#125; public User(String name, Integer age) &#123; this.name = name; this.age = age; &#125; public Long getId() &#123; return id; &#125; public void setId(Long id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125;&#125; 创建数据访问接口创建一个userRepository接口，进行数据库操作 12345678910111213141516171819202122232425import org.springframework.data.jpa.repository.JpaRepository;import org.springframework.data.jpa.repository.Query;import org.springframework.data.repository.query.Param;import java.util.List;public interface UserRepository extends JpaRepository&lt;User, Long&gt;//JpaRepository&lt;实体类型，主键类型&gt;&#123; // 通过名称找到用户 User findByName(String name); // 通过名称和年龄找到用户 User findByNameAndAge(String name, Integer age); // 通过名称模糊查询 List&lt;User&gt; findByNameLike(String name); // 使用hql查询 @Query(\"from User u where u.name=:name\")//:name对应@Param里的name User findByHQL(@Param(\"name\") String name); // 使用sql查询 @Query(value = \"select * from user where name = ?1 and age = ?2\", nativeQuery = true)//?1表示第一个参数，?2表示第二个参数 User findBySQL(String name, Integer age);&#125; 单元测试在src/test/java/你的包名/你的项目名ApplicationTests编写对应的单元测试来验证编写的内容是否正确 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import org.junit.Assert;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;@RunWith(SpringRunner.class)@SpringBootTestpublic class JpaLearnApplicationTests&#123; // 注入userRepository @Autowired private UserRepository userRepository; @Test public void contextLoads() &#123; // 添加10个测试用例 userRepository.save(new User(\"QQQ\",1)); userRepository.save(new User(\"WWW\",2)); userRepository.save(new User(\"EEE\",3)); userRepository.save(new User(\"AAA\",4)); userRepository.save(new User(\"SSS\",5)); userRepository.save(new User(\"DDD\",6)); userRepository.save(new User(\"ZZZ\",7)); userRepository.save(new User(\"XXX\",8)); userRepository.save(new User(\"CCC\",9)); userRepository.save(new User(\"QQQ2\",10)); // 测试findAll, 查询所有记录 Assert.assertEquals(10, userRepository.findAll().size()); // 测试findByName, 查询姓名为AAA的User Assert.assertEquals(4, userRepository.findByName(\"AAA\").getAge().longValue()); // 测试findByHQL, 查询姓名为AAA的User Assert.assertEquals(4, userRepository.findByHQL(\"AAA\").getAge().longValue()); // 测试findByNameAndAge, 查询姓名为SSS并且年龄为5的User Assert.assertEquals(\"SSS\", userRepository.findByNameAndAge(\"SSS\", 5).getName()); // 测试findBySQL, 查询姓名为SSS并且年龄为5的User Assert.assertEquals(\"SSS\", userRepository.findBySQL(\"SSS\", 5).getName()); // 测试删除姓名为AAA的User userRepository.delete(userRepository.findByName(\"AAA\")); // 测试findAll, 查询所有记录, 验证上面的删除是否成功 Assert.assertEquals(9, userRepository.findAll().size()); // 测试findAll, 查询名字有Q的有几个 Assert.assertEquals(2,userRepository.findByNameLike(\"%Q%\").size()); &#125;&#125; 点击运行测试用例 源码地址：https://github.com/LieRabbit/SpringBoot-jpa-learn","categories":[{"name":"Spring Boot快速入门","slug":"Spring-Boot快速入门","permalink":"https://lierabbit.cn/categories/Spring-Boot快速入门/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://lierabbit.cn/tags/Spring-Boot/"}]},{"title":"SpringBoot快速入门3-依赖注入","slug":"SpringBoot快速入门3-依赖注入","date":"2018-01-15T14:48:05.000Z","updated":"2018-08-23T13:33:44.285Z","comments":true,"path":"2018/01/15/SpringBoot快速入门3-依赖注入/","link":"","permalink":"https://lierabbit.cn/2018/01/15/SpringBoot快速入门3-依赖注入/","excerpt":"","text":"spring boot使用依赖注入的方式很简单，只需要给添加相应的注解即可 @Service用于标注业务层组件 @Controller用于标注控制层组件 @Repository用于标注数据访问组件，即DAO组件 @Component泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。然后在使用的地方使用@Autowired即可 创建MyComponent，使用@Component12345678910import org.springframework.stereotype.Component;@Component//泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。public class MyComponent&#123; public void hi(String name) &#123; System.out.println(\"hi \" + name + \",I am MyComponent\"); &#125;&#125; 创建MyController，使用@Controller12345678910import org.springframework.stereotype.Controller;@Controller//用于标注控制层组件public class MyController&#123; public void hi(String name) &#123; System.out.println(\"hi \" + name + \",I am MyController\"); &#125;&#125; 创建MyRepository，使用@Repository12345678@Repository//用于标注数据访问组件，即DAO组件public class MyRepository&#123; public void hi(String name) &#123; System.out.println(\"hi \" + name + \",I am MyRepository\"); &#125;&#125; 创建MyService，MyServiceImpl，使用@Service1234public interface MyService&#123; void doSomeThing();&#125; 123456789101112import org.springframework.stereotype.Service;@Service//用于标注业务层组件public class MyServiceImpl implements MyService&#123; @Override public void doSomeThing() &#123; System.out.println(\"i am MyServiceImpl\"); &#125;&#125; 单元测试在src/test/java/你的包名/你的项目名ApplicationTests编写对应的单元测试来验证是否可以成功注入 1234567891011121314151617181920212223242526272829import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;@RunWith(SpringRunner.class)@SpringBootTestpublic class DiApplicationTests&#123; @Autowired//自动注入 private MyController myController; @Autowired//自动注入 private MyRepository myRepository; @Autowired//自动注入 private MyComponent myComponent; @Autowired//自动注入实现了该接口的bean private MyService myService; @Test public void contextLoads() &#123; myController.hi(\"lierabbit\"); myRepository.hi(\"lierabbit\"); myComponent.hi(\"lierabbit\"); myService.doSomeThing(); &#125;&#125; 运行测试用例显示红圈的4句话证明成功注入 源码地址：https://github.com/LieRabbit/SpringBoot-DI","categories":[{"name":"Spring Boot快速入门","slug":"Spring-Boot快速入门","permalink":"https://lierabbit.cn/categories/Spring-Boot快速入门/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://lierabbit.cn/tags/Spring-Boot/"}]},{"title":"SpringBoot快速入门2-Http请求","slug":"SpringBoot快速入门2-Http请求","date":"2018-01-14T12:05:08.000Z","updated":"2018-08-23T13:32:36.598Z","comments":true,"path":"2018/01/14/SpringBoot快速入门2-Http请求/","link":"","permalink":"https://lierabbit.cn/2018/01/14/SpringBoot快速入门2-Http请求/","excerpt":"","text":"准备postman：一个接口测试工具创建一个新工程 选择web不会的请看Spring Boot快速入门（一）：Hello Spring Boot 开始新建java类RequestCtrl 添加一个all方法，使用@RequestMapping注解，可以处理所有的http请求 123456789@RestController//这是一个控制器并只返回数据不寻找视图public class RequestCtrl&#123; @RequestMapping(\"/\")//将本方法映射到/ public String all(String name, Integer age)//接受2个参数,name和age &#123; return \"这里是all\\n\" + \"name: \" + name + \"\\n\" + \"age: \" + age; &#125;&#125; requestMapping的作用可以简单理解为给方法加个地址，让别人能访问 通过源码可以看出@RestController是@Controller和ResponseBody的结合注解@Controller 表明这是一个控制器，将会返回数据或者页面@ResponseBody 表明只会返回数据，Spring Boot默认将数据使用jaskson序列化为json返回JSON(JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式，常见表现形式为键值对{key:value}，例如{name:”lierabbit”,age:20}，字符串和数字直接返回启动程序，打开postman对http://localhost:8080发起get请求 发起带参数的请求 使用post请求 添加一个get方法，使用@GetMapping注解，只可以处理get类型的http请求12345@GetMapping(\"/get\")//将本方法映射到/get，且只能用get方式访问public String get(String name, int age)//接受2个参数,name和age&#123; return \"这里是get\\n\" + \"name: \" + name + \"\\n\" + \"age: \" + age;&#125; 使用get方式访问http://localhost:8080/get?name=lierabbit&amp;age=20 尝试使用post访问，将得到405异常 添加一个post方法，使用@PostMapping注解，只可以处理post类型的http请求12345@PostMapping(\"/post\")//将本方法映射到/post，且只能用post方式访问public String post(String name, int age)//接受2个参数,name和age&#123; return \"这里是post\\n\" + \"name: \" + name + \"\\n\" + \"age: \" + age;&#125; 使用post方式访问 尝试使用get访问，得到405异常 添加一个put方法，使用@PutMapping注解，只可以处理put类型的http请求12345678@PutMapping(\"/put\")//将本方法映射到/put，且只能用put方式访问public User put(@RequestBody User user)//接受一个user实体&#123; user.setName(\"名字已经被修改：\" + user.getName()); user.setAge(user.getAge() + 1); return user;&#125;@RequestBody 表示接受一个user实体（user json） 返回User，会被spring boot自动序列化为json 添加一个delete方法，使用@DeleteMapping注解，只可以处理delete类型的http请求1234567@DeleteMapping(\"/delete\")//将本方法映射到/delete，且只能用delete方式访问public User delete(@RequestBody User user)//接受一个user实体&#123; user.setName(\"这个用户将会被删除：\" + user.getName()); user.setAge(user.getAge() + 1); return user;&#125; 添加一个patch方法，使用@PatchMapping注解，只可以处理patch类型的http请求123456@PatchMapping(\"/patch\")//将本方法映射到/patch，且只能用patch方式访问public User pathch(@RequestBody User user)//接受一个user实体&#123; user.setName(\"只改名称：\" + user.getName()); return user;&#125; 源码地址：https://github.com/LieRabbit/SpringBoot-request","categories":[{"name":"Spring Boot快速入门","slug":"Spring-Boot快速入门","permalink":"https://lierabbit.cn/categories/Spring-Boot快速入门/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://lierabbit.cn/tags/Spring-Boot/"}]},{"title":"升级node与npm","slug":"升级node与npm","date":"2018-01-14T09:48:54.000Z","updated":"2018-08-23T14:14:41.738Z","comments":true,"path":"2018/01/14/升级node与npm/","link":"","permalink":"https://lierabbit.cn/2018/01/14/升级node与npm/","excerpt":"","text":"升级node安装 n 工具，这个工具的名称很短，方便输入npm install -g n 升级node至长期版或者最新版上图为node中文官网的截图123n lts //升级到LTS版本，即上图的8.9.4n stable //升级到最新稳定版，即上图的9.4.0 n工具其它的一些命令123456789101112n 输出已安装的node版本n latest 安装最新的node版本n stable 安装最新稳定的node版本n lts 安装最新LTS的node版本n &lt;version&gt; 安装指定的node版本n bin &lt;version&gt; 输出指定的node的位置n rm &lt;version ...&gt; 删除指定的node版本n prune 删除除了当前node版本之外的所有版本n --latest 输出最新的node版本n --stable 输出最新稳定的node版本n --lts 输出最新LTS的node版本n ls 输出所有node版本 升级npm1npm install -g npm 一句话解决","categories":[],"tags":[{"name":"node.js","slug":"node-js","permalink":"https://lierabbit.cn/tags/node-js/"}]},{"title":"SpringBoot快速入门1-HelloSpringBoot","slug":"SpringBoot快速入门1-HelloSpringBoot","date":"2018-01-12T09:07:21.000Z","updated":"2018-08-23T13:30:48.533Z","comments":true,"path":"2018/01/12/SpringBoot快速入门1-HelloSpringBoot/","link":"","permalink":"https://lierabbit.cn/2018/01/12/SpringBoot快速入门1-HelloSpringBoot/","excerpt":"","text":"一、准备工作java环境：jdk 1.8开发工具：idea 二、创建项目打开idea 点击Create New Project 选择Spring Initializr，Next Group.Artifact = 你的包名type：个人喜欢选择gradle，默认的maven也可以Next 选择webNext 选择工程目录Finish 如果目录不存在，Idea将帮你创建，点击ok就行 如果没有下载过gradle，默认选择就行，点ok如果想使用已存在的gradle选择Use local gradle distribution 等待右下角（红圈部分）下载完成 添加HelloCtrl类添加如下代码1234567891011121314import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;@Controller//这是一个控制器public class HelloCtrl&#123; @RequestMapping(\"/\")//将地址映射到 / 即访问http://localhost:8080 就可以进入这个方法 @ResponseBody//返回数据,如果不添加该注解将在resources/templates下寻找与之对应的html模版 public String hello() &#123; return \"hello spring boot\"; &#125;&#125; 三、运行 点击右上角启动如果没有启动可点点击HelloSpringBootApplication左边的启动箭头即可启动 启动成功控制的打印如下图所示内容 打开浏览器，http://localhost:8080 出现hello spring boot字样则成功源码地址：https://github.com/LieRabbit/hello-spring-boot","categories":[{"name":"Spring Boot快速入门","slug":"Spring-Boot快速入门","permalink":"https://lierabbit.cn/categories/Spring-Boot快速入门/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://lierabbit.cn/tags/Spring-Boot/"}]}]}