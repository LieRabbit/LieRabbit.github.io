{"pages":[{"title":"关于谎话兔","date":"2018-08-20T12:11:42.000Z","updated":"2018-08-25T06:12:21.484Z","comments":false,"path":"about/index.html","permalink":"https://lierabbit.cn/about/index.html","excerpt":"","text":"123456789101112131415161718192021222324252627&#123; name: &apos;谎话兔&apos; age: 23, gender: &apos;男&apos;, profession: &apos;业余开发者&apos;, experience: &apos;0年&apos;, address: &apos;广东省广州市&apos;, education: &apos;本科&apos;, github: &apos;https://github.com/LieRabbit&apos;, blog: &apos;http://lierabbit.cn&apos;, email: &apos;lierabbit@qq.com&apos;, description: &apos;有些梦虽然遥不可及，但并不是不可能实现，只要我足够的强&apos;, skills: [ [&apos;Java&apos;, &apos;Spring Cloud&apos;, &apos;Spring Boot&apos;, &apos;Spring&apos;] [&apos;Angular&apos;, &apos;TypeScript&apos;], [&apos;Html&apos;, &apos;JavaScript&apos;, &apos;JQuery&apos;, &apos;CSS&apos;, &apos;ES6&apos;, &apos;Node&apos;, &apos;Sass&apos;], [&apos;Python&apos;, &apos;Django&apos;] [&apos;Git&apos;, &apos;SVN&apos;] ], devTools: [ [&apos;Idea&apos;, &apos;WebStorm&apos;, &apos;PyCharm&apos;, &apos;Visual Studio Code&apos;], [&apos;Chrome DevTools&apos;], [&apos;Navicat&apos;], ]&#125;"},{"title":"分类","date":"2018-08-20T12:12:46.000Z","updated":"2018-08-20T12:32:32.265Z","comments":false,"path":"categories/index.html","permalink":"https://lierabbit.cn/categories/index.html","excerpt":"","text":""},{"title":"书单","date":"2018-08-22T09:00:18.676Z","updated":"2018-08-22T09:00:18.676Z","comments":false,"path":"books/index.html","permalink":"https://lierabbit.cn/books/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2018-08-20T12:12:13.000Z","updated":"2018-08-20T12:21:05.858Z","comments":true,"path":"links/index.html","permalink":"https://lierabbit.cn/links/index.html","excerpt":"","text":""},{"title":"项目","date":"2018-08-20T12:12:23.000Z","updated":"2018-08-20T12:29:34.573Z","comments":false,"path":"repository/index.html","permalink":"https://lierabbit.cn/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-08-18T09:59:10.592Z","updated":"2018-08-18T09:59:10.592Z","comments":false,"path":"tags/index.html","permalink":"https://lierabbit.cn/tags/index.html","excerpt":"","text":"啦啦啦"}],"posts":[{"title":"报数","slug":"报数","date":"2018-10-10T03:05:51.000Z","updated":"2018-10-10T03:14:19.333Z","comments":true,"path":"2018/10/10/报数/","link":"","permalink":"https://lierabbit.cn/2018/10/10/报数/","excerpt":"","text":"题目描述报数序列是指一个整照其中的整数的顺序进数序列，按行报数，得到下一个数。其前五项如下： 12345111211211111221 1被读作&quot;one 1&quot;(&quot;一个一&quot;),即11。11被读作&quot;two 1s&quot;(&quot;两个一&quot;）,即21。21被读作&quot;one 2&quot;,&quot;one 1&quot;（&quot;一个二&quot;,&quot;一个一&quot;), 即1211。 给定一个正整数 n（1 ≤ n ≤ 30），输出报数序列的第 n 项。注意：整数顺序将表示为一个字符串。 示例 1: 输入: 1输出: “1” 示例 2: 输入: 4输出: “1211” 解决方法观察题目可知，第一个报数为“1”，每一个报数都是通过前一个报数计算得出，那么有 1 = “1” n = f(n-1)，n &gt; 1 通过以上分析可得以下代码 12345678910111213141516171819202122232425262728293031323334353637383940public String countAndSay(int n) &#123; if (n == 1) return \"1\"; else return parse(countAndSay(n - 1));&#125;/** * 解析字符串 * * @param str 待解析的字符串 * @return */public String parse(String str) &#123; StringBuilder sb = new StringBuilder(); // 前一个字符 char preCh = str.charAt(0); // 当前字符 char curCh; // 计数 int count = 1; // 根据规则解析字符串 for (int i = 1; i &lt; str.length(); i++) &#123; curCh = str.charAt(i); if (preCh == curCh) count++; else &#123; sb.append(count).append(preCh); preCh = curCh; count = 1; &#125; &#125; // 解析最后一个字符 sb.append(count).append(preCh); return sb.toString();&#125;","categories":[{"name":"LeetCode算法之旅","slug":"LeetCode算法之旅","permalink":"https://lierabbit.cn/categories/LeetCode算法之旅/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"解数独（Sudoku Solver）","slug":"解数独","date":"2018-10-09T06:22:53.000Z","updated":"2018-10-09T06:40:56.075Z","comments":true,"path":"2018/10/09/解数独/","link":"","permalink":"https://lierabbit.cn/2018/10/09/解数独/","excerpt":"","text":"题目描述编写一个程序，通过已填充的空格来解决数独问题。一个数独的解法需遵循如下规则： 数字1-9在每一行只能出现一次。 数字1-9在每一列只能出现一次。 数字1-9在每一个以粗实线分隔的3x3宫内只能出现一次。 空白格用&#39;.&#39;表示。 一个数独。 答案被标成红色。 Note: 给定的数独序列只包含数字1-9和字符&#39;.&#39;。 你可以假设给定的数独只有唯一解。 给定数独永远是9x9形式的。 解决方法使用回溯法枚举每一种可能性直到找到第一个解法 回溯一通过二维数组的长度和一维数组的长度遍历数组123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public void solveSudoku(char[][] board) &#123; if (board == null || board.length == 0) return; solve(board, 0, 0);&#125;/** * 递归求数独 * * @param board * @param row 行索引 * @param col 列索引 * @return */private boolean solve(char[][] board, int row, int col) &#123; for (int curRow = row; curRow &lt; board.length; curRow++) &#123; for (int curCol = col; curCol &lt; board[0].length; curCol++) &#123; if (board[curRow][curCol] == '.') &#123; // 尝试填入'1'-'9' for (char ch = '1'; ch &lt;= '9'; ch++) &#123; // 验证是否符合规则 if (isValid(board, curRow, curCol, ch)) &#123; // 尝试填入 board[curRow][curCol] = ch; // 继续解决下一个 if (solve(board, curRow, curCol + 1)) return true; else // 尝试失败，还原 board[curRow][curCol] = '.'; &#125; &#125; // 尝试'1'-'9'失败，开始回溯 return false; &#125; &#125; // 换行重置列索引 col = 0; &#125; return true;&#125;/** * 合法性验证 * * @param board * @param row 行索引 * @param col 列索引 * @param ch 要填入的数字 * @return */public boolean isValid(char[][] board, int row, int col, char ch) &#123; for (int i = 0; i &lt; 9; i++) &#123; if (board[row][i] == ch) return false; if (board[i][col] == ch) return false; if (board[row / 3 * 3 + i / 3][col / 3 * 3 + i % 3] == ch) return false; &#125; return true;&#125; 回溯二通过数组总长度遍历数组总共9x9=81个格子，从0开始计算范围是[0,80]行索引 = 当前第x个格子 / 9列索引 = 当前第x个格子 % 9 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public void solveSudoku(char[][] board) &#123; if (board == null || board.length != 9 || board[0].length != 9) return; solve(board, 0);&#125;/** * @param board * @param pos 准备填入数字的格子 * @return */public boolean solve(char[][] board, int pos) &#123; // 总共9x9=81个格子，从0开始计算范围是[0,80] if (pos == 81) return true; // 计算行索引 int row = pos / 9; // 计算列索引 int col = pos % 9; if (board[row][col] == '.') &#123; // 尝试填入'1'-'9' for (char ch = '1'; ch &lt;= '9'; ch++) &#123; // 验证是否符合规则 if (isValid(board, row, col, ch)) &#123; board[row][col] = ch; // 继续解决下一个 if (solve(board, pos + 1)) return true; else // 尝试失败，还原 board[row][col] = '.'; &#125; &#125; // 尝试'1'-'9'失败，开始回溯 return false; &#125; else &#123; // 当前的格子已有数，跳过当前的格子 return solve(board, pos + 1); &#125;&#125;/** * 合法性验证 * * @param board * @param row 行索引 * @param col 列索引 * @param ch 要填入的数字 * @return */public boolean isValid(char[][] board, int row, int col, char ch) &#123; for (int i = 0; i &lt; 9; i++) &#123; if (board[row][i] == ch) return false; if (board[i][col] == ch) return false; if (board[row / 3 * 3 + i / 3][col / 3 * 3 + i % 3] == ch) return false; &#125; return true;&#125;","categories":[{"name":"LeetCode算法之旅","slug":"LeetCode算法之旅","permalink":"https://lierabbit.cn/categories/LeetCode算法之旅/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"有效的数独（Valid Sudoku）","slug":"有效的数独","date":"2018-10-08T02:29:33.000Z","updated":"2018-10-09T02:16:35.213Z","comments":true,"path":"2018/10/08/有效的数独/","link":"","permalink":"https://lierabbit.cn/2018/10/08/有效的数独/","excerpt":"","text":"题目描述判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。 数字 1-9 在每一行只能出现一次。 数字 1-9 在每一列只能出现一次。 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。 上图是一个部分填充的有效的数独。数独部分空格内已填入了数字，空白格用 ‘.’ 表示。 示例 1: 输入:[ [“5”,”3”,”.”,”.”,”7”,”.”,”.”,”.”,”.”], [“6”,”.”,”.”,”1”,”9”,”5”,”.”,”.”,”.”], [“.”,”9”,”8”,”.”,”.”,”.”,”.”,”6”,”.”], [“8”,”.”,”.”,”.”,”6”,”.”,”.”,”.”,”3”], [“4”,”.”,”.”,”8”,”.”,”3”,”.”,”.”,”1”], [“7”,”.”,”.”,”.”,”2”,”.”,”.”,”.”,”6”], [“.”,”6”,”.”,”.”,”.”,”.”,”2”,”8”,”.”], [“.”,”.”,”.”,”4”,”1”,”9”,”.”,”.”,”5”], [“.”,”.”,”.”,”.”,”8”,”.”,”.”,”7”,”9”]]输出: true 示例 2: 输入:[ [“8”,”3”,”.”,”.”,”7”,”.”,”.”,”.”,”.”], [“6”,”.”,”.”,”1”,”9”,”5”,”.”,”.”,”.”], [“.”,”9”,”8”,”.”,”.”,”.”,”.”,”6”,”.”], [“8”,”.”,”.”,”.”,”6”,”.”,”.”,”.”,”3”], [“4”,”.”,”.”,”8”,”.”,”3”,”.”,”.”,”1”], [“7”,”.”,”.”,”.”,”2”,”.”,”.”,”.”,”6”], [“.”,”6”,”.”,”.”,”.”,”.”,”2”,”8”,”.”], [“.”,”.”,”.”,”4”,”1”,”9”,”.”,”.”,”5”], [“.”,”.”,”.”,”.”,”8”,”.”,”.”,”7”,”9”]]输出: false解释: 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。 但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。 说明: 一个有效的数独（部分已被填充）不一定是可解的。 只需要根据以上规则，验证已经填入的数字是否有效即可。 给定数独序列只包含数字1-9和字符&#39;.&#39;。 给定数独永远是9x9形式的。 解决方法遍历所有格子，收集出现过的字符，将其编码成如下所示： ‘7’ 出现在第4行(row=3)，则编码成”row37” ‘7’ 出现在第4列(col=3)，则编码成”col37” ‘7’ 出现在第4行第4列(row=3,col=3)，将其编码成”area” + row / 3 + col / 3 + ‘7’ 即”area117” 如果发现有一样的编码格式则说明不符合规则返回false 1234567891011121314151617public boolean isValidSudoku(char[][] board) &#123; if (board == null) return false; Set&lt;String&gt; set = new HashSet&lt;&gt;(); for (int row = 0; row &lt; board.length; row++) &#123; for (int col = 0; col &lt; board[row].length; col++) &#123; char ch = board[row][col]; if (ch != '.') &#123; if (!set.add(\"row\" + row + ch) || !set.add(\"col\" + col + ch) || !set.add(\"area\" + row / 3 + col / 3 + ch)) return false; &#125; &#125; &#125; return true;&#125;","categories":[{"name":"LeetCode算法之旅","slug":"LeetCode算法之旅","permalink":"https://lierabbit.cn/categories/LeetCode算法之旅/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"搜索插入位置（Search Insert Position）","slug":"搜索插入位置","date":"2018-09-30T04:25:25.000Z","updated":"2018-09-30T04:28:03.143Z","comments":true,"path":"2018/09/30/搜索插入位置/","link":"","permalink":"https://lierabbit.cn/2018/09/30/搜索插入位置/","excerpt":"","text":"题目描述给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。你可以假设数组中无重复元素。 示例 1: 输入: [1,3,5,6], 5输出: 2 示例 2: 输入: [1,3,5,6], 2输出: 1 示例 3: 输入: [1,3,5,6], 7输出: 4 示例 4: 输入: [1,3,5,6], 0输出: 0 解决方法使用二分搜索1234567891011121314151617181920public int searchInsert(int[] nums, int target) &#123; int left = 0, right = nums.length - 1; if (target &lt; nums[left]) return 0; if (target &gt; nums[right]) return right + 1; while (left &lt;= right) &#123; int mid = left + (right - left) / 2; if (nums[mid] == target) return mid; else if (nums[mid] &gt; target) right = mid - 1; else left = mid + 1; &#125; return left;&#125;","categories":[{"name":"LeetCode算法之旅","slug":"LeetCode算法之旅","permalink":"https://lierabbit.cn/categories/LeetCode算法之旅/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"在排序数组中查找元素的第一个和最后一个位置（Find First and Last Position of Element in Sorted Array）","slug":"在排序数组中查找元素的第一个和最后一个位置","date":"2018-09-29T02:39:19.000Z","updated":"2018-09-29T02:48:07.356Z","comments":true,"path":"2018/09/29/在排序数组中查找元素的第一个和最后一个位置/","link":"","permalink":"https://lierabbit.cn/2018/09/29/在排序数组中查找元素的第一个和最后一个位置/","excerpt":"","text":"题目描述给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。你的算法时间复杂度必须是 O(log n) 级别。如果数组中不存在目标值，返回 [-1, -1]。 示例 1: 输入: nums = [5,7,7,8,8,10], target = 8输出: [3,4] 示例 2: 输入: nums = [5,7,7,8,8,10], target = 6输出: [-1,-1] 解决方法使用两次二分查找使用二分查找搜索目标值的开始位置，如果找不到则直接返回[-1,-1]，否则继续使用二分查找搜索结束位置1234567891011121314151617181920212223242526272829303132333435363738394041public int[] searchRange(int[] nums, int target) &#123; int[] res = new int[]&#123;-1, -1&#125;; if (nums == null || nums.length == 0) return res; int firstIndex = binarySearch(nums, target, true); // 找不到第一个则最后一个必定不存在 if (firstIndex == -1) return res; res[0] = firstIndex; res[1] = binarySearch(nums, target, false); return res;&#125;/** * 二分查找 * * @param nums * @param target * @param isFindFirst true查找第一个,false查找最后一个 * @return */public int binarySearch(int nums[], int target, boolean isFindFirst) &#123; int left = 0, right = nums.length - 1, res = -1; while (left &lt;= right) &#123; int mid = left + (right - left) / 2; if (nums[mid] == target) &#123; res = mid; if (isFindFirst) right = mid - 1; else left = mid + 1; &#125; else if (nums[mid] &lt; target) left = mid + 1; else right = mid - 1; &#125; return res;&#125; 改进现在我们每次查找都从头（0）开始搜索，通过第一次搜索我们知道开始位置在哪，所以我们查找结束位置的时候可以从开始位置开始搜索，缩小了搜索范围123456789101112131415161718192021222324252627282930313233343536373839404142public int[] searchRange2(int[] nums, int target) &#123; int[] res = new int[]&#123;-1, -1&#125;; if (nums == null || nums.length == 0) return res; int firstIndex = binarySearch2(nums, 0, target, true); // 找不到第一个则最后一个必定不存在 if (firstIndex == -1) return res; res[0] = firstIndex; res[1] = binarySearch2(nums, firstIndex, target, false); return res;&#125;/** * 二分查找 * * @param start 开始索引 * @param nums * @param target * @param isFindFirst true查找第一个,false查找最后一个 * @return */public int binarySearch2(int nums[], int start, int target, boolean isFindFirst) &#123; int left = start, right = nums.length - 1, res = -1; while (left &lt;= right) &#123; int mid = left + (right - left) / 2; if (nums[mid] == target) &#123; res = mid; if (isFindFirst) right = mid - 1; else left = mid + 1; &#125; else if (nums[mid] &lt; target) left = mid + 1; else right = mid - 1; &#125; return res;&#125;","categories":[{"name":"LeetCode算法之旅","slug":"LeetCode算法之旅","permalink":"https://lierabbit.cn/categories/LeetCode算法之旅/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"搜索旋转排序数组（Search in Rotated Sorted Array）","slug":"搜索旋转排序数组","date":"2018-09-28T07:32:09.000Z","updated":"2018-10-09T02:17:09.731Z","comments":true,"path":"2018/09/28/搜索旋转排序数组/","link":"","permalink":"https://lierabbit.cn/2018/09/28/搜索旋转排序数组/","excerpt":"","text":"题目描述假设按照升序排序的数组在预先未知的某个点上进行了旋转。( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。你可以假设数组中不存在重复的元素。你的算法时间复杂度必须是 O(log n) 级别。 示例 1: 输入: nums = [4,5,6,7,0,1,2], target = 0输出: 4 示例 2: 输入: nums = [4,5,6,7,0,1,2], target = 3输出: -1 解决方法由于是旋转排序数组，所以局部有序，可以使用二分搜索 当局部数组中间元素(nums[mid])等于目标(target)，则返回mid 当局部数组头元素(nums[left])小于等于nums[mid]，等于是用于left==mid的时候，则[left,mid]这区间的元素是有序的。如果target &gt;= nums[left]且target &lt; nums[mid]说明target在[left,mid)区间里 当上面的条件不成立，则说明nums[mid] &lt; nums[right]，说明[mid,right]这区间的元素是有序的，当target &gt; nums[mid] 且 target &lt;= nums[right]，说明target在(mid,right]区间里12345678910111213141516171819202122232425public int search(int[] nums, int target) &#123; if (nums == null || nums.length == 0) return -1; int left = 0, right = nums.length - 1; while (left &lt; right) &#123; int mid = left + ((right - left) &gt;&gt; 1); if (nums[mid] == target) return mid; else if (nums[left] &lt;= nums[mid]) &#123; if (target &gt;= nums[left] &amp;&amp; target &lt; nums[mid]) right = mid - 1; else left = mid + 1; &#125; else &#123; if (target &gt; nums[mid] &amp;&amp; target &lt;= nums[right]) left = mid + 1; else right = mid - 1; &#125; &#125; // 当left == right时，判断一下是否是target return nums[left] == target ? left : -1;&#125;","categories":[{"name":"LeetCode算法之旅","slug":"LeetCode算法之旅","permalink":"https://lierabbit.cn/categories/LeetCode算法之旅/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"最长有效括号（Longest Valid Parentheses）","slug":"最长有效括号","date":"2018-09-27T04:15:50.000Z","updated":"2018-09-27T04:27:59.369Z","comments":true,"path":"2018/09/27/最长有效括号/","link":"","permalink":"https://lierabbit.cn/2018/09/27/最长有效括号/","excerpt":"","text":"题目描述给定一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长的包含有效括号的子串的长度。 示例 1: 输入: “(()”输出: 2解释: 最长有效括号子串为 “()”示例 2: 输入: “)()())”输出: 4解释: 最长有效括号子串为 “()()” 解决方法在扫描字符串的时候使用堆栈来检查目前为止扫描的字符串是否是有效的括号，以及统计最长的有效括号长度 当字符为’(‘时将其压入堆栈 当字符为’)’时，弹出栈顶，如果此时栈空则将当前索引i入栈，否则当前有效括号字串的长度为i - 当前栈顶，更新最长的有效括号长度你的浏览器不支持观看视频，请使用新版chrome浏览12345678910111213141516171819public int longestValidParentheses(String s) &#123; int maxLen = 0; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); stack.push(-1); for (int i = 0; i &lt; s.length(); i++) &#123; if (s.charAt(i) == '(') stack.push(i); else &#123; stack.pop(); if (stack.isEmpty()) stack.push(i); else maxLen = Math.max(maxLen, i - stack.peek()); &#125; &#125; return maxLen;&#125;","categories":[{"name":"LeetCode算法之旅","slug":"LeetCode算法之旅","permalink":"https://lierabbit.cn/categories/LeetCode算法之旅/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"下一个排列（Next Permutation）","slug":"下一个排列","date":"2018-09-26T03:10:37.000Z","updated":"2018-09-27T04:19:06.698Z","comments":true,"path":"2018/09/26/下一个排列/","link":"","permalink":"https://lierabbit.cn/2018/09/26/下一个排列/","excerpt":"","text":"题目描述实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。必须原地修改，只允许使用额外常数空间。以下是一些例子，输入位于左侧列，其相应输出位于右侧列。1231,2,3 → 1,3,23,2,1 → 1,2,31,1,5 → 1,5,1 解决方法通过观察例子发现如果以降序排列则无法找到下一个更大的排列，例如3,2,1 -&gt; 1,2,3，则是否有下一个更大的排列就取决于是否是降序当不是降序的时候，例如1,5,8,4,7,6,5,3,1。 从后往前寻找第一个不是升序的数num1，记录其索引i。由于数位越低数值越小，所以从后往前找利于获取下一个更大的排序 从后往前寻找第一个比num1大的数num2，则num2是右边里大于num1的数中最小的 交换num1,num2位置，这时还不是下一个更大的排列，我们需要将i右边小的数排在前面以获取更小的局部排列，这样才是下一个更大的排列 反转i右边的数，因为i右边的数是升序排列的，所以反转其即可获得更小的局部排列 你的浏览器不支持观看视频，请使用新版chrome浏览 1234567891011121314151617181920212223242526272829303132public void nextPermutation(int[] nums) &#123; int i = nums.length - 2; // 寻找第一个降序的数字 while (i &gt;= 0 &amp;&amp; nums[i + 1] &lt;= nums[i]) i--; if (i &gt;= 0) &#123; int j = nums.length - 1; // 寻找第一个比nums[i]大的数 while (j &gt; i &amp;&amp; nums[j] &lt;= nums[i]) j--; swap(nums, i, j); &#125; reverse(nums, i + 1);&#125;/** * 交换 */public void swap(int[] nums, int i, int j) &#123; int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp;&#125;/** * 反转 */public void reverse(int[] nums, int start) &#123; int left = start, right = nums.length - 1; while (left &lt; right) swap(nums, left++, right--);&#125; 复杂度分析 时间复杂度：O(n)O(n)，在最坏的情况下，只需要对整个数组进行两次扫描。 空间复杂度：O(1)O(1)，没有使用额外的空间，原地替换足以做到。","categories":[{"name":"LeetCode算法之旅","slug":"LeetCode算法之旅","permalink":"https://lierabbit.cn/categories/LeetCode算法之旅/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"与所有单词相关联的字串（Substring with Concatenation of All Words）","slug":"与所有单词相关联的字串","date":"2018-09-25T03:17:40.000Z","updated":"2018-09-25T03:43:38.589Z","comments":true,"path":"2018/09/25/与所有单词相关联的字串/","link":"","permalink":"https://lierabbit.cn/2018/09/25/与所有单词相关联的字串/","excerpt":"","text":"题目描述给定一个字符串 s 和一些长度相同的单词 words。在 s 中找出可以恰好串联 words 中所有单词的子串的起始位置。注意子串要与 words 中的单词完全匹配，中间不能有其他字符，但不需要考虑 words 中单词串联的顺序。 示例 1: 输入: s = “barfoothefoobarman”, words = [“foo”,”bar”]输出: [0,9]解释: 从索引 0 和 9 开始的子串分别是 “barfoor” 和 “foobar” 。输出的顺序不重要, [9,0] 也是有效答案。 示例 2: 输入: s = “wordgoodstudentgoodword”, words = [“word”,”student”]输出: [] 解决方法使用两个map，counts用来记录word预期出现的次数，seen用来记录word实际出现次数，然后我们检查索引i的每个可能的位置， 一旦我们遇到不在words里的word或word出现的次数大于预期的次数，我们就会停止检查。 如果我们成功完成检查，将i推送到索引结果集合。 索引i可能的范围[0,max)计算说明：max = n - wl * len + 1n为字符串长度，wl为words数组长度，len为word的长度（题目说每个word都是一样的长度）举个例子：如果字符串s长度为10，那么其索引范围是[0,10)，words数组长度为3，word长度为2，max = 10 - 3 * 2 + 1 = 5，则索引的可能的范围是[0,5)为什么要减去 wl * len（words子串长度） ？因为如果要检查的字符串长度小于 wl * len 肯定不会有符合的子串为什么+1？因为索引从0开始计算，使用i&lt;=max可以不+11234567891011121314151617181920212223242526272829303132public List&lt;Integer&gt; findSubstring(String s, String[] words) &#123; List&lt;Integer&gt; indexes = new ArrayList&lt;&gt;(); if (s == null || s.isEmpty() || words == null || words.length == 0) return indexes; Map&lt;String, Integer&gt; counts = new HashMap&lt;&gt;(); // 统计预期出现次数 for (String word : words) counts.compute(word, (k, v) -&gt; v == null ? 0 : v + 1); int n = s.length(), wl = words.length, len = words[0].length(); for (int i = 0, max = n - wl * len + 1, j; i &lt; max; i++) &#123; Map&lt;String, Integer&gt; seen = new HashMap&lt;&gt;(); for (j = 0; j &lt; wl; j++) &#123; // 获取一个单词 String word = s.substring(i + j * len, i + (j + 1) * len); if (counts.containsKey(word)) &#123; seen.compute(word, (k, v) -&gt; v == null ? 0 : v + 1); if (seen.get(word) &gt; counts.get(word)) break; &#125; else break; &#125; // 所有的word都匹配中了 if (j == wl) indexes.add(i); &#125; return indexes;&#125;","categories":[{"name":"LeetCode算法之旅","slug":"LeetCode算法之旅","permalink":"https://lierabbit.cn/categories/LeetCode算法之旅/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"两数相除（Divide Two Integers）","slug":"两数相除","date":"2018-09-21T07:58:44.000Z","updated":"2018-09-21T10:07:18.051Z","comments":true,"path":"2018/09/21/两数相除/","link":"","permalink":"https://lierabbit.cn/2018/09/21/两数相除/","excerpt":"","text":"题目描述给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。返回被除数 dividend 除以除数 divisor 得到的商。 示例 1: 输入: dividend = 10, divisor = 3输出: 3 示例 2: 输入: dividend = 7, divisor = -3输出: -2 说明:被除数和除数均为 32 位有符号整数。除数不为 0。假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231, 231 − 1]。本题中，如果除法结果溢出，则返回 231 − 1。 解决方法任何一个整数都可以表示成：num=a020+a121+a222+…+an2n基于这个公式以及左移一位相当于乘以2，得出以下算法1.先让除数左移直到大于被除数之前得到一个最大的数（temp）2.被除数每次减去temp，商（res）加上2k，k为左移的次数，被除数减去temp3.重复1、2直到被除数小于除数为止1234567891011121314151617181920212223public int divide(int dividend, int divisor) &#123; // 相除时溢出处理 if (divisor == 0 || (dividend == Integer.MIN_VALUE &amp;&amp; divisor == -1)) return Integer.MAX_VALUE; // 获取符号位 int sign = (dividend &lt; 0) ^ (divisor &lt; 0) ? -1 : 1; // 使用long防止取绝对值溢出，例如当Math.abs(Integer.MIN_VALUE)就会溢出 long dvd = Math.abs((long) dividend); long dvs = Math.abs((long) divisor); int res = 0; while (dvd &gt;= dvs) &#123; long temp = dvs, multiple = 1; while (dvd &gt;= (temp &lt;&lt; 1)) &#123; temp &lt;&lt;= 1; multiple &lt;&lt;= 1; &#125; dvd -= temp; res += multiple; &#125; return sign == 1 ? res : -res;&#125;","categories":[{"name":"LeetCode算法之旅","slug":"LeetCode算法之旅","permalink":"https://lierabbit.cn/categories/LeetCode算法之旅/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"实现strStr（Implement strStr）","slug":"实现strStr","date":"2018-09-20T09:45:14.000Z","updated":"2018-09-20T09:53:23.415Z","comments":true,"path":"2018/09/20/实现strStr/","link":"","permalink":"https://lierabbit.cn/2018/09/20/实现strStr/","excerpt":"","text":"题目描述实现 strStr() 函数。给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。 示例 1: 输入: haystack = “hello”, needle = “ll”输出: 2 示例 2: 输入: haystack = “aaaaa”, needle = “bba”输出: -1 说明:当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。 解决方法模仿jdk源码的实现，基本思路就是暴力匹配1234567891011121314151617181920212223242526public int strStr(String haystack, String needle) &#123; if (needle.isEmpty()) return 0; char first = needle.charAt(0); int max = haystack.length() - needle.length(); for (int i = 0; i &lt;= max; i++) &#123; // 寻找第一个相同的字符 if (haystack.charAt(i) != first) &#123; while (++i &lt;= max &amp;&amp; haystack.charAt(i) != first) ; &#125; // 寻找剩下的字符 if (i &lt;= max) &#123; int j = i + 1; int end = j + needle.length() - 1; for (int k = 1; j &lt; end &amp;&amp; haystack.charAt(j) == needle.charAt(k); j++, k++) ; // 找到完整的字符串 if (j == end) return i; &#125; &#125; return -1;&#125; jdk8的String的indexOf源码12345678910111213141516171819202122232425262728293031323334353637static int indexOf(char[] source, int sourceOffset, int sourceCount, char[] target, int targetOffset, int targetCount, int fromIndex) &#123; if (fromIndex &gt;= sourceCount) &#123; return (targetCount == 0 ? sourceCount : -1); &#125; if (fromIndex &lt; 0) &#123; fromIndex = 0; &#125; if (targetCount == 0) &#123; return fromIndex; &#125; char first = target[targetOffset]; int max = sourceOffset + (sourceCount - targetCount); for (int i = sourceOffset + fromIndex; i &lt;= max; i++) &#123; /* Look for first character. */ if (source[i] != first) &#123; while (++i &lt;= max &amp;&amp; source[i] != first); &#125; /* Found first character, now look at the rest of v2 */ if (i &lt;= max) &#123; int j = i + 1; int end = j + targetCount - 1; for (int k = targetOffset + 1; j &lt; end &amp;&amp; source[j] == target[k]; j++, k++); if (j == end) &#123; /* Found whole string. */ return i - sourceOffset; &#125; &#125; &#125; return -1;&#125;","categories":[{"name":"LeetCode算法之旅","slug":"LeetCode算法之旅","permalink":"https://lierabbit.cn/categories/LeetCode算法之旅/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"移除元素（Remove Element）","slug":"移除元素","date":"2018-09-19T03:13:42.000Z","updated":"2018-09-19T03:22:55.901Z","comments":true,"path":"2018/09/19/移除元素/","link":"","permalink":"https://lierabbit.cn/2018/09/19/移除元素/","excerpt":"","text":"题目描述给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 示例 1: 给定 nums = [3,2,2,3], val = 3,函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。 示例 2: 给定 nums = [0,1,2,2,3,0,4,2], val = 2,函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。 说明:为什么返回数值是整数，但输出的答案是数组呢?请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。你可以想象内部操作如下:12345678// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝int len = removeElement(nums, val);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i &lt; len; i++) &#123; print(nums[i]);&#125; 解决方法使用2个索引len，i，其中len用来复制，i用来检查是否移除元素当nums[i] != val时，说明这时不需要移除元素，将其复制到nums[len]12345678910111213public int removeElement(int[] nums, int val) &#123; if (nums == null || nums.length == 0) return 0; int len = 0; for (int i = 0; i &lt; nums.length; i++) &#123; if (nums[i] != val) nums[len++] = nums[i]; &#125; return len;&#125;","categories":[{"name":"LeetCode算法之旅","slug":"LeetCode算法之旅","permalink":"https://lierabbit.cn/categories/LeetCode算法之旅/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"删除排序数组中的重复项（Remove Duplicates from Sorted Array）","slug":"删除排序数组中的重复项","date":"2018-09-18T03:27:41.000Z","updated":"2018-09-19T03:19:10.000Z","comments":true,"path":"2018/09/18/删除排序数组中的重复项/","link":"","permalink":"https://lierabbit.cn/2018/09/18/删除排序数组中的重复项/","excerpt":"","text":"题目描述给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 示例 1: 给定数组 nums = [1,1,2],函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。你不需要考虑数组中超出新长度后面的元素。 示例 2: 给定 nums = [0,0,1,1,1,2,2,3,3,4],函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。你不需要考虑数组中超出新长度后面的元素。 说明:为什么返回数值是整数，但输出的答案是数组呢?请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。你可以想象内部操作如下:12345678// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝int len = removeDuplicates(nums);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i &lt; len; i++) &#123; print(nums[i]);&#125; 解决方法由于数组已经排序我们可以使用2个索引len，i进行去重，其中len用来复制，i用来检查是否重复。当nums[i-1] != nums[i]时，说明这时不重复，将其复制到nums[len]。1234567891011121314public int removeDuplicates(int[] nums) &#123; if (nums == null || nums.length == 0) return 0; int len = 1; for (int i = 1; i &lt; nums.length; i++) &#123; if (nums[i - 1] != nums[i]) nums[len++] = nums[i]; &#125; return len;&#125;","categories":[{"name":"LeetCode算法之旅","slug":"LeetCode算法之旅","permalink":"https://lierabbit.cn/categories/LeetCode算法之旅/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"k个一组翻转链表（Reverse Nodes in k-Group）","slug":"k个一组翻转链表","date":"2018-09-17T07:09:11.000Z","updated":"2018-09-17T07:35:54.182Z","comments":true,"path":"2018/09/17/k个一组翻转链表/","link":"","permalink":"https://lierabbit.cn/2018/09/17/k个一组翻转链表/","excerpt":"","text":"题目描述给出一个链表，每 k 个节点一组进行翻转，并返回翻转后的链表。 k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么将最后剩余节点保持原有顺序。 示例 : 给定这个链表：1-&gt;2-&gt;3-&gt;4-&gt;5 当 k = 2 时，应当返回: 2-&gt;1-&gt;4-&gt;3-&gt;5 当 k = 3 时，应当返回: 3-&gt;2-&gt;1-&gt;4-&gt;5 说明 : 你的算法只能使用常数的额外空间。 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 ListNode结构12345678class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125;&#125; 解决方法使用4个指针反转链表 start下一次循环的开始节点 kStep提前走k步 cur当前要移动的节点 pre固定的开始节点 例如:list = 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5, k = 3 1234567891011121314151617181920首先使用虚拟头节点简化操作dummy -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5第一次反转链表过程如下dummy -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 pre cur kStep startdummy -&gt; 2 -&gt; 3 -&gt; 1 -&gt; 4 -&gt; 5 pre cur kStep startdummy -&gt; 3 -&gt; 2 -&gt; 1 -&gt; 4 -&gt; 5 pre cur start kStep第二次反转遍历过程如下dummy -&gt; 3 -&gt; 2 -&gt; 1 -&gt; 4 -&gt; 5 -&gt; null pre start kStepkStep为null退出循环 123456789101112131415161718192021public ListNode reverseKGroup(ListNode head, int k) &#123; ListNode dummy = new ListNode(0); dummy.next = head; ListNode start = dummy; while (true) &#123; ListNode kStep = start, pre = start, cur; start = pre.next; for (int i = 0; i &lt; k &amp;&amp; kStep != null; i++) kStep = kStep.next; if (kStep == null) break; for (int i = 0; i &lt; k - 1; i++) &#123; cur = pre.next; pre.next = cur.next; cur.next = kStep.next; kStep.next = cur; &#125; &#125; return dummy.next;&#125;","categories":[{"name":"LeetCode算法之旅","slug":"LeetCode算法之旅","permalink":"https://lierabbit.cn/categories/LeetCode算法之旅/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"两两交换链表中的节点（Swap Nodes in Pairs）","slug":"两两交换链表中的节点","date":"2018-09-09T06:27:36.000Z","updated":"2018-09-17T07:54:46.130Z","comments":true,"path":"2018/09/09/两两交换链表中的节点/","link":"","permalink":"https://lierabbit.cn/2018/09/09/两两交换链表中的节点/","excerpt":"","text":"题目描述给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。 示例: 给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3. 说明: 你的算法只能使用常数的额外空间。 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 ListNode数据结构12345678class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125;&#125; 解决方法使用3个指针进行两两交换，分别是前指针（pre）,当前指针（cur）,后指针（next）pre的作用是在cur与next交换后进行连接，防止断链123456789101112131415161718192021public ListNode swapPairs(ListNode head) &#123; if (head == null || head.next == null) return head; ListNode tempHead = new ListNode(0); tempHead.next = head; ListNode pre = tempHead; ListNode cur = pre.next; ListNode next; while (cur != null &amp;&amp; cur.next != null) &#123; next = cur.next; cur.next = next.next; next.next = cur; pre.next = next; pre = cur; cur = pre.next; &#125; return tempHead.next;&#125;","categories":[{"name":"LeetCode算法之旅","slug":"LeetCode算法之旅","permalink":"https://lierabbit.cn/categories/LeetCode算法之旅/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"合并K个排序链表（Merge k Sorted Lists）","slug":"合并K个排序链表","date":"2018-09-05T14:20:30.000Z","updated":"2018-09-17T07:54:46.134Z","comments":true,"path":"2018/09/05/合并K个排序链表/","link":"","permalink":"https://lierabbit.cn/2018/09/05/合并K个排序链表/","excerpt":"","text":"题目描述合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。 示例: 输入:[ 1-&gt;4-&gt;5, 1-&gt;3-&gt;4, 2-&gt;6]输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6 ListNode数据结构12345678class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125;&#125; 解决方法相邻链表两两合并，两两合并详情见合并两个有序链表1234567891011121314151617181920212223242526public ListNode mergeKLists(ListNode[] lists) &#123; int interval = 1; while (interval &lt; lists.length) &#123; for (int i = 0; i &lt; lists.length - interval; i += interval * 2) &#123; lists[i] = merge2Lists(lists[i], lists[i + interval]); &#125; interval *= 2; &#125; return lists.length &gt; 0 ? lists[0] : null;&#125;public ListNode merge2Lists(ListNode l1, ListNode l2) &#123; if (l1 == null) return l2; if (l2 == null) return l1; if (l1.val &lt; l2.val) &#123; l1.next = merge2Lists(l1.next, l2); return l1; &#125; else &#123; l2.next = merge2Lists(l1, l2.next); return l2; &#125;&#125; 时间复杂度： O(Nlogk)，k是链表的数目","categories":[{"name":"LeetCode算法之旅","slug":"LeetCode算法之旅","permalink":"https://lierabbit.cn/categories/LeetCode算法之旅/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"括号生成（Generate Parentheses）","slug":"括号生成","date":"2018-09-04T02:41:25.000Z","updated":"2018-09-17T07:54:46.136Z","comments":true,"path":"2018/09/04/括号生成/","link":"","permalink":"https://lierabbit.cn/2018/09/04/括号生成/","excerpt":"","text":"题目描述给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。 例如，给出 n = 3，生成结果为： [ “((()))”, “(()())”, “(())()”, “()(())”, “()()()”] 解决方法合法的括号： 左括号在对应右括号的左边 -&gt; 先添加左括号再添加右括号即可保证左括号在右括号的左边 相同数量的左右括号 -&gt; 右括号数量 == 左括号数量 最终形成的字符串长度为n*2，也就是左右括号各n个 根据以上分析使用回溯法 12345678910111213141516171819202122232425public List&lt;String&gt; generateParenthesis(int n) &#123; List&lt;String&gt; res = new ArrayList&lt;&gt;(); process(res, \"\", 0, 0, n); return res;&#125;/** * @param res 结果 * @param str 结果中的一项 * @param open 左括号数量 * @param close 右括号数量 * @param n 生成的括号对数 */public void process(List&lt;String&gt; res, String str, int open, int close, int n) &#123; if (str.length() == n * 2) &#123; res.add(str); &#125; else &#123; if (open &lt; n) process(res, str + \"(\", open + 1, close, n); if (close &lt; open) process(res, str + \")\", open, close + 1, n); &#125;&#125;","categories":[{"name":"LeetCode算法之旅","slug":"LeetCode算法之旅","permalink":"https://lierabbit.cn/categories/LeetCode算法之旅/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"合并两个有序链表（Merge Two Sorted Lists）","slug":"合并两个有序链表","date":"2018-09-03T08:46:54.000Z","updated":"2018-09-17T07:54:46.134Z","comments":true,"path":"2018/09/03/合并两个有序链表/","link":"","permalink":"https://lierabbit.cn/2018/09/03/合并两个有序链表/","excerpt":"","text":"题目描述将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例：输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 解决方法先比较头节点，然后递归比较剩下的节点，最后将其连接起来 1234567891011121314public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if (l1 == null) return l2; if (l2 == null) return l1; if (l1.val &lt; l2.val) &#123; l1.next = mergeTwoLists(l1.next, l2); return l1; &#125; else &#123; l2.next = mergeTwoLists(l1, l2.next); return l2; &#125;&#125;","categories":[{"name":"LeetCode算法之旅","slug":"LeetCode算法之旅","permalink":"https://lierabbit.cn/categories/LeetCode算法之旅/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"仿segmentfault-table横向滚动","slug":"仿segmentfault-table横向滚动","date":"2018-09-02T08:37:47.000Z","updated":"2018-09-02T09:56:24.393Z","comments":true,"path":"2018/09/02/仿segmentfault-table横向滚动/","link":"","permalink":"https://lierabbit.cn/2018/09/02/仿segmentfault-table横向滚动/","excerpt":"","text":"问题描述自己的博客在用移动端访问时，如果table的列数足够多会显示不全，如下图红圈所示 正常情况如图 解决过程使用chrome发现segmentfault的解决方法是在table上套一个table-wrap，如下图蓝色背景和红圈所示 首先想到直接在table上套一个table-wrap即可接着查看别的table时发现并不是每一个table都被套上一个table-wrap，如下图所示，也就是说只有显示不全的table才会套上table-wrap table什么情况是显示不全？那就是table的宽度 &gt; 文章的宽度 通过以上分析可以得出简单的步骤： 获取文章的宽度(articleWidth) 获取所有的table 找出比articleWidth宽的table 使其被.table-wrap包囊 12345678let articleWidth = document.getElementById('文章').clientWidth;let tables = $('table');tables.each((index, table) =&gt; &#123; if (table.clientWidth &gt; articleWidth) &#123; table.outerHTML = \"&lt;div class='table-wrap'&gt;\" + table.outerHTML + \"&lt;/div&gt;\"; &#125;&#125;); 别忘了补上css123.table-wrap&#123; overflow-x: scroll;&#125; 其实不用判断table的宽度 &gt; 文章的宽度也能实现，让每一个table都套上.table-wrap，使用如下css123.table-wrap&#123; overflow-x: auto;&#125; 这样的话只是会在html上多一点&lt;div class=&quot;table-wrap&quot;&gt;&lt;/div&gt;而已，并且当页面大小发生变化也会根据需要是否出现滚动条 实际效果用移动端或者chrome模拟移动端看https://lierabbit.cn/2018/05/08/最长回文子串","categories":[],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://lierabbit.cn/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://lierabbit.cn/tags/CSS/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://lierabbit.cn/tags/JavaScript/"}]},{"title":"有效的括号（Valid Parentheses）","slug":"有效的括号","date":"2018-09-01T12:16:02.000Z","updated":"2018-09-17T07:54:46.138Z","comments":true,"path":"2018/09/01/有效的括号/","link":"","permalink":"https://lierabbit.cn/2018/09/01/有效的括号/","excerpt":"","text":"题目描述给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 注意空字符串可被认为是有效字符串。 示例 1:输入: “()”输出: true 示例 2:输入: “()[]{}”输出: true 示例 3:输入: “(]”输出: false 示例 4:输入: “([)]”输出: false 示例 5:输入: “{[]}”输出: true 解决方法合法的括号特征：当右括号出现，则紧靠其左边必有对应的左括号具体做法： 利用一个栈记录遍历到的左括号对应的右括号 当右括号出现，若栈顶与右括号一致则合法，反之不合法 1234567891011121314151617public boolean isValid(String s) &#123; Stack&lt;Character&gt; stack = new Stack&lt;&gt;(); for (int i = 0, len = s.length(); i &lt; len; i++) &#123; char ch = s.charAt(i); if (ch == '(') stack.add(')'); else if (ch == '&#123;') stack.add('&#125;'); else if (ch == '[') stack.add(']'); else if (stack.isEmpty() || stack.pop() != ch) return false; &#125; return stack.isEmpty();&#125;","categories":[{"name":"LeetCode算法之旅","slug":"LeetCode算法之旅","permalink":"https://lierabbit.cn/categories/LeetCode算法之旅/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"删除链表的倒数第N个节点（Remove Nth Node From End of List）","slug":"删除链表的倒数第N个节点","date":"2018-08-31T02:37:17.000Z","updated":"2018-09-17T07:54:46.133Z","comments":true,"path":"2018/08/31/删除链表的倒数第N个节点/","link":"","permalink":"https://lierabbit.cn/2018/08/31/删除链表的倒数第N个节点/","excerpt":"","text":"题目描述给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。 示例： 给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.说明：给定的 n 保证是有效的。 进阶：你能尝试使用一趟扫描实现吗 ListNode数据结构12345678class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125;&#125; 解决方法如何一趟遍历获取倒数第n个节点？使用2个指针first,second，first在前，second在后，保持间隔n走到链尾，这样second就是倒数第n个节点 如何删除当前节点操作？前一个节点.next = 前一个节点.next.next 由于头节点没有前一个节点了，如何删除头节点？在头节点前面加入临时头节点，这样原头节点就和普通节点一致 解决了上述3个问题可得出以下代码 12345678910111213141516171819public ListNode removeNthFromEnd(ListNode head, int n) &#123; // 为了方便操作建立临时头节点 ListNode tempHead = new ListNode(0); tempHead.next = head; ListNode first = tempHead; ListNode second = tempHead; // 让first先走n+1步 for (int i = 1; i &lt;= n + 1; i++) &#123; first = first.next; &#125; // 两个指针一起走，当first走到链尾，second就走到倒数第n+1个节点 while (first != null) &#123; first = first.next; second = second.next; &#125; // 删除下一个节点即删除倒数第n个节点 second.next = second.next.next; return tempHead.next;&#125;","categories":[{"name":"LeetCode算法之旅","slug":"LeetCode算法之旅","permalink":"https://lierabbit.cn/categories/LeetCode算法之旅/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"四数之和（4Sum）","slug":"四数之和","date":"2018-08-30T06:33:15.000Z","updated":"2018-09-17T07:54:46.134Z","comments":true,"path":"2018/08/30/四数之和/","link":"","permalink":"https://lierabbit.cn/2018/08/30/四数之和/","excerpt":"","text":"题目描述给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。注意：答案中不可以包含重复的四元组。示例： 给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。满足要求的四元组集合为：[ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]] 解决方法通过观察之前的两数之和，三数之和发现所有的K数之和问题都可以转变成两数之和问题： 将K数之和问题转化为K-1数之和问题 重复1直到k==2 两数之和利用夹逼算法解决 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123; Arrays.sort(nums); return kSum(nums, 0, 4, target);&#125;private List&lt;List&lt;Integer&gt;&gt; kSum(int[] nums, int start, int k, int target) &#123; int len = nums.length; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); if (k == 2) &#123; int left = start, right = len - 1; while (left &lt; right) &#123; int sum = nums[left] + nums[right]; if (sum == target) &#123; List&lt;Integer&gt; temp = new LinkedList&lt;&gt;(); temp.add(nums[left]); temp.add(nums[right]); res.add(temp); // 跳过左边重复数字 while (left &lt; right &amp;&amp; nums[left] == nums[left + 1]) left++; // 跳过右边重复数字 while (left &lt; right &amp;&amp; nums[right] == nums[right - 1]) right--; left++; right--; &#125; else if (sum &lt; target) left++; else right--; &#125; &#125; else &#123; for (int i = start, end = len - (k - 1); i &lt; end; i++) &#123; // 跳过重复数字 if (i &gt; start &amp;&amp; nums[i] == nums[i - 1]) continue; // 将K数之和转换成K-1数之和 List&lt;List&lt;Integer&gt;&gt; temp = kSum(nums, i + 1, k - 1, target - nums[i]); for (List&lt;Integer&gt; item : temp) item.add(0, nums[i]); res.addAll(temp); &#125; &#125; return res;&#125; 时间复杂度：O(Nk-1)，在本题中k=4，即O(N3)","categories":[{"name":"LeetCode算法之旅","slug":"LeetCode算法之旅","permalink":"https://lierabbit.cn/categories/LeetCode算法之旅/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"电话号码的字母组合（Letter Combinations of a Phone Number）","slug":"电话号码的字母组合","date":"2018-08-29T03:01:19.000Z","updated":"2018-09-17T07:54:46.139Z","comments":true,"path":"2018/08/29/电话号码的字母组合/","link":"","permalink":"https://lierabbit.cn/2018/08/29/电话号码的字母组合/","excerpt":"","text":"题目描述给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。 示例: 输入：”23”输出：[“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”]. 说明:尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。 解决方法利用队列先进先出的性质进行横向组合。例如输入“23” 首先取出输入中的第一个数2，它所代表的字母为a,b,c，依次放入队列， 接着取出输入中的下一个数3，它所代表的字母为d,e,f。 队列依次出队与d,e,f进行组合 过程如下123456789101112&quot;&quot; + a = a&quot;&quot; + b = b&quot;&quot; + c = ca + d = ada + e = aea + f = afb + d = bdb + e = beb + f = bfc + d = cdc + e = cec + f = cf 如果输入的是“234”，重复2，3步骤即可 现在还剩2个问题：何时退出这个循环？通过观察可知，输入字符串的长度 == 组合后子项的长度也就是说队列里的所有字符串长度 == 输入的字符串长度时组合完成如何取得输入中的下一个数？既然输入字符串的长度 == 组合后子项的长度，那么通过队列里的字符长度获取输入中的下一个数即可 123456789101112131415161718public List&lt;String&gt; letterCombinations(String digits) &#123; LinkedList&lt;String&gt; res = new LinkedList&lt;&gt;(); // 使用数组模拟按键映射，这里可以换成HashMap String[] map = new String[]&#123;\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"&#125;; if (digits.isEmpty()) return res; res.add(\"\"); while (res.peek().length() != digits.length()) &#123; String temp = res.pop(); String value = map[digits.charAt(temp.length()) - '0']; for (char c : value.toCharArray()) res.add(temp + c); &#125; return res;&#125;","categories":[{"name":"LeetCode算法之旅","slug":"LeetCode算法之旅","permalink":"https://lierabbit.cn/categories/LeetCode算法之旅/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"最接近的三数之和（3Sum Closest）","slug":"最接近的三数之和","date":"2018-05-23T07:52:05.000Z","updated":"2018-09-17T07:54:46.137Z","comments":true,"path":"2018/05/23/最接近的三数之和/","link":"","permalink":"https://lierabbit.cn/2018/05/23/最接近的三数之和/","excerpt":"","text":"题目描述给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。 例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2). 解决方法确定第一个数，然后通过夹逼算法寻找接近target的数 1234567891011121314151617181920212223public int threeSumClosest(int[] nums, int target) &#123; int res = nums[0] + nums[1] + nums[2]; Arrays.sort(nums); for (int i = 0; i &lt; nums.length - 2; i++) &#123; int lo = i + 1, hi = nums.length - 1; while (lo &lt; hi) &#123; int sum = nums[i] + nums[lo] + nums[hi]; if (sum &lt; target) lo++; else if (sum &gt; target) hi--; else return target; if (Math.abs(target - sum) &lt; Math.abs(target - res)) res = sum; &#125; &#125; return res;&#125; 时间复杂度：O(N2)","categories":[{"name":"LeetCode算法之旅","slug":"LeetCode算法之旅","permalink":"https://lierabbit.cn/categories/LeetCode算法之旅/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"三数之和（3Sum）","slug":"三数之和","date":"2018-05-23T07:21:13.000Z","updated":"2018-09-17T07:54:46.130Z","comments":true,"path":"2018/05/23/三数之和/","link":"","permalink":"https://lierabbit.cn/2018/05/23/三数之和/","excerpt":"","text":"题目描述给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为：1234[ [-1, 0, 1], [-1, -1, 2]] 解决方法先确定一个数，则另外两数之和等于该数的相反数，通过夹逼算法寻找两数之和 123456789101112131415161718192021222324252627public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); Arrays.sort(nums); for (int i = 0; i &lt; nums.length - 2; i++) &#123; // 跳过前后一样的数字 if (i == 0 || nums[i] != nums[i - 1]) &#123; int lo = i + 1, hi = nums.length - 1, sum = -nums[i]; while (lo &lt; hi) &#123; if (nums[lo] + nums[hi] == sum) &#123; res.add(Arrays.asList(nums[i], nums[lo], nums[hi])); // 跳过前后一样的数字 while (lo &lt; hi &amp;&amp; nums[lo] == nums[lo + 1]) lo++; while (lo &lt; hi &amp;&amp; nums[hi] == nums[hi - 1]) hi--; lo++; hi--; &#125; else if (nums[lo] + nums[hi] &lt; sum) lo++; else hi--; &#125; &#125; &#125; return res;&#125; 时间复杂度：O(N2)","categories":[{"name":"LeetCode算法之旅","slug":"LeetCode算法之旅","permalink":"https://lierabbit.cn/categories/LeetCode算法之旅/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"最长公共前缀（Longest Common Prefix）","slug":"最长公共前缀","date":"2018-05-21T06:48:08.000Z","updated":"2018-09-25T04:16:08.001Z","comments":true,"path":"2018/05/21/最长公共前缀/","link":"","permalink":"https://lierabbit.cn/2018/05/21/最长公共前缀/","excerpt":"","text":"题目描述编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 “”。 示例 1:输入: [“flower”,”flow”,”flight”]输出: “fl” 示例 2:输入: [“dog”,”racecar”,”car”]输出: “”解释: 输入不存在公共前缀。 说明:所有输入只包含小写字母 a-z 。 解决方法横向匹配所有字符串取出字符串数组里任意一个字符串prefix，遍历其余的字符串判断prefix是否是其的前缀，不是就去掉prefix最后一个字符，直到prefix为空 123456789101112131415public String longestCommonPrefix(String[] strs) &#123; if (strs == null || strs.length == 0) return \"\"; String prefix = strs[0]; for (int i = 1; i &lt; strs.length; i++) &#123; while (strs[i].indexOf(prefix) != 0) &#123; prefix = prefix.substring(0, prefix.length() - 1); if (prefix.isEmpty()) return \"\"; &#125; &#125; return prefix;&#125; 时间复杂度：O(S)，其中S是所有字符串中所有字符的总和空间复杂度：O(1)，只使用了恒定的额外空间 二分搜索 取最短的字符串的长度minLen作为右边界right，因为最长公共前缀的长度不可能大于字符串数组里最短字符串的长度 判断左半部分是否是公共前缀，是的话向右寻找更长的公共前缀，反之向左寻找公共前缀 当 左边界left &gt; 右边界right 寻找结束，最长公共前缀范围就是[0, (left + right) / 2) 1234567891011121314151617181920212223242526272829public String longestCommonPrefix2(String[] strs) &#123; if (strs == null || strs.length == 0) return \"\"; int minLen = Integer.MAX_VALUE; for (String str : strs) minLen = Math.min(minLen, str.length()); int left = 1, right = minLen; while (left &lt;= right) &#123; int middle = (left + right) / 2; if (isCommonPrefix(strs, middle)) left = middle + 1; else right = middle - 1; &#125; return strs[0].substring(0, (left + right) / 2);&#125;public boolean isCommonPrefix(String[] strs, int len) &#123; String str1 = strs[0].substring(0, len); for (int i = 1; i &lt; strs.length; i++) &#123; if (!strs[i].startsWith(str1)) return false; &#125; return true;&#125; 时间复杂度：O(S*log(n))，其中S是所有字符串中所有字符的总和。空间复杂度：O(1)。我们只使用了恒定的额外空间。","categories":[{"name":"LeetCode算法之旅","slug":"LeetCode算法之旅","permalink":"https://lierabbit.cn/categories/LeetCode算法之旅/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"罗马数字转整数（Roman to Integer）","slug":"罗马数字转整数","date":"2018-05-14T13:44:33.000Z","updated":"2018-09-19T03:21:07.136Z","comments":true,"path":"2018/05/14/罗马数字转整数/","link":"","permalink":"https://lierabbit.cn/2018/05/14/罗马数字转整数/","excerpt":"","text":"题目描述123456789罗马数字包含以下七种字符：I， V， X， L，C，D 和 M。字符 数值I 1V 5X 10L 50C 100D 500M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。 示例 1:输入: “III”输出: 3 示例 2:输入: “IV”输出: 4 示例 3:输入: “IX”输出: 9 示例 4:输入: “LVIII”输出: 58解释: C = 100, L = 50, XXX = 30, III = 3. 示例 5:输入: “MCMXCIV”输出: 1994解释: M = 1000, CM = 900, XC = 90, IV = 4. 解决方法如果当前字符代表的数字小于下一个字符代表的数字，则做减法，反之加法 12345678910111213141516171819202122public int romanToInt(String s) &#123; HashMap&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); map.put('I', 1); map.put('V', 5); map.put('X', 10); map.put('L', 50); map.put('C', 100); map.put('D', 500); map.put('M', 1000); int sum = 0; for (int i = 0; i &lt; s.length() - 1; i++) &#123; if (map.get(s.charAt(i)) &lt; map.get(s.charAt(i + 1))) sum -= map.get(s.charAt(i)); else sum += map.get(s.charAt(i)); &#125; sum += map.get(s.charAt(s.length() - 1)); return sum;&#125; 时间复杂度：O(s)，s为字符串的长度空间复杂度：O(1)","categories":[{"name":"LeetCode算法之旅","slug":"LeetCode算法之旅","permalink":"https://lierabbit.cn/categories/LeetCode算法之旅/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"整数转罗马数字（Integer to Roman）","slug":"整数转罗马数字","date":"2018-05-14T08:39:40.000Z","updated":"2018-09-17T07:54:46.136Z","comments":true,"path":"2018/05/14/整数转罗马数字/","link":"","permalink":"https://lierabbit.cn/2018/05/14/整数转罗马数字/","excerpt":"","text":"题目描述123456789罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。字符 数值I 1V 5X 10L 50C 100D 500M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。 示例 1:输入: 3输出: “III” 示例 2:输入: 4输出: “IV” 示例 3:输入: 9输出: “IX” 示例 4:输入: 58输出: “LVIII”解释: C = 100, L = 50, XXX = 30, III = 3. 示例 5:输入: 1994输出: “MCMXCIV”解释: M = 1000, CM = 900, XC = 90, IV = 4. 解决方法直接储存各个数位上的字符，再根据数字取出对应的字符🙃 12345678public String intToRoman(int num) &#123; String M[] = &#123;\"\", \"M\", \"MM\", \"MMM\"&#125;; String C[] = &#123;\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"&#125;; String X[] = &#123;\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"&#125;; String I[] = &#123;\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"&#125;; return M[num / 1000] + C[num % 1000 / 100] + X[num % 100 / 10] + I[num % 10];&#125; 时间复杂度：O(1)空间复杂度：O(1)","categories":[{"name":"LeetCode算法之旅","slug":"LeetCode算法之旅","permalink":"https://lierabbit.cn/categories/LeetCode算法之旅/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"盛最多水的容器（Container With Most Water）","slug":"盛最多水的容器","date":"2018-05-14T08:06:24.000Z","updated":"2018-09-17T07:54:46.139Z","comments":true,"path":"2018/05/14/盛最多水的容器/","link":"","permalink":"https://lierabbit.cn/2018/05/14/盛最多水的容器/","excerpt":"","text":"题目描述给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。画 n 条垂直线，使得垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 解决方法从头和尾开始找起，一开始就获得了最大宽度，由于面积是取较小的高度，所以移动高度较小的索引以期待能获得更高的高度。 12345678910111213public int maxArea(int[] height) &#123; int l = 0, r = height.length - 1, max = 0; while (l &lt; r) &#123; max = Math.max(max, (r - l) * Math.min(height[l], height[r])); if (height[l] &lt; height[r]) l++; else r--; &#125; return max;&#125; 时间复杂度：O(n)空间复杂度：O(1)","categories":[{"name":"LeetCode算法之旅","slug":"LeetCode算法之旅","permalink":"https://lierabbit.cn/categories/LeetCode算法之旅/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"正则表达式匹配（Regular Expression Matching）","slug":"正则表达式匹配-1","date":"2018-05-14T07:19:01.000Z","updated":"2018-09-17T07:54:46.139Z","comments":true,"path":"2018/05/14/正则表达式匹配-1/","link":"","permalink":"https://lierabbit.cn/2018/05/14/正则表达式匹配-1/","excerpt":"","text":"题目描述给定一个字符串 (s) 和一个字符模式 (p)。实现支持 ‘.’ 和 ‘*‘ 的正则表达式匹配。‘.’ 匹配任意单个字符。‘*‘ 匹配零个或多个前面的元素。匹配应该覆盖整个字符串 (s) ，而不是部分字符串。 说明:s 可能为空，且只包含从 a-z 的小写字母。p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。 示例 1:输入:s = “aa”p = “a”输出: false解释: “a” 无法匹配 “aa” 整个字符串。 示例 2:输入:s = “aa”p = “a*“输出: true解释: ‘*‘ 代表可匹配零个或多个前面的元素, 即可以匹配 ‘a’ 。因此, 重复 ‘a’ 一次, 字符串可变为 “aa”。 示例 3:输入:s = “ab”p = “.*“输出: true解释: “.*“ 表示可匹配零个或多个(‘*‘)任意字符(‘.’)。 示例 4:输入:s = “aab”p = “c*a*b”输出: true解释: ‘c’ 可以不被重复, ‘a’ 可以被重复一次。因此可以匹配字符串 “aab”。 示例 5:输入:s = “mississippi”p = “mis*is*p*.”输出: false 解决方法方法一当模式中的第二个字符是“*”时：如果字符串第一个字符跟模式第一个字符不匹配，则模式后移2个字符，继续匹配。如果字符串第一个字符跟模式第一个字符匹配，可以有2种匹配方式： 模式后移2字符，相当于x*被忽略 字符串后移1字符，模式不变，即继续匹配字符下一位，因为*可以匹配多位当模式中的第二个字符不是“*”时： 如果字符串第一个字符和模式中的第一个字符相匹配，那么字符串和模式都后移一个字符，然后匹配剩余的 如果字符串第一个字符和模式中的第一个字符相不匹配，直接返回false 这里需要注意的是：要时刻检验数组是否越界 1234567891011121314151617181920212223242526272829public boolean isMatch(String s, String p) &#123; if (s == null || p == null) return false; return isMatchCore(s, 0, p, 0);&#125;public boolean isMatchCore(String s, int sIndex, String p, int pIndex) &#123; // 有效性检验：str到尾，pattern到尾，匹配成功 if (s.length() == sIndex &amp;&amp; p.length() == pIndex) return true; // pattern先到尾，匹配失败 if (p.length() == pIndex) return false; // 模式后一个字符是*，且字符串第1个跟模式第1个匹配,分2种匹配模式。如不匹配，模式后移2位 if (pIndex + 1 &lt; p.length() &amp;&amp; p.charAt(pIndex + 1) == '*') &#123; if (sIndex &lt; s.length() &amp;&amp; (s.charAt(sIndex) == p.charAt(pIndex) || p.charAt(pIndex) == '.')) &#123; return isMatchCore(s, sIndex + 1, p, pIndex) || // x*匹配1个字符，再匹配str中的下一个 isMatchCore(s, sIndex, p, pIndex + 2); // 模式后移2位，视为x*匹配0个字符 &#125; else return isMatchCore(s, sIndex, p, pIndex + 2); &#125; else &#123; // 模式后一个字符不是*，且字符串第1个跟模式第1个匹配，则都后移1位，否则直接返回false if (sIndex &lt; s.length() &amp;&amp; (s.charAt(sIndex) == p.charAt(pIndex) || p.charAt(pIndex) == '.')) return isMatchCore(s, sIndex + 1, p, pIndex + 1); else return false; &#125;&#125; 方法二只需要注意后一个字符是否为*即可，第一个字符直接进行对比判断，当第二个字符为*时，有2种情况 0个字符匹配，模式直接往后跳2位 1个字符匹配，字符串往后跳1位没*的话直接对比匹配即可 1234567891011public boolean isMatch2(String s, String p) &#123; if (p.isEmpty()) return s.isEmpty(); boolean firstMatch = !s.isEmpty() &amp;&amp; (s.charAt(0) == p.charAt(0) || p.charAt(0) == '.'); if (p.length() &gt; 1 &amp;&amp; p.charAt(1) == '*') return isMatch2(s, p.substring(2)) || (firstMatch &amp;&amp; isMatch2(s.substring(1), p)); else return firstMatch &amp;&amp; isMatch2(s.substring(1), p.substring(1));&#125;","categories":[{"name":"LeetCode算法之旅","slug":"LeetCode算法之旅","permalink":"https://lierabbit.cn/categories/LeetCode算法之旅/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"回文数（Palindrome Number）","slug":"回文数","date":"2018-05-09T04:28:24.000Z","updated":"2018-09-17T07:54:46.135Z","comments":true,"path":"2018/05/09/回文数/","link":"","permalink":"https://lierabbit.cn/2018/05/09/回文数/","excerpt":"","text":"题目描述判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 示例 1:输入: 121输出: true 示例 2:输入: -121输出: false解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。 示例 3:输入: 10输出: false解释: 从右向左读, 为 01 。因此它不是一个回文数。 进阶: 你能不将整数转为字符串来解决这个问题吗？ 解决方法 如果是负数则不是回文数，因为只有一个’-‘ 如果个位为0则不是回文数，0除外。因为如果个位为0则首位必须为0，然而除了0之外没有首位为0的数 反转数的一半，例如x=12321，反转后x=12，reverse=123，那么x==reverse或者x==reverse/10 12345678910111213public boolean isPalindrome(int x) &#123; if (x &lt; 0 || (x % 10 == 0 &amp;&amp; x != 0)) return false; int reverse = 0; // 反转数字的一半 while (x &gt; reverse) &#123; reverse = reverse * 10 + x % 10; x /= 10; &#125; return x == reverse || reverse / 10 == x;&#125; 时间复杂度：O(log10(n))空间复杂度：O(1)","categories":[{"name":"LeetCode算法之旅","slug":"LeetCode算法之旅","permalink":"https://lierabbit.cn/categories/LeetCode算法之旅/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"字符串转整数（String to Integer (atoi)）","slug":"字符串转整数","date":"2018-05-09T03:42:42.000Z","updated":"2018-09-17T07:54:46.135Z","comments":true,"path":"2018/05/09/字符串转整数/","link":"","permalink":"https://lierabbit.cn/2018/05/09/字符串转整数/","excerpt":"","text":"题目描述实现 atoi，将字符串转为整数。在找到第一个非空字符之前，需要移除掉字符串中的空格字符。如果第一个非空字符是正号或负号，选取该符号，并将其与后面尽可能多的连续的数字组合起来，这部分字符即为整数的值。如果第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。字符串可以在形成整数的字符后面包括多余的字符，这些字符可以被忽略，它们对于函数没有影响。当字符串中的第一个非空字符序列不是个有效的整数；或字符串为空；或字符串仅包含空白字符时，则不进行转换。若函数不能执行有效的转换，返回 0。 说明：假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231, 231 − 1]。如果数值超过可表示的范围，则返回 INT_MAX (231 − 1) 或 INT_MIN (−231) 。 示例 1:输入: “42”输出: 42 示例 2:输入: “ -42”输出: -42解释: 第一个非空白字符为 ‘-‘, 它是一个负号。我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。 示例 3:输入: “4193 with words”输出: 4193解释: 转换截止于数字 ‘3’ ，因为它的下一个字符不为数字。 示例 4:输入: “words and 987”输出: 0解释: 第一个非空字符是 ‘w’, 但它不是数字或正、负号。因此无法执行有效的转换。 示例 5:输入: “-91283472332”输出: -2147483648解释: 数字 “-91283472332” 超过 32 位有符号整数范围。 因此返回 INT_MIN (−231) 。 解决方法只需要注意4个地方 字符串前面的空格 符号位 只要连续的数字 溢出判断 12345678910111213141516171819202122232425public int myAtoi(String str) &#123; if (str == null || str.length() == 0) return 0; int index = 0, base = 0, sign = 1, len = str.length(); // 跳过空格 while (index &lt; len &amp;&amp; str.charAt(index) == ' ') index++; // 获取符号位 if (index &lt; len &amp;&amp; (str.charAt(index) == '+' || str.charAt(index) == '-')) sign = 1 - 2 * ((str.charAt(index++) == '-') ? 1 : 0); // 只取数字，碰到非数字退出循环 while (index &lt; len &amp;&amp; str.charAt(index) &gt;= '0' &amp;&amp; str.charAt(index) &lt;= '9') &#123; // 溢出判断，MAX_VALUE的个位为7 if (base &gt; Integer.MAX_VALUE / 10 || (base == Integer.MAX_VALUE / 10 &amp;&amp; str.charAt(index) - '0' &gt; 7)) if (sign == 1) return Integer.MAX_VALUE; else return Integer.MIN_VALUE; base = base * 10 + str.charAt(index++) - '0'; &#125; return sign * base;&#125;","categories":[{"name":"LeetCode算法之旅","slug":"LeetCode算法之旅","permalink":"https://lierabbit.cn/categories/LeetCode算法之旅/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"反转整数（Reverse Integer）","slug":"反转整数","date":"2018-05-09T02:52:29.000Z","updated":"2018-09-17T07:54:46.133Z","comments":true,"path":"2018/05/09/反转整数/","link":"","permalink":"https://lierabbit.cn/2018/05/09/反转整数/","excerpt":"","text":"题目描述给定一个 32 位有符号整数，将整数中的数字进行反转。 示例 1:输入: 123输出: 321 示例 2:输入: -123输出: -321 示例 3:输入: 120输出: 21 注意：假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231, 231 − 1]。根据这个假设，如果反转后的整数溢出，则返回 0。 解决方法123 -&gt; 321的过程 res = 0 获取个位g res = res * 10 + g 原值 /= 10 重复2 3步骤直到原值为0 反转的算法有了，还差个溢出判断。a为原值，d为新值，c为个位，如果不溢出的话可以通过a*10+c=d，a=(d-c)/10互相转换根据上述可得以下代码 1234567891011121314public int reverse(int x) &#123; int res = 0; while (x != 0) &#123; int remainder = x % 10; int newRes = res * 10 + remainder; if ((newRes - remainder) / 10 != res) // 如果有溢出则无法回退到原来的结果 return 0; res = newRes; x /= 10; &#125; return res;&#125; 时间复杂度：O(log(x))，x为要反转的数字空间复杂度：O(1)","categories":[{"name":"LeetCode算法之旅","slug":"LeetCode算法之旅","permalink":"https://lierabbit.cn/categories/LeetCode算法之旅/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"Z字形变换（ZigZag Conversion）","slug":"Z字形变换","date":"2018-05-09T02:17:52.000Z","updated":"2018-09-17T07:54:46.129Z","comments":true,"path":"2018/05/09/Z字形变换/","link":"","permalink":"https://lierabbit.cn/2018/05/09/Z字形变换/","excerpt":"","text":"题目描述将字符串 “PAYPALISHIRING” 以Z字形排列成给定的行数：123P A H NA P L S I I GY I R 之后从左往右，逐行读取字符：”PAHNAPLSIIGYIR”实现一个将字符串进行指定行数变换的函数:string convert(string s, int numRows); 示例 1:输入: s = “PAYPALISHIRING”, numRows = 3输出: “PAHNAPLSIIGYIR” 示例 2:输入: s = “PAYPALISHIRING”, numRows = 4输出: “PINALSIGYAHRPI”解释:1234P I NA L S I GY A H RP I 解决方法观察示例可知，往下走要走numRows步，往上走要走numRows-2步（除去头尾，因为和往下走重叠）模拟Z字遍历字符串 往下走numRows步 往上走numRows-2步 重复1，2直到字符串遍历结束 123456789101112131415161718192021public String convert(String s, int numRows) &#123; if (numRows &lt; 2) return s; StringBuilder[] sbs = new StringBuilder[numRows]; for (int i = 0; i &lt; numRows; i++) sbs[i] = new StringBuilder(); int index = 0, len = s.length(); while (index &lt; len) &#123; for (int row = 0; row &lt; numRows &amp;&amp; index &lt; len; row++) // 往下走 sbs[row].append(s.charAt(index++)); for (int row = numRows - 2; row &gt; 0 &amp;&amp; index &lt; len; row--) // 往上走 sbs[row].append(s.charAt(index++)); &#125; for (int row = 1; row &lt; numRows; row++) sbs[0].append(sbs[row]); return sbs[0].toString();&#125;","categories":[{"name":"LeetCode算法之旅","slug":"LeetCode算法之旅","permalink":"https://lierabbit.cn/categories/LeetCode算法之旅/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"最长回文子串（Longest Palindromic Substring）","slug":"最长回文子串","date":"2018-05-08T07:43:48.000Z","updated":"2018-09-17T07:54:46.138Z","comments":true,"path":"2018/05/08/最长回文子串/","link":"","permalink":"https://lierabbit.cn/2018/05/08/最长回文子串/","excerpt":"","text":"题目描述给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为1000。 示例 1：输入: “babad”输出: “bab”注意: “aba”也是一个有效答案。 示例 2：输入: “cbbd”输出: “bb” 解决方法首先，我们通过在字母之间插入特殊字符’＃’来将输入字符串S转换为另一个字符串T，这么做的原因很快就会很快清楚。例如：S =“abaaba”，T =“＃a＃b＃a＃a＃b＃a＃”。为了找到最长的回文子串，我们需要在每个Ti周围扩展，使得Ti-d … Ti + d形成回文。你应该马上看到d是以Ti为中心的回文的长度。我们将中间结果存储在数组P中，其中P[i]等于在Ti处的回文中心的长度。最长的回文子串将成为P中的最大元素。使用上面的例子，我们填充P如下（从左到右）： 序号 0 1 2 3 4 5 6 7 8 9 10 11 12 T # a # b # a # a # b # a # P 0 1 0 3 0 1 6 1 0 3 0 1 0 看着P，我们立即看到最长的回文是“abaaba”，如P6 = 6所示。您是否注意到在字母之间插入特殊字符（＃），是否优雅地处理了奇数和偶数长度的回文？ （请注意：这是为了更容易地演示这个想法，并不一定需要对算法进行编码。）现在，想象你在回文中心“abaaba”绘制一条想象的垂直线。你有没有注意到P中的数字是围绕这个中心对称的？不仅如此，请尝试使用另一个回文“aba”，这些数字也反映了类似的对称性。这是巧合吗？答案是肯定的，不是。这仅仅是一个条件，但无论如何，我们有很大的进步，因为我们可以消除P[i]的重新计算部分。让我们继续讨论一个稍微复杂的例子，其中有更多的重叠回文，其中S =“babcbabcbaccba”。 上图显示T由S =“babcbabcbaccba”转化而来。假设你达到了表P部分完成的状态。垂直的实线表示回文“abcbabcba”的中心（C）。两条虚线垂直线分别表示其左（L）和右（R）边缘。您处于索引i处，其围绕C的镜像索引是i’。你如何有效地计算P[i]？假设我们已经到达指数i = 13，并且我们需要计算P[13]（由问号？表示）。我们首先看一下它在回文中心C周围的镜像索引i’，索引i’= 9。 上面的两条绿色实线表示以i和i’为中心的两个回文序列覆盖的区域。我们看一下C周围的镜像索引i’。P[i’] = P[9] = 1.由于回文在其中心附近具有对称性，因此P[i]必须也是1。正如你在上面看到的那样，P[i] = P[i’] = 1是非常明显的，由于回文中心周围的对称性，这一定是正确的。事实上，C之后的所有三个元素都遵循对称性（即P[12] = P[10] = 0，P[13] = P[9] = 1，P[14] = P[8] = 0）。 现在我们处于索引i = 15，其C上的镜像索引是i’= 7。P[15] = P[7] = 7？现在我们处于索引i = 15处。P[i]的值是什么？如果我们遵循对称性，P[i]的值应该与P[i’] = 7相同，但这是错误的。如果我们在T15围绕中心展开，它形成回文“A·B·C·B·一”，它实际上比它的镜像索引i’更短。 为什么？ 在索引i和i’处围绕中心重叠彩色线。 由于C周围的对称属性，绿色实线显示两侧必须匹配的区域。红色实线表示两侧可能不匹配的区域。 虚线绿线表示穿过中心的区域。很显然，由两条实线表示的区域中的两个子串必须完全匹配。中心区域（用绿色虚线表示）也必须是对称的。注意P[i’]是7，并且它一直扩展到回文的左边缘（L）（用红色实线表示），它不再落在回文的对称属性之下。我们所知道的是P[i] ≥ 5，并且为了找到P[i]的实际值，我们必须通过扩展右边缘（R）来进行字符匹配。在这种情况下，由于P[21]≠P[1]，我们得出结论P[i] = 5。我们总结一下这个算法的关键部分如下： 如果 P[i’] ≤ R - i，则 P[i] = P[i’]否则 P[i] ≥ P[i’]。那么我们必须扩展到右边缘（R）以找到P[i]。 看看它有多优雅？如果你能够充分掌握上述总结，那么你已经获得了这个算法的本质，这也是最难的部分。最后一部分是确定我们应该在何时将C的位置与R一起移动到右侧，这很容易： 如果以i为中心的回文确实扩展到R，我们将C更新为i（这个新回文的中心），并将R延伸到新回文的右边。 在每一步中，都有两种可能性。如果P[i]≤R-i，我们将P[i]设置为P[i’]，这只需要一步。否则，我们试图通过从右边缘R开始将回文中心改为i。扩展R（内部while循环）总共最多需要N个步骤，并且定位和测试每个中心总共需要N步。因此，该算法确保在至多2 * N步完成，给出线性时间解决方案，时间复杂度：O(N)Manacher(马拉车)算法解释原文 实现：真的添加#字符123456789101112131415161718192021222324252627282930313233343536public String longestPalindrome(String s) &#123; // 改造字符串，每个字符间添加#。添加头^尾$两个不同的字符用于消除边界判断 StringBuilder sb = new StringBuilder(\"^\"); for (int i = 0, len = s.length(); i &lt; len; i++) sb.append(\"#\").append(s.charAt(i)); sb.append(\"#$\"); int c = 0, r = 0, len = sb.length(), centerIndex = 0, maxLen = 0; int[] p = new int[len]; for (int i = 1; i &lt; len - 1; i++) &#123; int iMirror = 2 * c - i; // 相当于 c - (i - c) p[i] = r &gt; i ? Math.min(r - i, p[iMirror]) : 0; // 基于当前点为中心扩展寻找回文 while (sb.charAt(i - 1 - p[i]) == sb.charAt(i + 1 + p[i])) p[i]++; // 如果扩展后的右边界值大于当前右边界值则更新 if (i + p[i] &gt; r) &#123; c = i; r = i + p[i]; &#125; // 寻找最大值与中心点 if (p[i] &gt; maxLen) &#123; maxLen = p[i]; centerIndex = i; &#125; &#125; int beginIndex = (centerIndex - 1 - maxLen) / 2; return s.substring(beginIndex, beginIndex + maxLen);&#125; 实现：不真正添加#字符要想不添加#字符，那么只需要模拟添加#字符后的操作例如：原始字符：abcba a b c b a 0 1 2 3 4 添加#字符后 # a # b # c # b # a # 0 1 2 3 4 5 6 7 8 9 10 观察添加#字符后的字符串可知，#左边的字符在原始字符串的索引为#的索引/2，#右边的字符在原始字符串的索引为(#的索引-1)/2。例如：索引为4的#，它的左边字符是b，那么b在原始字符串的索引为4-1/2=1，它的右边字符是c，那么c在原始字符串的索引为4/2=2。 假设当前点为’c’则原始索引i=2，添加#字符后索引为i’=5，要对左右两边进行回文搜索。那么添加#字符后进行回文搜索的过程如下 左边索引 左边索引对应的字符 右边索引对应的字符 右边索引 4 # # 6 3 b b 7 2 # # 8 1 a a 9 0 # # 10 通过将其还原为对应的字符可实现不真正添加#字符也能运用上述算法 左边索引 左边索引对应的字符 右边索引对应的字符 右边索引 4/2=2 c c （6-1）/2=2 3/2=1 b b （7-1）/2=3 2/2=1 b b （8-1）/2=3 1/2=0 a a （9-1）/2=4 0/2=0 a a （10-1）/2=4 1234567891011121314151617181920212223242526272829303132333435363738394041public String longestPalindrome2(String s) &#123; if (s == null || s.length() &lt; 2) return s; // 添加头^尾$两个不同的字符用于消除边界判断 String temp = \"^\" + s + \"$\"; int c = 0, r = 0, len = s.length() * 2 + 1 + 2, centerIndex = 0, maxLen = 0; int[] p = new int[len]; for (int i = 1; i &lt; len - 1; i++) &#123; int iMirror = 2 * c - i; p[i] = r &gt; i ? Math.min(r - i, p[iMirror]) : 0; // 基于当前点为中心扩展寻找回文 int left = i - 1 - p[i]; int right = i + 1 + p[i]; while (temp.charAt(left / 2) == temp.charAt((right - 1) / 2)) &#123; p[i]++; left--; right++; &#125; // 如果扩展后的右边界值大于当前右边界值则更新 if (i + p[i] &gt; r) &#123; c = i; r = i + p[i]; &#125; // 寻找最大值与中心点 if (p[i] &gt; maxLen) &#123; maxLen = p[i]; centerIndex = i; &#125; &#125; int beginIndex = (centerIndex - 1 - maxLen) / 2; return s.substring(beginIndex, beginIndex + maxLen);&#125;","categories":[{"name":"LeetCode算法之旅","slug":"LeetCode算法之旅","permalink":"https://lierabbit.cn/categories/LeetCode算法之旅/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"两个排序数组的中位数（Median of Two Sorted Arrays）","slug":"两个排序数组的中位数","date":"2018-04-30T09:01:15.000Z","updated":"2018-09-17T07:54:46.131Z","comments":true,"path":"2018/04/30/两个排序数组的中位数/","link":"","permalink":"https://lierabbit.cn/2018/04/30/两个排序数组的中位数/","excerpt":"","text":"题目描述给定两个大小为 m 和 n 的有序数组 nums1 和 nums2 。请找出这两个有序数组的中位数。要求算法的时间复杂度为 O(log (m+n)) 。 示例 1:nums1 = [1, 3]nums2 = [2]中位数是 2.0 示例 2:nums1 = [1, 2]nums2 = [3, 4]中位数是 (2 + 3)/2 = 2.5 解决方法首先，让我们以一种非常规的方式看到’中位数’的概念。那是： “ 如果我们将排序后的数组切割成等于两半的等长，则平均数为最大值（lower_half）和最小值（upper_half）的平均值，即紧靠切割的两个数字 ”。 例如，对于[2 3 5 7]，我们在3和5之间进行切割： [2 3 / 5 7] 那么中位数=（3 + 5）/ 2。请注意，在本文中，我将使用’/‘来表示切割和（数字/数字）来表示通过数字进行的切割。对于[2 3 4 5 6]，我们将4切割： [2 3（4/4）5 7] 由于我们把4分成两半，所以我们说现在子单元的下部和上部都包含4。这个概念也导致了正确的答案：（4 + 4）/ 2 = 4。为了方便起见，我们使用L来表示切割的左边对应的数字，R表示切割的右边对应的数字。例如[2 3 5 7]，我们分别有L = 3和R = 5。我们观察到L和R的索引与数组N的长度有下列关系：123456789N Index of L / R1 0 / 02 0 / 13 1 / 1 4 1 / 2 5 2 / 26 2 / 37 3 / 38 3 / 4 不难断定L =（N-1）/ 2的指数，并且R = N / 2。因此，中位数可以表示为 (L + R)/2 = (A[(N-1)/2] + A[N/2])/2 为了准备好两个数组的情况，我们在数字之间添加一些想象的“位置”（表示为＃），并将数字视为“位置”。 [6 9 13 18] -&gt; [# 6 # 9 # 13 # 18 #] (N = 4)position index 0 1 2 3 4 5 6 7 8 (N_Position = 9) [6 9 11 13 18]-&gt; [# 6 # 9 # 11 # 13 # 18 #] (N = 5)position index 0 1 2 3 4 5 6 7 8 9 10 (N_Position = 11) 正如你所看到的，不管长度为N，总有正好2 * N + 1的位置。因此，中间切割应该总是在第N个位置（基于0的位置）进行。在这种情况下，由于index(L)=(N-1)/2和index(R)=N/2，我们可以推断 index(L) = (CutPosition-1)/2, index(R) = (CutPosition)/2 现在对于两个数组的情况： A1: [# 1 # 2 # 3 # 4 # 5 #] (N1 = 5, N1_positions = 11)A2: [# 1 # 1 # 1 # 1 #] (N2 = 4, N2_positions = 9) 类似于单数组问题，我们需要找到一个将两个数组分成两半的切割 “左半部分的任何数字”&lt;=“右半部分的任何数字”。 我们也可以提出以下意见： 共有2个N1 + 2个 N2 + 2个位置。因此，在切割的每一边必须有N1 + N2的位置，并且直接在切割处有2个位置。 因此，当我们在A2中的位置C2 = K处切割时，A1中的切割位置必须是C1 = N1 + N2-k。例如，如果C2 = 2，那么我们必须有C1 = 4 + 5 - C2 = 7。 [# 1 # 2 # 3 # (4/4) # 5 #][# 1 / 1 # 1 # 1 #] 切割完成后，我们会有两个L和两个R。他们是 L1 = A1[(C1-1)/2]; R1 = A1[C1/2];L2 = A2[(C2-1)/2]; R2 = A2[C2/2]; 在上面的例子中， L1 = A1[(7-1)/2] = A1[3] = 4; R1 = A1[7/2] = A1[3] = 4;L2 = A2[(2-1)/2] = A2[0] = 1; R2 = A1[2/2] = A11 = 1; 现在我们该如何决定这个切割是否是我们想要的切割？因为L1，L2是左边最大的数字，而R1，R2是右边最小的数字，所以我们只需要 L1 &lt;= R1 &amp;&amp; L1 &lt;= R2 &amp;&amp; L2 &lt;= R1 &amp;&amp; L2 &lt;= R2 确保下半部分的任何数字&lt;=上半部分的任何数字。事实上，因为L1 &lt;= R1和L2 &lt;= R2是自然保证的，因为A1和A2是分类的，我们只需要确保： L1 &lt;= R2且L2 &lt;= R1。 现在我们可以使用简单的二分查找来找出结果。 如果我们有L1&gt; R2，这意味着在A1的左半部分有太多的大数字，那么我们必须将C1向左移动（即向右移动C2）。如果L2&gt; R1，那么A2的左半部分有太多的大数字，我们必须将C2移到左边。否则，这一切是正确的。在我们找到切割后，可以得出结果为（max（L1，L2）+ min（R1，R2））/ 2; 注意： 由于C1和C2可以相互确定，我们可以先移动其中一个，然后相应地计算另一个。但是，首先将C2（较短数组上的一个）移动更为实用。原因是，在较短的数组上，所有位置都可能是中位数的切割位置，但在较长的数组上，左右位置过于靠后的位置对于合法切割根本不可能。例如，[1]，[2 3 4 5 6 7 8]。很显然，2和3之间的切割是不可能的，因为如果你用这种方式进行切割，较短的数组没有那么多元素来平衡[3 4 5 6 7 8]部分。因此，要将较长的数组用作第一次切割的基础，必须执行范围检查。在较短的数组上执行操作会更容易，也无需进行任何检查。 唯一的边缘情况是当切割落在第0(第一个)或第2N （最后一个）位置时。例如，如果C2 = 2N2，则R2 = A2 [2 * N2 / 2] = A2 [N2]，其超出数组的边界。为了解决这个问题，我们可以想象，A1和A2实际上有两个额外的元素，INT_MAX在A [-1]和INT_MAX在A [N]。这些添加不会改变结果，但会使实现更容易：如果任何L落在数组的左边界之外，则L = INT_MIN，并且如果有任何R落在右边界之外，则R = INT_MAX。 我知道这不是很容易理解，但所有上述推理最终归结为以下简洁的代码： 123456789101112131415161718192021222324public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123; int n1 = nums1.length; int n2 = nums2.length; if (n1 &lt; n2) return findMedianSortedArrays(nums2, nums1); // 确保nums2为短数组 int lo = 0, hi = n2 * 2; // while (lo &lt;= hi) &#123; int c2 = (lo + hi) &gt;&gt; 1; int c1 = n1 + n2 - c2; double L1 = (c1 == 0) ? Integer.MIN_VALUE : nums1[(c1 - 1) / 2]; double L2 = (c2 == 0) ? Integer.MIN_VALUE : nums2[(c2 - 1) / 2]; double R1 = (c1 == n1 * 2) ? Integer.MAX_VALUE : nums1[c1 / 2]; double R2 = (c2 == n2 * 2) ? Integer.MAX_VALUE : nums2[c2 / 2]; if (L1 &gt; R2) lo = c2 + 1; // 增大c2，减小c1，向右移动c2 else if (L2 &gt; R1) hi = c2 - 1; // 减小c2，增大c1，向左移动c2 else return (Math.max(L1, L2) + Math.min(R1, R2)) / 2; &#125; return -1;&#125; 时间复杂度：O(log(min(M,N))) 算法解释原文","categories":[{"name":"LeetCode算法之旅","slug":"LeetCode算法之旅","permalink":"https://lierabbit.cn/categories/LeetCode算法之旅/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"无重复字符的最长子串（Longest Substring Without Repeating Characters）","slug":"无重复字符的最长子串","date":"2018-04-24T03:24:58.000Z","updated":"2018-09-17T07:54:46.137Z","comments":true,"path":"2018/04/24/无重复字符的最长子串/","link":"","permalink":"https://lierabbit.cn/2018/04/24/无重复字符的最长子串/","excerpt":"","text":"题目描述给定一个字符串，找出不含有重复字符的最长子串的长度。 示例：给定 “abcabcbb” ，没有重复字符的最长子串是 “abc” ，那么长度就是3。给定 “bbbbb” ，最长的子串就是 “b” ，长度是1。给定 “pwwkew” ，最长子串是 “wke” ，长度是3。请注意答案必须是一个子串，”pwke” 是 子序列 而不是子串。 解决方法使用HashMap记录字符上次出现的位置，用pre记录最近重复字符出现的位置，则i(当前位置)-pre就是当前字符最长无重复字符的长度，取最大的就是字符串的最长无重复字符的长度 123456789101112131415161718192021public int lengthOfLongestSubstring(String str) &#123; if (str == null || str.length() &lt; 1) return 0; // 记录字符上次出现的位置 HashMap&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); int max = 0; // 最近出现重复字符的位置 int pre = -1; for (int i = 0, strLen = str.length(); i &lt; strLen; i++) &#123; Character ch = str.charAt(i); Integer index = map.get(ch); if (index != null) pre = Math.max(pre, index); max = Math.max(max, i - pre); map.put(ch, i); &#125; return max;&#125; 时间复杂度：O(n)","categories":[{"name":"LeetCode算法之旅","slug":"LeetCode算法之旅","permalink":"https://lierabbit.cn/categories/LeetCode算法之旅/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"两数相加（Add Two Numbers）","slug":"两数相加","date":"2018-04-23T04:15:27.000Z","updated":"2018-09-17T07:54:46.132Z","comments":true,"path":"2018/04/23/两数相加/","link":"","permalink":"https://lierabbit.cn/2018/04/23/两数相加/","excerpt":"","text":"题目描述给定两个非空链表来表示两个非负整数。位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。你可以假设除了数字 0 之外，这两个数字都不会以零开头。 示例：输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 ListNode数据结构12345678class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125;&#125; 解决方法遍历链表对应相加即可，注意进位 方法一123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; // 为方便操作加入的头结点 ListNode res = new ListNode(0); // 当前结点 ListNode cur = res; // 进位标志 boolean[] flag = new boolean[1]; // 两链表对应位置相加 while (l1 != null &amp;&amp; l2 != null) &#123; ListNode node = add(l1.val, l2.val, flag); cur.next = node; cur = node; l1 = l1.next; l2 = l2.next; &#125; // 如果l1链表有剩余，则剩下的与0相加 while (l1 != null) &#123; ListNode node = add(l1.val, 0, flag); cur.next = node; cur = node; l1 = l1.next; &#125; // 如果l2链表有剩余，则剩下的与0相加 while (l2 != null) &#123; ListNode node = add(0, l2.val, flag); cur.next = node; cur = node; l2 = l2.next; &#125; // 如果链表末尾相加有进位则添加一个进位节点作为尾节点 if (flag[0]) cur.next = new ListNode(1); return res.next;&#125;public ListNode add(int v1, int v2, boolean[] flag) &#123; int sum = v1 + v2; // 如果有进位则和+1 if (flag[0]) &#123; sum++; flag[0] = false; &#125; // 产生进位 if (sum &gt; 9) flag[0] = true; // 获取个位上的数 return new ListNode(sum % 10);&#125; 时间复杂度：O(max(M,N))。M，N分别为l1，l2的链表长度 基于方法一的改进1234567891011121314151617181920212223public ListNode addTwoNumbers2(ListNode l1, ListNode l2) &#123; // 为方便操作加入的头节点 ListNode res = new ListNode(0); // 当前节点 ListNode cur = res; // 进位 int carry = 0; // 两链表对应相加 while (l1 != null || l2 != null || carry != 0) &#123; int sum = (l1 != null ? l1.val : 0) + (l2 != null ? l2.val : 0) + carry; // 获取进位 carry = sum / 10; // 获取个位上的数 ListNode node = new ListNode(sum % 10); cur.next = node; cur = node; l1 = l1 != null ? l1.next : null; l2 = l2 != null ? l2.next : null; &#125; return res.next;&#125; 时间复杂度：O(max(M,N))。M，N分别为l1，l2的链表长度","categories":[{"name":"LeetCode算法之旅","slug":"LeetCode算法之旅","permalink":"https://lierabbit.cn/categories/LeetCode算法之旅/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"两数之和（Two Sum）","slug":"两数之和","date":"2018-04-22T04:19:19.000Z","updated":"2018-09-17T07:54:46.132Z","comments":true,"path":"2018/04/22/两数之和/","link":"","permalink":"https://lierabbit.cn/2018/04/22/两数之和/","excerpt":"","text":"题目描述给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。 示例:给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 解决方法若a + b = c，则 c - a = b。所以只需记录所有遍历过的数，然后利用预期值-当前值得出的值查询是否已有记录，如果有则退出循环。 12345678910111213141516171819public int[] twoSum(int[] nums, int target) &#123; int[] res = new int[2]; // 记录遍历过的数和索引 Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; // 获取target-nums[i]，看是否存在，存在则表明可以相加为target Integer value = map.get(target - nums[i]); if (value != null) &#123; res[0] = value; res[1] = i; break; &#125; // 用键保存遍历过的数，用值保存遍历过的索引 map.put(nums[i], i); &#125; return res;&#125; 时间复杂度：O(n)空间复杂度：O(n)","categories":[{"name":"LeetCode算法之旅","slug":"LeetCode算法之旅","permalink":"https://lierabbit.cn/categories/LeetCode算法之旅/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"机器人的运动范围","slug":"机器人的运动范围","date":"2018-04-21T05:16:59.000Z","updated":"2018-08-26T13:45:22.727Z","comments":true,"path":"2018/04/21/机器人的运动范围/","link":"","permalink":"https://lierabbit.cn/2018/04/21/机器人的运动范围/","excerpt":"","text":"地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？ 思路：使用二维数组isVisit保存访问过的格子，按上下左右方向依次递归访问各个格子 123456789101112131415161718192021222324252627282930313233343536373839public int movingCount(int threshold, int rows, int cols) &#123; // 记录访问过的点 boolean[][] isVisit = new boolean[rows][cols]; return movingCountCore(threshold, rows, cols, 0, 0, isVisit);&#125;public int movingCountCore(int threshold, int rows, int cols, int y, int x, boolean[][] isVisit) &#123; // 排除非法点以及访问过的点 if (y &gt;= rows || y &lt; 0 || x &gt;= cols || x &lt; 0 || isVisit[y][x] || calcXY(x, y) &gt; threshold) return 0; // 设置当前点已访问 isVisit[y][x] = true; // 按上下左右方向访问 return movingCountCore(threshold, rows, cols, y + 1, x, isVisit) + movingCountCore(threshold, rows, cols, y - 1, x, isVisit) + movingCountCore(threshold, rows, cols, y, x - 1, isVisit) + movingCountCore(threshold, rows, cols, y, x + 1, isVisit) + 1;&#125;// 计算坐标为（x，y）的点的数位之和private int calcXY(int x, int y) &#123; return calc(x) + calc(y);&#125;// 计算value的数位之和private int calc(int value) &#123; int res = 0; while (value != 0) &#123; res += value % 10; value /= 10; &#125; return res;&#125;","categories":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://lierabbit.cn/categories/剑指Offer/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"矩阵中的路径","slug":"矩阵中的路径","date":"2018-04-20T03:15:08.000Z","updated":"2018-08-26T13:42:49.310Z","comments":true,"path":"2018/04/20/矩阵中的路径/","link":"","permalink":"https://lierabbit.cn/2018/04/20/矩阵中的路径/","excerpt":"","text":"请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 例如 a b c e s f c s a d e e 矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。 思路：用一个状态数组保存之前访问过的字符，然后再分别按上下左右方向寻找 123456789101112131415161718192021222324252627282930313233343536373839404142434445public boolean hasPath(char[] matrix, int rows, int cols, char[] str) &#123; // 记录位置是否已访问 boolean[] flags = new boolean[matrix.length]; // 遍历所有位置 for (int x = 0; x &lt; rows; x++) &#123; for (int y = 0; y &lt; cols; y++) &#123; if (hasPathCore(matrix, rows, cols, x, y, str, 0, flags)) return true; &#125; &#125; return false;&#125;public boolean hasPathCore(char[] matrix, int rows, int cols, int x, int y, char[] str, int k, boolean[] flags) &#123; // 计算当前坐标 int index = x * cols + y; // 非法判断 if (x &lt; 0 || x &gt;= rows || y &lt; 0 || y &gt;= cols || matrix[index] != str[k] || flags[index]) return false; // 匹配完成 if (k == str.length - 1) return true; // 当前点已访问 flags[index] = true; // 往后寻找 k++; // 按上下左右方向寻找 if (hasPathCore(matrix, rows, cols, x - 1, y, str, k, flags) || hasPathCore(matrix, rows, cols, x + 1, y, str, k, flags) || hasPathCore(matrix, rows, cols, x, y - 1, str, k, flags) || hasPathCore(matrix, rows, cols, x, y + 1, str, k, flags)) return true; // 未找到还原当前点为未访问 flags[index] = false; // 未找到 return false;&#125;","categories":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://lierabbit.cn/categories/剑指Offer/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"滑动窗口的最大值","slug":"滑动窗口的最大值","date":"2018-04-19T06:06:04.000Z","updated":"2018-08-26T13:40:29.320Z","comments":true,"path":"2018/04/19/滑动窗口的最大值/","link":"","permalink":"https://lierabbit.cn/2018/04/19/滑动窗口的最大值/","excerpt":"","text":"给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。 思路：使用双端队列记录访问到的最大值，判断该值是否还在窗口内 1234567891011121314151617181920212223public ArrayList&lt;Integer&gt; maxInWindows(int[] num, int size) &#123; ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if (size &lt; 1) return res; Deque&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; num.length; i++) &#123; while (!queue.isEmpty() &amp;&amp; num[queue.peekLast()] &lt; num[i]) queue.pollLast(); queue.add(i); if (i &gt;= size - 1) &#123; // 判断最大值是否在窗口内 if (queue.peekFirst() == i - size) queue.pollFirst(); res.add(num[queue.peekFirst()]); &#125; &#125; return res;&#125;","categories":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://lierabbit.cn/categories/剑指Offer/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"数据流中的中位数","slug":"数据流中的中位数","date":"2018-04-18T03:21:29.000Z","updated":"2018-08-26T13:37:03.238Z","comments":true,"path":"2018/04/18/数据流中的中位数/","link":"","permalink":"https://lierabbit.cn/2018/04/18/数据流中的中位数/","excerpt":"","text":"如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。 思路：使用2个堆，一个小根堆放大的数，一个大根堆放小的数，当数据流中数据个数为偶数加入大根堆，奇数加入小根堆。若当前数据量为奇数则中位数为大根堆的堆顶，若当前数据量为偶数则为小根堆与大根堆的堆顶和再➗2 12345678910111213141516171819202122public class 数据流中的中位数 &#123; private int count = 0; private PriorityQueue&lt;Integer&gt; minHeap = new PriorityQueue&lt;&gt;(); private PriorityQueue&lt;Integer&gt; maxHeap = new PriorityQueue&lt;&gt;((v1, v2) -&gt; v2 - v1); public void Insert(Integer num) &#123; if ((count++ &amp; 1) == 0) &#123; minHeap.add(num); maxHeap.add(minHeap.poll()); &#125; else &#123; maxHeap.add(num); minHeap.add(maxHeap.poll()); &#125; &#125; public Double GetMedian() &#123; if ((count &amp; 1) == 0) return (minHeap.peek() + maxHeap.peek()) / 2.0; else return Double.valueOf(maxHeap.peek()); &#125;&#125;","categories":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://lierabbit.cn/categories/剑指Offer/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"二叉搜索树的第k个结点","slug":"二叉搜索树的第k个结点","date":"2018-04-17T02:47:40.000Z","updated":"2018-08-26T13:33:38.805Z","comments":true,"path":"2018/04/17/二叉搜索树的第k个结点/","link":"","permalink":"https://lierabbit.cn/2018/04/17/二叉搜索树的第k个结点/","excerpt":"","text":"给定一颗二叉搜索树，请找出其中的第k个结点。例如，12345 5 / \\ 3 7 / \\ / \\ 2 4 6 8 按结点数值大小顺序第三个结点的值为4。 思路：中序遍历查找第K个 12345678910111213141516171819202122232425262728293031323334353637383940414243public class 二叉搜索树的第k个结点 &#123; int index; TreeNode KthNode(TreeNode pRoot, int k) &#123; index = k; return KthNodeCore(pRoot); &#125; TreeNode KthNodeCore(TreeNode pRoot) &#123; if (pRoot == null) return pRoot; TreeNode node = KthNodeCore(pRoot.left); if (node != null) return node; index--; if (index == 0) return pRoot; node = KthNodeCore(pRoot.right); return node; &#125; public static void main(String[] args) &#123; TreeNode t2 = new TreeNode(2); TreeNode t3 = new TreeNode(3); TreeNode t4 = new TreeNode(4); TreeNode t5 = new TreeNode(5); TreeNode t6 = new TreeNode(6); TreeNode t7 = new TreeNode(7); TreeNode t8 = new TreeNode(8); t5.left = t3; t5.right = t7; t3.left = t2; t3.right = t4; t7.left = t6; t7.right = t8; 二叉搜索树的第k个结点 test = new 二叉搜索树的第k个结点(); System.out.println(test.KthNode(t5,3).val); &#125;&#125;","categories":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://lierabbit.cn/categories/剑指Offer/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"序列化二叉树","slug":"序列化二叉树","date":"2018-04-16T09:06:47.000Z","updated":"2018-08-26T13:32:11.216Z","comments":true,"path":"2018/04/16/序列化二叉树/","link":"","permalink":"https://lierabbit.cn/2018/04/16/序列化二叉树/","excerpt":"","text":"请实现两个函数，分别用来序列化和反序列化二叉树 思路：使用先序遍历序列化和反序列化二叉树 1234567891011121314151617181920212223242526272829303132333435363738394041public class 序列化二叉树 &#123; int index; String Serialize(TreeNode root) &#123; StringBuilder sb = new StringBuilder(); SerializeCore(root, sb); return sb.toString(); &#125; void SerializeCore(TreeNode node, StringBuilder sb) &#123; if (node == null) sb.append(\"#!\"); else &#123; sb.append(node.val).append(\"!\"); SerializeCore(node.left, sb); SerializeCore(node.right, sb); &#125; &#125; TreeNode Deserialize(String str) &#123; index = -1; return DeserializeCore(str.split(\"!\")); &#125; TreeNode DeserializeCore(String[] strs) &#123; index++; if (index &gt; strs.length) return null; String str = strs[index]; if (str.equals(\"#\")) return null; else &#123; TreeNode node = new TreeNode(Integer.valueOf(strs[index])); node.left = DeserializeCore(strs); node.right = DeserializeCore(strs); return node; &#125; &#125;&#125;","categories":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://lierabbit.cn/categories/剑指Offer/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"按之字形顺序打印二叉树","slug":"按之字形顺序打印二叉树","date":"2018-04-15T07:41:34.000Z","updated":"2018-08-26T13:31:12.690Z","comments":true,"path":"2018/04/15/按之字形顺序打印二叉树/","link":"","permalink":"https://lierabbit.cn/2018/04/15/按之字形顺序打印二叉树/","excerpt":"","text":"请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。 思路：使用队列保存按行从左往右的节点，使用last记录当前行的最右节点，使用nLast表示下一行的最右节点，当队列弹出的节点等于last表示当前行已打印完毕，进行换行。使用isNeedReverse进行偶数行反转即可完成之字形 123456789101112131415161718192021222324252627282930313233343536public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; Print(TreeNode pRoot) &#123; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); if (pRoot == null) return res; ArrayList&lt;Integer&gt; row = new ArrayList&lt;&gt;(); TreeNode last = pRoot; TreeNode node, nLast = null; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(pRoot); boolean isNeedReverse = false; // 是否需要反转 while (!queue.isEmpty()) &#123; node = queue.poll(); row.add(node.val); if (node.left != null) &#123; queue.add(node.left); nLast = node.left; &#125; if (node.right != null) &#123; queue.add(node.right); nLast = node.right; &#125; if (node == last) &#123; last = nLast; if (isNeedReverse) Collections.reverse(row); res.add(row); row = new ArrayList&lt;&gt;(); isNeedReverse = !isNeedReverse; &#125; &#125; return res;&#125;","categories":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://lierabbit.cn/categories/剑指Offer/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"把二叉树打印成多行","slug":"把二叉树打印成多行","date":"2018-04-13T15:24:32.000Z","updated":"2018-08-26T13:30:02.292Z","comments":true,"path":"2018/04/13/把二叉树打印成多行/","link":"","permalink":"https://lierabbit.cn/2018/04/13/把二叉树打印成多行/","excerpt":"","text":"从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。 思路：使用队列保存按行从左往右的节点，使用last记录当前行的最右节点，使用nLast表示下一行的最右节点，当队列弹出的节点等于last表示当前行已打印完毕，进行换行 1234567891011121314151617181920212223242526272829303132ArrayList&lt;ArrayList&lt;Integer&gt;&gt; Print(TreeNode pRoot) &#123; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); if (pRoot == null) return res; ArrayList&lt;Integer&gt; row = new ArrayList&lt;&gt;(); TreeNode last = pRoot; TreeNode nLast = null; TreeNode node; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(pRoot); while (!queue.isEmpty()) &#123; node = queue.poll(); row.add(node.val); if (node.left != null) &#123; queue.add(node.left); nLast = node.left; &#125; if (node.right != null) &#123; queue.add(node.right); nLast = node.right; &#125; if (node == last) &#123; res.add(row); row = new ArrayList&lt;&gt;(); last = nLast; &#125; &#125; return res;&#125;","categories":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://lierabbit.cn/categories/剑指Offer/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"对称的二叉树","slug":"对称的二叉树","date":"2018-04-12T14:12:51.000Z","updated":"2018-08-26T13:28:12.881Z","comments":true,"path":"2018/04/12/对称的二叉树/","link":"","permalink":"https://lierabbit.cn/2018/04/12/对称的二叉树/","excerpt":"","text":"请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。 思路：递归判断左右子树 123456789101112131415boolean isSymmetrical(TreeNode pRoot) &#123; if (pRoot == null) return true; else return isSymmetricalCore(pRoot.left, pRoot.right);&#125;boolean isSymmetricalCore(TreeNode left, TreeNode right) &#123; if (left == null &amp;&amp; right == null) return true; else if (left != null &amp;&amp; right != null) return left.val == right.val &amp;&amp; isSymmetricalCore(left.left, right.right) &amp;&amp; isSymmetricalCore(left.right, right.left); else return false;&#125;","categories":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://lierabbit.cn/categories/剑指Offer/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"二叉树的下一个结点","slug":"二叉树的下一个结点","date":"2018-04-11T15:37:31.000Z","updated":"2018-08-26T13:24:20.016Z","comments":true,"path":"2018/04/11/二叉树的下一个结点/","link":"","permalink":"https://lierabbit.cn/2018/04/11/二叉树的下一个结点/","excerpt":"","text":"给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。 这题给的TreeLinkNode的next比较迷，居然是父节点的意思 思路：分析二叉树的下一个节点，一共有以下情况： 二叉树为空，则返回空 节点右孩子存在，则设置一个指针从该节点的右孩子出发，一直沿着指向左子结点的指针找到的叶子节点即为下一个节点 节点不是根节点。如果该节点是其父节点的左孩子，则返回父节点。否则继续向上遍历其父节点的父节点，重复之前的判断，返回结果 12345678910111213141516171819202122232425262728293031323334353637383940414243public class TreeLinkNode &#123; int val; TreeLinkNode left = null; TreeLinkNode right = null; TreeLinkNode next = null; TreeLinkNode(int val) &#123; this.val = val; &#125;&#125;public class 二叉树的下一个结点 &#123; public TreeLinkNode GetNext(TreeLinkNode pNode) &#123; if (pNode == null) // 二叉树为空，则返回空 return null; else if (pNode.right != null) &#123; // 节点右孩子存在，则设置一个指针从该节点的右孩子出发，一直沿着指向左子结点的指针找到的叶子节点即为下一个节点 pNode = pNode.right; while (pNode.left != null) &#123; pNode = pNode.left; &#125; return pNode; &#125; else &#123; // 如果该节点是其父节点的左孩子，则返回父节点；否则继续向上遍历其父节点的父节点，重复之前的判断，返回结果。 while (pNode.next != null) &#123; if (pNode.next.left == pNode) return pNode.next; pNode = pNode.next; &#125; return null; &#125; &#125; public static void main(String[] args) &#123; 二叉树的下一个结点 test = new 二叉树的下一个结点(); TreeLinkNode t1 = new TreeLinkNode(1); TreeLinkNode t2 = new TreeLinkNode(2); TreeLinkNode t3 = new TreeLinkNode(3); t1.left = t2; t2.next = t1; t2.right = t3; t3.next = t2; System.out.println(test.GetNext(t3)); &#125;&#125;","categories":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://lierabbit.cn/categories/剑指Offer/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"删除链表中重复的结点","slug":"删除链表中重复的结点","date":"2018-04-09T05:51:56.000Z","updated":"2018-08-26T13:22:20.539Z","comments":true,"path":"2018/04/09/删除链表中重复的结点/","link":"","permalink":"https://lierabbit.cn/2018/04/09/删除链表中重复的结点/","excerpt":"","text":"在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5 思路：使用3个指针pre,cur,next遍历链表寻找重复节点删除 1234567891011121314151617181920212223242526public ListNode deleteDuplication(ListNode pHead) &#123; if (pHead == null || pHead.next == null) return pHead; ListNode newHead = new ListNode(-1); newHead.next = pHead; ListNode pre = newHead; ListNode cur = pre.next; ListNode next; while (cur != null &amp;&amp; cur.next != null) &#123; next = cur.next; if (cur.val == next.val) &#123; next = next.next; while (next != null &amp;&amp; cur.val == next.val) next = next.next; pre.next = next; cur = next; &#125; else &#123; pre = cur; cur = next; &#125; &#125; return newHead.next;&#125;","categories":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://lierabbit.cn/categories/剑指Offer/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"字符流中第一个不重复的字符","slug":"字符流中第一个不重复的字符","date":"2018-04-08T15:10:52.000Z","updated":"2018-08-26T13:20:25.105Z","comments":true,"path":"2018/04/08/字符流中第一个不重复的字符/","link":"","permalink":"https://lierabbit.cn/2018/04/08/字符流中第一个不重复的字符/","excerpt":"","text":"请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。 输出描述:如果当前字符流没有存在出现一次的字符，返回#字符。 思路：一个字符占8位，因此不会超过256个，可以申请一个256大小的数组来实现一个简易的哈希表。时间复杂度为O(n)，空间复杂度O(n) 123456789101112131415161718192021public class 字符流中第一个不重复的字符 &#123; private int[] map = new int[256]; private StringBuilder sb = new StringBuilder(); //Insert one char from stringstream public void Insert(char ch) &#123; sb.append(ch); map[ch]++; &#125; //return the first appearence once char in current stringstream public char FirstAppearingOnce() &#123; String str = sb.toString(); char[] chars = str.toCharArray(); for (char ch : chars) if (map[ch] == 1) return ch; return '#'; &#125;&#125;","categories":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://lierabbit.cn/categories/剑指Offer/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"链表中环的入口结点","slug":"链表中环的入口结点","date":"2018-04-03T13:16:58.000Z","updated":"2018-08-26T13:19:19.893Z","comments":true,"path":"2018/04/03/链表中环的入口结点/","link":"","permalink":"https://lierabbit.cn/2018/04/03/链表中环的入口结点/","excerpt":"","text":"一个链表中包含环，请找出该链表的环的入口结点。 思路：使用快慢指针，一个每次走一步，一个每次走两步，如果快慢指针相遇则有环，令快指针等于头节点，这次快指针和慢指针同步走，当他们再次相遇时就是入环点 1234567891011121314151617181920212223public ListNode EntryNodeOfLoop(ListNode pHead) &#123; if (pHead == null || pHead.next == null) return null; ListNode fast = pHead.next.next, node = pHead.next; while (fast != node) &#123; if (fast.next != null &amp;&amp; fast.next.next != null) &#123; fast = fast.next.next; node = node.next; &#125; else return null; &#125; fast = pHead; while (fast != node) &#123; fast = fast.next; node = node.next; &#125; return fast;&#125;","categories":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://lierabbit.cn/categories/剑指Offer/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"表示数值的字符串","slug":"表示数值的字符串","date":"2018-04-02T10:26:24.000Z","updated":"2018-08-26T13:18:41.393Z","comments":true,"path":"2018/04/02/表示数值的字符串/","link":"","permalink":"https://lierabbit.cn/2018/04/02/表示数值的字符串/","excerpt":"","text":"请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。 思路：排除所有不合法的数字 第一次出现+-符号，且不是在字符串开头，必须紧接在e之后 第二次出现+-符号，必须紧接在e之后 不能同时存在两个e且e后面一定要接数字 e后面不能接小数点 小数点不能出现两次 除符号外其余字符处于‘0’与‘9’之间 12345678910111213141516171819202122232425public boolean isNumeric(char[] str) &#123; // 标记符号、小数点、e是否出现过 boolean hasSign = false, hasDecimal = false, hasE = false; for (int i = 0, len = str.length; i &lt; len; i++) &#123; char ch = str[i]; if (ch == '+' || ch == '-') &#123; if (hasSign &amp;&amp; str[i - 1] != 'e' &amp;&amp; str[i - 1] != 'E') // 第二次出现+-符号，则必须紧接在e之后 return false; else if (!hasSign &amp;&amp; i &gt; 0 &amp;&amp; str[i - 1] != 'e' &amp;&amp; str[i - 1] != 'E') // 第一次出现+-符号，且不是在字符串开头，则也必须紧接在e之后 return false; hasSign = true; &#125; else if (ch == 'e' || ch == 'E') &#123; if (hasE || i == len - 1) // 不能同时存在两个e且e后面一定要接数字 return false; hasE = true; &#125; else if (ch == '.') &#123; if (hasE || hasDecimal) // e后面不能接小数点，小数点不能出现两次 return false; hasDecimal = true; &#125; else if (ch &lt; '0' || ch &gt; '9') // 不合法字符 return false; &#125; return true;&#125;","categories":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://lierabbit.cn/categories/剑指Offer/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"正则表达式匹配","slug":"正则表达式匹配","date":"2018-04-01T07:42:40.000Z","updated":"2018-08-26T13:13:38.581Z","comments":true,"path":"2018/04/01/正则表达式匹配/","link":"","permalink":"https://lierabbit.cn/2018/04/01/正则表达式匹配/","excerpt":"","text":"请实现一个函数用来匹配包括’.’和’*‘的正则表达式。模式中的字符’.’表示任意一个字符，而’*‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab*ac*a”匹配，但是与”aa.a”和”ab*a”均不匹配 思路：当模式中的第二个字符是“*”时：如果字符串第一个字符跟模式第一个字符不匹配，则模式后移2个字符，继续匹配。如果字符串第一个字符跟模式第一个字符匹配，可以有2种匹配方式： 模式后移2字符，相当于x*被忽略 字符串后移1字符，模式不变，即继续匹配字符下一位，因为*可以匹配多位 当模式中的第二个字符不是“*”时： 如果字符串第一个字符和模式中的第一个字符相匹配，那么字符串和模式都后移一个字符，然后匹配剩余的 如果字符串第一个字符和模式中的第一个字符相不匹配，直接返回false 这里需要注意的是：要时刻检验数组是否越界 12345678910111213141516171819202122232425262728293031public boolean match(char[] str, char[] pattern) &#123; if (str == null || pattern == null) return false; return matchCore(str, 0, pattern, 0);&#125;public boolean matchCore(char[] str, int strIndex, char[] pattern, int patternIndex) &#123; // 有效性检验：str到尾，pattern到尾，匹配成功 if (strIndex == str.length &amp;&amp; patternIndex == pattern.length) return true; // pattern先到尾，匹配失败 if (strIndex != str.length &amp;&amp; patternIndex == pattern.length) return false; // 模式后一个字符是*，且字符串第1个跟模式第1个匹配,分2种匹配模式。如不匹配，模式后移2位 if (patternIndex + 1 &lt; pattern.length &amp;&amp; pattern[patternIndex + 1] == '*') &#123; if ((strIndex != str.length &amp;&amp; str[strIndex] == pattern[patternIndex]) || (pattern[patternIndex] == '.' &amp;&amp; strIndex != str.length)) return matchCore(str, strIndex + 1, pattern, patternIndex) // x*匹配1个字符，再匹配str中的下一个 || matchCore(str, strIndex, pattern, patternIndex + 2); // 模式后移2位，视为x*匹配0个字符 else return matchCore(str, strIndex, pattern, patternIndex + 2); &#125; else &#123; // 模式后一个字符不是*，且字符串第1个跟模式第1个匹配，则都后移1位，否则直接返回false if ((strIndex != str.length &amp;&amp; str[strIndex] == pattern[patternIndex]) || (pattern[patternIndex] == '.' &amp;&amp; strIndex != str.length)) return matchCore(str, strIndex + 1, pattern, patternIndex + 1); else return false; &#125;&#125;","categories":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://lierabbit.cn/categories/剑指Offer/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"构建乘积数组","slug":"构建乘积数组","date":"2018-03-31T15:32:27.000Z","updated":"2018-08-26T13:06:29.428Z","comments":true,"path":"2018/03/31/构建乘积数组/","link":"","permalink":"https://lierabbit.cn/2018/03/31/构建乘积数组/","excerpt":"","text":"给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]*A[1]*…*A[i-1]*A[i+1]*…*A[n-1]。不能使用除法。 思路：B[i]的值可以看作下面表格矩阵中每行的乘积。下三角用连乘可以很容求得，上三角，从下向上也是连乘。 因此我们的思路就很清晰了，先算下三角中的连乘，即我们先算出B[i]中的一部分，然后倒过来按上三角中的分布规律，把另一部分也乘进去。 B数组 0 1 2 ······ n-2 n-1 B0 1 A1 A2 ······ An-2 An-1 B1 A0 1 A2 ······ An-2 An-1 B2 A0 A1 1 ······ An-2 An-1 B3 A0 A1 A2 ······ An-2 An-1 B4 A0 A1 A2 ······ 1 An-1 B5 A0 A1 A2 ······ An-2 1 1234567891011121314151617181920public int[] multiply(int[] A) &#123; if (A == null) return null; int length = A.length; int[] B = new int[length]; if (length == 0) return B; B[0] = 1; // 计算下三角 for (int i = 1; i &lt; length; i++) B[i] = B[i - 1] * A[i - 1]; // 计算上三角 int temp = 1; for (int i = length - 1; i &gt;= 0; i--) &#123; B[i] *= temp; temp *= A[i]; &#125; return B;&#125;","categories":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://lierabbit.cn/categories/剑指Offer/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"数组中重复的数字","slug":"数组中重复的数字","date":"2018-03-30T06:41:44.000Z","updated":"2018-08-26T12:56:16.463Z","comments":true,"path":"2018/03/30/数组中重复的数字/","link":"","permalink":"https://lierabbit.cn/2018/03/30/数组中重复的数字/","excerpt":"","text":"在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。 思路：使用一个map数组模拟hashmap统计数组中各个数字出现的次数，遍历数组判断当前数字出现次数即可 1234567891011121314151617181920212223// Parameters:// numbers: an array of integers// length: the length of array numbers// duplication: (Output) the duplicated number in the array number,length of duplication array is 1,so using duplication[0] = ? in implementation;// Here duplication like pointor in C/C++, duplication[0] equal *duplication in C/C++// 这里要特别注意~返回任意重复的一个，赋值duplication[0]// Return value: true if the input is valid, and there are some duplications in the array number// otherwise falsepublic boolean duplicate(int numbers[], int length, int[] duplication) &#123; if (numbers == null || numbers.length &lt; 2) return false; int[] map = new int[10]; for (int num : numbers) &#123; if (map[num]++ == 1) &#123; duplication[0] = num; return true; &#125; &#125; return false;&#125;","categories":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://lierabbit.cn/categories/剑指Offer/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"把字符串转换成整数","slug":"把字符串转换成整数","date":"2018-03-30T06:32:02.000Z","updated":"2018-08-26T12:54:51.802Z","comments":true,"path":"2018/03/30/把字符串转换成整数/","link":"","permalink":"https://lierabbit.cn/2018/03/30/把字符串转换成整数/","excerpt":"","text":"将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0 思路：取出字符串中每一位乘以相应的单位（个十百千万······）即可 12345678910111213141516171819202122232425262728293031323334353637public int StrToInt(String str) &#123; if (str == null || str.isEmpty()) return 0; char[] chars = str.toCharArray(); int left = 0; int right = chars.length - 1; boolean isPositive = true; // 默认正数 char first = chars[0]; // 正负号判断 if (first == '+') left = 1; else if (first == '-') &#123; left = 1; isPositive = false; &#125; int num = 0; int temp = 1; while (right &gt;= left) &#123; char chNum = chars[right]; if (!isNum(chNum)) return 0; num += (chNum % '0') * temp; temp *= 10; right--; &#125; return isPositive ? num : -num;&#125;// 是否是数字public boolean isNum(char num) &#123; return num &gt;= '0' &amp;&amp; num &lt;= '9';&#125;","categories":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://lierabbit.cn/categories/剑指Offer/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"不用加减乘除做加法","slug":"不用加减乘除做加法","date":"2018-03-30T05:49:06.000Z","updated":"2018-08-26T12:51:46.904Z","comments":true,"path":"2018/03/30/不用加减乘除做加法/","link":"","permalink":"https://lierabbit.cn/2018/03/30/不用加减乘除做加法/","excerpt":"","text":"写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。 思路：首先看十进制是如何做的： 5+7=12，分为三步第一步：相加各位的值，不算进位，得到2。第二步：计算进位值，得到10。如果这一步的进位值为0，那么第一步得到的值就是最终结果。第三步：重复上述两步，只是相加的值变成上述两步的得到的结果2和10，得到12。同样我们可以用三步的方式计算二进制值相加： 5的二进制为101，7的二进制为111第一步：相加各位的值，不算进位，得到010，二进制每位相加就相当于各位做异或操作，101^111。第二步：计算进位值，得到1010，相当于各位做与操作得到101，再向左移一位得到1010，(101&amp;111)&lt;&lt;1。第三步：重复上述两步， 各位相加 010^1010=1000，进位值为100=(010&amp;1010)&lt;&lt;1。继续重复上述两步：1000^100 = 1100，进位值为0，跳出循环，1100为最终结果。 123456789public int Add(int num1, int num2) &#123; while (num2 != 0) &#123; int temp = num1 ^ num2; // 不进位加法 num2 = (num1 &amp; num2) &lt;&lt; 1; // 进位 num1 = temp; &#125; return num1;&#125;","categories":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://lierabbit.cn/categories/剑指Offer/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"求1+2+3+...+n","slug":"求1-2-3-n","date":"2018-03-30T05:29:51.000Z","updated":"2018-08-26T12:49:41.941Z","comments":true,"path":"2018/03/30/求1-2-3-n/","link":"","permalink":"https://lierabbit.cn/2018/03/30/求1-2-3-n/","excerpt":"","text":"求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。 思路：利用“&amp;&amp;”运算的短路特点进行递归 1234public int Sum_Solution(int n) &#123; boolean a = (n &gt; 0) &amp;&amp; ((n += Sum_Solution(n - 1)) &gt; 0); return n;&#125;","categories":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://lierabbit.cn/categories/剑指Offer/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"孩子们的游戏","slug":"孩子们的游戏","date":"2018-03-30T05:16:06.000Z","updated":"2018-08-26T12:48:28.547Z","comments":true,"path":"2018/03/30/孩子们的游戏/","link":"","permalink":"https://lierabbit.cn/2018/03/30/孩子们的游戏/","excerpt":"","text":"每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1) 思路：按着游戏规则编码即可 123456789101112131415public int LastRemaining_Solution(int n, int m) &#123; if (n &lt;= 0 || m &lt;= 0) return -1; LinkedList&lt;Integer&gt; list = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; n; i++) list.add(i); int index = 0; while (list.size() &gt; 1) &#123; index = (index + m - 1) % list.size(); list.remove(index); &#125; return list.peek();&#125;","categories":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://lierabbit.cn/categories/剑指Offer/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"扑克牌顺子","slug":"扑克牌顺子","date":"2018-03-30T04:22:47.000Z","updated":"2018-08-26T12:45:18.685Z","comments":true,"path":"2018/03/30/扑克牌顺子/","link":"","permalink":"https://lierabbit.cn/2018/03/30/扑克牌顺子/","excerpt":"","text":"LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)…他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…..LL不高兴了,他想了想,决定大\\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何。为了方便起见,你可以认为大小王是0。 思路：如果是顺子必须满足以下条件 数组长度为5 不能有重复的 max - min + 1 &lt;= 5 例如[1,2,3,4,5],min=1,max=5,则5-1+1=5满足 12345678910111213141516171819202122public boolean isContinuous(int[] numbers) &#123; if (numbers == null || numbers.length != 5) return false; int max = -1; int min = 14; int[] map = new int[14]; for (int num : numbers) &#123; if (num == 0) continue; if (map[num]++ != 0) return false; max = Math.max(max, num); min = Math.min(min, num); if (max - min + 1 &gt; 5) return false; &#125; return true;&#125;","categories":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://lierabbit.cn/categories/剑指Offer/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"翻转单词顺序列","slug":"翻转单词顺序列","date":"2018-03-29T14:51:47.000Z","updated":"2018-08-26T12:44:18.741Z","comments":true,"path":"2018/03/29/翻转单词顺序列/","link":"","permalink":"https://lierabbit.cn/2018/03/29/翻转单词顺序列/","excerpt":"","text":"牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？ 思路：首先反转整个字符串，接着一个一个的反转局部单词即可 1234567891011121314151617181920212223242526272829303132public String ReverseSentence(String str) &#123; if (str == null || str.isEmpty()) return str; char[] chars = str.toCharArray(); int len = chars.length; reverse(chars, 0, len - 1); int l = -1; int r = -1; for (int i = 0; i &lt; len; i++) &#123; if (i == 0 || chars[i - 1] == ' ') l = i; if (i == len - 1 || chars[i + 1] == ' ') r = i; if (l != -1 &amp;&amp; r != -1) &#123; reverse(chars, l, r); l = -1; r = -1; &#125; &#125; return String.valueOf(chars);&#125;public void reverse(char[] chars, int left, int right) &#123; while (left &lt; right) swap(chars, left++, right--);&#125;public void swap(char[] chars, int i, int j) &#123; char temp = chars[i]; chars[i] = chars[j]; chars[j] = temp;&#125;","categories":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://lierabbit.cn/categories/剑指Offer/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"和为S的两个数字","slug":"和为S的两个数字","date":"2018-03-28T13:05:43.000Z","updated":"2018-08-26T12:42:23.711Z","comments":true,"path":"2018/03/28/和为S的两个数字/","link":"","permalink":"https://lierabbit.cn/2018/03/28/和为S的两个数字/","excerpt":"","text":"输入一个递增排序的数组和一个数字S，在数组中查找两个数，是的他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。 输出描述：对应每个测试案例，输出两个数，小的先输出。 思路：数列满足递增，相差越远乘积越小，则夹逼相加设两个头尾两个指针left和right若array[left] + array[right] == sum，就是答案若array[left] + array[right] &gt; sum，array[right]肯定不是答案之一（前面已得出 left 前面的数已是不可能），right -= 1若array[left] + array[right] &lt; sum，array[left]肯定不是答案之一（前面已得出 right 后面的数已是不可能），left += 1时间复杂度：O(n) 12345678910111213141516171819public ArrayList&lt;Integer&gt; FindNumbersWithSum(int[] array, int sum) &#123; ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if (array == null || array.length &lt; 2) return res; int left = 0; int right = array.length - 1; while (left &lt; right) &#123; if (array[left] + array[right] == sum) &#123; res.add(array[left]); res.add(array[right]); return res; &#125; else if (array[left] + array[right] &gt; sum) right--; else left++; &#125; return res;&#125;","categories":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://lierabbit.cn/categories/剑指Offer/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"和为S的连续正数序列","slug":"和为S的连续正数序列","date":"2018-03-27T03:08:40.000Z","updated":"2018-08-26T12:36:21.749Z","comments":true,"path":"2018/03/27/和为S的连续正数序列/","link":"","permalink":"https://lierabbit.cn/2018/03/27/和为S的连续正数序列/","excerpt":"","text":"小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck! 输出描述：输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序 思路：暴力破解，遍历求和。 123456789101112131415161718192021public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindContinuousSequence(int sum) &#123; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); if (sum &lt; 2) return res; for (int i = 1; i &lt;= sum / 2; i++) &#123; ArrayList&lt;Integer&gt; temp = new ArrayList&lt;&gt;(); int count = 0; for (int j = i; j &lt; sum; j++) &#123; count += j; temp.add(j); if (count &gt; sum) break; if (count == sum)&#123; res.add(temp); break; &#125; &#125; &#125; return res;&#125;","categories":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://lierabbit.cn/categories/剑指Offer/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"数组中只出现一次的数字","slug":"数组中只出现一次的数字","date":"2018-03-27T02:33:21.000Z","updated":"2018-08-26T12:33:50.032Z","comments":true,"path":"2018/03/27/数组中只出现一次的数字/","link":"","permalink":"https://lierabbit.cn/2018/03/27/数组中只出现一次的数字/","excerpt":"","text":"一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。 123456思路：整数n与0的异或结果为n，整数n与自己异或结果为0。令k1=0，arr中a和b出现了奇数次，剩下的数都出现了偶数次。则k1与arr中所有的数异或完成后，k1=a^b。因为a和b为不同的数，所以k1不为0。k1 = ·········1········· ↑ 32位整数第k位说明a和b的第k位，一定不一样。设置新整数k2=0。k2与arr中第k位为1的那些整数进行异或。异或完成后，k2为a或b中的一个。另一个数等于k2^k1。 123456789101112public void FindNumsAppearOnce(int[] array, int num1[], int num2[]) &#123; int k1 = 0; int k2 = 0; for (int a : array) k1 ^= a; // 最后k1为两数字的异或结果 int rightOne = k1 &amp; (~k1 + 1); // 二进制右边第一个1 for (int a : array) if ((a &amp; rightOne) != 0) k2 ^= a; // 最后k2为其中一个数字 num1[0] = k2; num2[0] = k1 ^ k2;&#125;","categories":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://lierabbit.cn/categories/剑指Offer/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"平衡二叉树","slug":"平衡二叉树","date":"2018-03-26T13:27:20.000Z","updated":"2018-08-26T12:26:41.148Z","comments":true,"path":"2018/03/26/平衡二叉树/","link":"","permalink":"https://lierabbit.cn/2018/03/26/平衡二叉树/","excerpt":"","text":"输入一棵二叉树，判断该二叉树是否是平衡二叉树。 思路：递归获取左右子树深度判断高度差是否大于1 123456789101112131415161718public boolean IsBalanced_Solution(TreeNode root) &#123; return isBalanced(root) != -1;&#125;public int isBalanced(TreeNode node) &#123; if (node == null) return 0; int left = isBalanced(node.left); if (left == -1) return -1; int right = isBalanced(node.right); if (right == -1) return -1; if (Math.abs(left - right) &gt; 1) return -1; else return Math.max(left, right) + 1;&#125;","categories":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://lierabbit.cn/categories/剑指Offer/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"数组中逆序对","slug":"数组中逆序对","date":"2018-03-25T12:49:34.000Z","updated":"2018-08-26T12:25:06.620Z","comments":true,"path":"2018/03/25/数组中逆序对/","link":"","permalink":"https://lierabbit.cn/2018/03/25/数组中逆序对/","excerpt":"","text":"在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007 思路：把数据分成前后两个数组(递归分到每个数组仅有一个数据项)，合并数组，合并时，出现前面的数组值arr[l]大于后面数组值arr[r]时；则前面数组arr[l]~arr[mid]都是大于arr[r]的，count += mid+1 - l。其实就是归并排序 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class 数组中逆序对 &#123; class Count &#123; private int value; public Count() &#123; value = 0; &#125; public void increment() &#123; value++; &#125; &#125; public int InversePairs(int[] array) &#123; Count count = new Count(); inverse(array, 0, array.length - 1, count); return count.value; &#125; public void inverse(int[] array, int left, int right, Count count) &#123; if (left != right) &#123; int mid = left + (right - left) / 2; inverse(array, left, mid, count); inverse(array, mid + 1, right, count); inverseCore(array, left, mid, right, count); &#125; &#125; public void inverseCore(int[] arr, int left, int mid, int right, Count count) &#123; int[] temp = new int[right - left + 1]; int l = left; int r = mid + 1; int index = 0; while (l &lt;= mid &amp;&amp; r &lt;= right) &#123; if (arr[l] &gt; arr[r]) &#123; count.value = (count.value + mid - l + 1) % 1000000007; // 核心计算 temp[index++] = arr[r++]; &#125; else &#123; temp[index++] = arr[l++]; &#125; &#125; while (l &lt;= mid) temp[index++] = arr[l++]; while (r &lt;= right) temp[index++] = arr[r++]; for (int i = 0; i &lt; index; i++) arr[left + i] = temp[i]; &#125; public static void main(String[] args) &#123; int[] arr = &#123;1, 2, 3, 4, 5, 6, 7, 0&#125;; 数组中逆序对 test = new 数组中逆序对(); int res = test.InversePairs(arr); System.out.println(res); &#125;&#125;","categories":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://lierabbit.cn/categories/剑指Offer/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"左旋字符串","slug":"左旋字符串","date":"2018-03-25T05:55:36.000Z","updated":"2018-08-26T12:23:17.256Z","comments":true,"path":"2018/03/25/左旋字符串/","link":"","permalink":"https://lierabbit.cn/2018/03/25/左旋字符串/","excerpt":"","text":"汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！ 思路：左移几位就是把几位放到字符串后面，如果左移位数超过字符串长度则对长度取余 12345678910public String LeftRotateString(String str, int k) &#123; if(str == null) return null; int len = str.length(); if(len == 0) return \"\"; k %= len; return str.substring(k, len) + str.substring(0, k);&#125;","categories":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://lierabbit.cn/categories/剑指Offer/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"二叉树的深度","slug":"二叉树的深度","date":"2018-03-24T15:44:35.000Z","updated":"2018-08-26T12:21:57.907Z","comments":true,"path":"2018/03/24/二叉树的深度/","link":"","permalink":"https://lierabbit.cn/2018/03/24/二叉树的深度/","excerpt":"","text":"输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。 思路：递归遍历 123456public int TreeDepth(TreeNode root) &#123; if (root == null) return 0; else return 1 + Math.max(TreeDepth(root.left), TreeDepth(root.right));&#125;","categories":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://lierabbit.cn/categories/剑指Offer/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"两个链表的第一个公共节点","slug":"两个链表的第一个公共节点","date":"2018-03-23T15:23:55.000Z","updated":"2018-08-26T12:19:37.160Z","comments":true,"path":"2018/03/23/两个链表的第一个公共节点/","link":"","permalink":"https://lierabbit.cn/2018/03/23/两个链表的第一个公共节点/","excerpt":"","text":"输入两个链表，找出它们的第一个公共结点。 找出2个链表的长度，然后让长的先走两个链表的长度差，然后再一起走1234567891011121314151617181920212223242526272829303132333435363738394041public ListNode FindFirstCommonNode(ListNode pHead1, ListNode pHead2) &#123; if (pHead1 == null || pHead2 == null) return null; int count1 = 0; int count2 = 0; ListNode node1 = pHead1; while (node1 != null) &#123; count1++; node1 = node1.next; &#125; ListNode node2 = pHead2; while (node2 != null) &#123; count2++; node2 = node2.next; &#125; node1 = pHead1; node2 = pHead2; int count3; if (count1 &gt; count2) &#123; count3 = count1 - count2; while (count3 &gt; 0) &#123; count3--; node1 = node1.next; &#125; &#125; else &#123; count3 = count2 - count1; while (count3 &gt; 0) &#123; count3--; node2 = node2.next; &#125; &#125; while (node1 != null) &#123; if (node1 == node2) return node1; node1 = node1.next; node2 = node2.next; &#125; return null;&#125; 用两个指针扫描”两个链表“，最终两个指针到达 null 或者到达公共结点。1234567891011121314public ListNode FindFirstCommonNode2(ListNode pHead1, ListNode pHead2) &#123; if (pHead1 == null || pHead2 == null) return null; ListNode node1 = pHead1; ListNode node2 = pHead2; while (node1 != node2) &#123; node1 = node1 == null ? pHead1 : node1.next; node2 = node2 == null ? pHead2 : node2.next; &#125; return node1;&#125;","categories":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://lierabbit.cn/categories/剑指Offer/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"丑数","slug":"丑数","date":"2018-03-22T15:46:56.000Z","updated":"2018-08-26T12:14:19.352Z","comments":true,"path":"2018/03/22/丑数/","link":"","permalink":"https://lierabbit.cn/2018/03/22/丑数/","excerpt":"","text":"把只包含因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。 思路：丑数的定义是1或者因子只有2 3 5，可推出丑数=丑数丑数，假定丑数有序序列为：a1,a2,a3…….an所以可以将以上序列（a1除外）可以分成3类，必定满足：包含2的有序丑数序列：2a1, 2a2, 2a3 …..包含3的有序丑数序列：3a1, 3a2, 3a3 …..包含5的有序丑数序列：5a1, 5a2, 5a3 …..以上3个序列的个数总数和为n个，而且已知a1 = 1了，将以上三个序列合并成一个有序序列即可程序中m2,m3,m5实际就是合并过程中三个序列的索引 123456789101112131415161718public int GetUglyNumber_Solution(int index) &#123; if (index &lt; 7) return index; int m2 = 0, m3 = 0, m5 = 0; int[] arr = new int[index]; arr[0] = 1; for (int i = 1; i &lt; index; i++) &#123; arr[i] = Math.min(arr[m2] * 2, Math.min(arr[m3] * 3, arr[m5] * 5)); if (arr[i] == arr[m2] * 2) m2++; if (arr[i] == arr[m3] * 3) m3++; if (arr[i] == arr[m5] * 5) m5++; &#125; return arr[index - 1];&#125;","categories":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://lierabbit.cn/categories/剑指Offer/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"第一个只出现一次的字符","slug":"第一个只出现一次的字符","date":"2018-03-21T15:02:37.000Z","updated":"2018-08-26T12:13:24.807Z","comments":true,"path":"2018/03/21/第一个只出现一次的字符/","link":"","permalink":"https://lierabbit.cn/2018/03/21/第一个只出现一次的字符/","excerpt":"","text":"在一个字符串(1&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置 思路：使用hashMap（用数组模拟）进行字数统计 第一次遍历字符串统计每个字符出现的次数，使用map（键值对的形式）保存 第二次遍历字符串通过map找出第一个只出现一次的字符 123456789101112public int FirstNotRepeatingChar(String str) &#123; int len = str.length(); int[] map = new int[256]; for (int i = 0; i &lt; len; i++) &#123; map[str.charAt(i)]++; &#125; for (int i = 0; i &lt; len; i++) &#123; if (map[str.charAt(i)] == 1) return i; &#125; return -1;&#125;","categories":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://lierabbit.cn/categories/剑指Offer/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"把数组排成最小的数","slug":"把数组排成最小的数","date":"2018-03-20T14:51:10.000Z","updated":"2018-08-26T12:09:39.009Z","comments":true,"path":"2018/03/20/把数组排成最小的数/","link":"","permalink":"https://lierabbit.cn/2018/03/20/把数组排成最小的数/","excerpt":"","text":"输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。 思路：将数字转化为字符串，有字符串a和b，若a+b&lt;b+a，则a在前b在后。 1234567891011public String PrintMinNumber(int[] numbers) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); for (int num : numbers) list.add(String.valueOf(num)); list.sort((a, b) -&gt; (a + b).compareTo(b + a)); StringBuilder sb = new StringBuilder(); for (String str : list) sb.append(str); return sb.toString();&#125;","categories":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://lierabbit.cn/categories/剑指Offer/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"整数中1出现的次数","slug":"整数中1出现的次数","date":"2018-03-19T07:03:13.000Z","updated":"2018-08-26T12:08:05.008Z","comments":true,"path":"2018/03/19/整数中1出现的次数/","link":"","permalink":"https://lierabbit.cn/2018/03/19/整数中1出现的次数/","excerpt":"","text":"求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数。 暴力计算1234567891011121314public int NumberOf1Between1AndN_Solution(int n) &#123; int count = 0; for (int i = 1; i &lt;= n; i++) &#123; int temp = i; while(temp != 0)&#123; if(temp % 10 == 1)&#123; count++; &#125; temp /= 10; &#125; &#125; return count;&#125;","categories":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://lierabbit.cn/categories/剑指Offer/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"连续子数组的最大和","slug":"连续子数组的最大和","date":"2018-03-19T06:33:15.000Z","updated":"2018-08-26T11:53:55.000Z","comments":true,"path":"2018/03/19/连续子数组的最大和/","link":"","permalink":"https://lierabbit.cn/2018/03/19/连续子数组的最大和/","excerpt":"","text":"HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。你会不会被他忽悠住？(子向量的长度至少是1) 思路：使用动态规划，dp[i]代表以array[i]为结尾的连续子向量最大和 1234567891011121314151617181920public int FindGreatestSumOfSubArray(int[] array) &#123; if (array == null || array.length == 0) return 0; int[] dp = new int[array.length]; dp[0] = array[0]; int max = dp[0]; for (int i = 1; i &lt; array.length; i++) &#123; if (dp[i - 1] &gt; 0) &#123; dp[i] = dp[i - 1] + array[i]; &#125; else &#123; dp[i] = array[i]; &#125; if (dp[i] &gt; max) max = dp[i]; &#125; return max;&#125; 由上面优化而来，使用sum代替dp，sum是以array[i]为结尾的连续子向量最大和 123456789101112131415161718public int FindGreatestSumOfSubArray2(int[] array) &#123; if (array == null || array.length == 0) return 0; int sum = array[0]; int max = sum; for (int i = 1; i &lt; array.length; i++) &#123; if (sum &gt; 0) &#123; sum += array[i]; &#125; else &#123; sum = array[i]; &#125; if (sum &gt; max) max = sum; &#125; return max;&#125;","categories":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://lierabbit.cn/categories/剑指Offer/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"数组中出现次数超过一半的数字","slug":"数组中出现次数超过一半的数字","date":"2018-03-19T05:58:42.000Z","updated":"2018-08-26T11:52:47.826Z","comments":true,"path":"2018/03/19/数组中出现次数超过一半的数字/","link":"","permalink":"https://lierabbit.cn/2018/03/19/数组中出现次数超过一半的数字/","excerpt":"","text":"数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。 思路：采用阵地攻守的思想，第一个数字作为第一个士兵，守阵地；count = 1。遇到相同元素，count++。遇到不相同元素，即为敌人，同归于尽,count–。当遇到count为0的情况，又以新的i值作为守阵地的士兵，继续下去，到最后还留在阵地上的士兵，有可能是主元素。再加一次循环，记录这个士兵的个数看是否大于数组一半即可。 12345678910111213141516171819202122232425262728public int MoreThanHalfNum_Solution(int[] array) &#123; if (array == null || array.length == 0) return 0; else if (array.length == 1) return array[0]; int length = array.length; int count = 1; int res = array[0]; for (int i = 1; i &lt; length; i++) &#123; if (count == 0) &#123; res = array[i]; count = 1; &#125; else &#123; if (res == array[i]) count++; else count--; &#125; &#125; count = 0; for (int a : array) if (res == a) count++; return count &gt; length / 2 ? res : 0;&#125;","categories":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://lierabbit.cn/categories/剑指Offer/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"字符串的排列","slug":"字符串的排列","date":"2018-03-19T05:36:16.000Z","updated":"2018-08-26T11:48:59.292Z","comments":true,"path":"2018/03/19/字符串的排列/","link":"","permalink":"https://lierabbit.cn/2018/03/19/字符串的排列/","excerpt":"","text":"输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。 输入描述输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。 思路：回溯法 123456789101112131415161718192021222324252627282930public ArrayList&lt;String&gt; Permutation(String str) &#123; ArrayList&lt;String&gt; res = new ArrayList&lt;&gt;(); if (str == null || str.length() == 0) return res; HashSet&lt;String&gt; set = new HashSet&lt;&gt;(); permutation(str.toCharArray(), 0, set); res.addAll(set); Collections.sort(res); return res;&#125;public void permutation(char[] chars, int index, HashSet&lt;String&gt; set) &#123; int length = chars.length; if (index == length - 1) &#123; set.add(String.valueOf(chars)); &#125; else &#123; for (int i = index; i &lt; length; i++) &#123; swap(chars, i, index); permutation(chars, index + 1, set); swap(chars, i, index); &#125; &#125;&#125;public void swap(char[] chars, int i, int j) &#123; char temp = chars[i]; chars[i] = chars[j]; chars[j] = temp;&#125;","categories":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://lierabbit.cn/categories/剑指Offer/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"二叉树搜索与双向链表","slug":"二叉树搜索与双向链表","date":"2018-03-18T12:57:48.000Z","updated":"2018-08-26T11:46:57.741Z","comments":true,"path":"2018/03/18/二叉树搜索与双向链表/","link":"","permalink":"https://lierabbit.cn/2018/03/18/二叉树搜索与双向链表/","excerpt":"","text":"输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。 思路：使用中序遍历，用cur和pre分别记录当前遍历节点和上一个节点，然后双向连接形成双向链表 12345678910111213141516171819202122232425262728public TreeNode Convert(TreeNode pRootOfTree) &#123; if (pRootOfTree == null) return null; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode cur = pRootOfTree; TreeNode pre = null; TreeNode head = null; while (cur != null || !stack.empty()) &#123; if (cur == null) &#123; TreeNode node = stack.pop(); if (head == null) head = node; if (pre != null) &#123; pre.right = node; node.left = pre; &#125; pre = node; cur = node.right; &#125; else &#123; stack.add(cur); cur = cur.left; &#125; &#125; return head;&#125;","categories":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://lierabbit.cn/categories/剑指Offer/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"顺时针打印矩阵","slug":"顺时针打印矩阵","date":"2018-03-17T14:08:24.000Z","updated":"2018-08-26T11:42:47.820Z","comments":true,"path":"2018/03/17/顺时针打印矩阵/","link":"","permalink":"https://lierabbit.cn/2018/03/17/顺时针打印矩阵/","excerpt":"","text":"输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10. 思路：处理好四个角落即可 123456789101112131415161718192021222324252627282930313233343536373839public ArrayList&lt;Integer&gt; printMatrix(int[][] matrix) &#123; ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if (matrix == null) return res; int row = matrix.length; if (row == 0) return res; int col = matrix[0].length; if (col == 0) return res; int top = 0; int bottom = row - 1; int left = 0; int right = col - 1; while (top &lt;= bottom &amp;&amp; left &lt;= right) &#123; // 从左往右 for (int i = left; i &lt;= right; i++) res.add(matrix[top][i]); // 从上到下 for (int i = top + 1; i &lt;= bottom; i++) res.add(matrix[i][right]); // 从右往左，当top==bottom时和从左往右重复了 for (int i = right - 1; i &gt;= left &amp;&amp; top != bottom; i--) res.add(matrix[bottom][i]); // 从下到上，当right==left时和从上到下重复了 for (int i = bottom - 1; i &gt; top &amp;&amp; right != left; i--) res.add(matrix[i][left]); top++; left++; right--; bottom--; &#125; return res;&#125;","categories":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://lierabbit.cn/categories/剑指Offer/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"最小的K个数","slug":"最小的K个数","date":"2018-03-16T15:09:53.000Z","updated":"2018-08-26T11:39:19.351Z","comments":true,"path":"2018/03/16/最小的K个数/","link":"","permalink":"https://lierabbit.cn/2018/03/16/最小的K个数/","excerpt":"","text":"输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4。 思路：用最大堆保存这k个数，每次只和堆顶比，如果比堆顶小，删除堆顶，新数入堆，调整大根堆 123456789101112131415161718192021222324252627282930313233343536373839404142434445public ArrayList&lt;Integer&gt; GetLeastNumbers_Solution(int[] input, int k) &#123; ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if (input == null || k &lt; 0 || k &gt; input.length) return res; // 建立大根堆 for (int i = k / 2 - 1; i &gt;= 0; i--) &#123; adjustHeap(input, i, k); &#125; // 依次与堆顶对比 for (int i = k; i &lt; input.length; i++) &#123; if (input[i] &lt; input[0]) &#123; swap(input, 0, i); adjustHeap(input, 0, k); &#125; &#125; for (int i = 0; i &lt; k; i++) res.add(input[i]); return res;&#125;public void adjustHeap(int[] heap, int index, int length) &#123; int node = heap[index]; for (int i = index * 2 + 1; i &lt; length; i = i * 2 + 1) &#123; if (i + 1 &lt; length &amp;&amp; heap[i + 1] &gt; heap[i]) i++; if (node &lt; heap[i]) &#123; heap[index] = heap[i]; index = i; &#125; else break; &#125; heap[index] = node;&#125;public void swap(int[] arr, int i, int j) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp;&#125;","categories":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://lierabbit.cn/categories/剑指Offer/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"数字在排序数组中出现的次数","slug":"数字在排序数组中出现的次数","date":"2018-03-13T14:04:11.000Z","updated":"2018-08-26T11:37:35.750Z","comments":true,"path":"2018/03/13/数字在排序数组中出现的次数/","link":"","permalink":"https://lierabbit.cn/2018/03/13/数字在排序数组中出现的次数/","excerpt":"","text":"统计一个数字在排序数组中出现的次数。统计一个数字在排序数组中出 思路：看见有序使用二分查找，分别找出第一个下标(first)与最后一个下标(last)，然后last-first+1即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public int GetNumberOfK(int[] array, int k) &#123; if (array == null || array.length == 0) return 0; else &#123; int first = getFirstNum(array, k); if (first == -1) return 0; int last = getLastNum(array, k); return last - first + 1; &#125;&#125;public int getFirstNum(int[] array, int k) &#123; int left = 0; int right = array.length - 1; int mid; int index = -1; while (left &lt;= right) &#123; mid = left + (right - left) / 2; if (array[mid] &lt; k) left = mid + 1; else if (array[mid] &gt; k) right = mid - 1; else &#123; index = mid; right = mid - 1; &#125; &#125; return index;&#125;public int getLastNum(int[] array, int k) &#123; int left = 0; int right = array.length - 1; int mid; int index = -1; while (left &lt;= right) &#123; mid = left + (right - left) / 2; if (array[mid] &lt; k) left = mid + 1; else if (array[mid] &gt; k) right = mid - 1; else &#123; index = mid; left = mid + 1; &#125; &#125; return index;&#125;","categories":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://lierabbit.cn/categories/剑指Offer/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"二叉树中和为某一值的路径","slug":"二叉树中和为某一值的路径","date":"2018-03-12T11:26:27.000Z","updated":"2018-08-26T11:35:04.547Z","comments":true,"path":"2018/03/12/二叉树中和为某一值的路径/","link":"","permalink":"https://lierabbit.cn/2018/03/12/二叉树中和为某一值的路径/","excerpt":"","text":"输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。 思路：深度递归遍历，类似于先序遍历 12345678910111213141516171819202122public class Solution &#123; private ArrayList&lt;ArrayList&lt;Integer&gt;&gt; allList = new ArrayList&lt;&gt;(); private ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root, int target) &#123; if (root == null) return allList; target -= root.val; list.add(root.val); if (target == 0 &amp;&amp; root.left == null &amp;&amp; root.right == null) allList.add(new ArrayList&lt;&gt;(list)); FindPath(root.left, target); FindPath(root.right, target); list.remove(list.size() - 1); // 弹出最后一个数 return allList; &#125;&#125;","categories":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://lierabbit.cn/categories/剑指Offer/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"复杂链表的复制","slug":"复杂链表的复制-1","date":"2018-03-12T10:29:35.000Z","updated":"2018-08-26T11:34:01.546Z","comments":true,"path":"2018/03/12/复杂链表的复制-1/","link":"","permalink":"https://lierabbit.cn/2018/03/12/复杂链表的复制-1/","excerpt":"","text":"输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空） 思路：使用在原始元素后面插入克隆元素解决难以设置随机指针问题，第一次遍历在每个元素后面添加一个克隆元素，第二次遍历设置克隆元素的随机指针即原随机指针的下一个，第三次遍历分割出克隆链表 12345678910111213141516171819202122232425262728293031323334353637383940414243class RandomListNode &#123; int label; RandomListNode next = null; RandomListNode random = null; RandomListNode(int label) &#123; this.label = label; &#125;&#125;public class 复杂链表的复制 &#123; public RandomListNode Clone(RandomListNode pHead) &#123; if (pHead == null) return null; RandomListNode cur = pHead; RandomListNode newNode; while (cur != null) &#123; // 在链表每个元素后面添加一个克隆元素 newNode = new RandomListNode(cur.label); newNode.next = cur.next; cur.next = newNode; cur = newNode.next; &#125; cur = pHead; while (cur != null) &#123; // 给每个克隆元素设置随机指针 newNode = cur.next; newNode.random = cur.random == null ? null : cur.random.next; cur = cur.next.next; &#125; cur = pHead; RandomListNode newHead = pHead.next; RandomListNode next; while (cur != null) &#123; // 分割出克隆链表，还原原链表 next = cur.next.next; newNode = cur.next; newNode.next = next == null ? null : next.next; cur.next = next; cur = next; &#125; return newHead; &#125;&#125;","categories":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://lierabbit.cn/categories/剑指Offer/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"二叉搜索树的后序遍历序列","slug":"二叉搜索树的后序遍历序列","date":"2018-03-09T15:50:21.000Z","updated":"2018-08-26T11:30:49.620Z","comments":true,"path":"2018/03/09/二叉搜索树的后序遍历序列/","link":"","permalink":"https://lierabbit.cn/2018/03/09/二叉搜索树的后序遍历序列/","excerpt":"","text":"输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。 思路：递归实现检测，对于后序遍历来说，序列数组的最后一个元素一定是根节点，则根据这个元素，将前面的数组分为左、右两个部分，左侧部分都小，右侧部分都大，如果右侧部分有比该根节点小的元素，那么就不是后序遍历,如此递归进行 1234567891011121314151617181920212223242526272829303132333435363738public boolean VerifySquenceOfBST(int[] sequence) &#123; if (sequence == null || sequence.length == 0) &#123; return false; &#125; boolean flag = this.isBST(sequence, 0, sequence.length - 1); return flag;&#125;/** * 递归实现检测 * 对于后序遍历来说，序列数组的最后一个元素一定是根节点, * 则根据这个元素，将前面的数组分为左、右两个部分，左侧部分都小，右侧部分都大， * 如果右侧部分有比该根节点小的元素，那么就不是后序遍历,如此递归进行 * * @param arr * @param start * @param end * @return */public boolean isBST(int[] arr, int start, int end) &#123; if (start &gt;= end) &#123; return true; &#125; // 当前数组(从start到end部分)的根节点 int curElement = arr[end]; int splitIndex; // 找到比curElement大和比curElement小的分界点,分成左侧、右侧两组数据 for (splitIndex = start; splitIndex &lt; end &amp;&amp; arr[splitIndex] &lt; curElement; splitIndex++) ; // 只需要看右侧即可，因为前面的for循环，已经确保左侧部分全部都小于curElement for (int i = splitIndex; i &lt; end; i++) &#123; if (arr[i] &lt; curElement) &#123; return false; &#125; &#125; return isBST(arr, start, splitIndex - 1) &amp;&amp; isBST(arr, splitIndex, end - 1);&#125;","categories":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://lierabbit.cn/categories/剑指Offer/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"从上往下打印二叉树","slug":"从上往下打印二叉树","date":"2018-03-08T03:09:09.000Z","updated":"2018-08-26T11:29:34.177Z","comments":true,"path":"2018/03/08/从上往下打印二叉树/","link":"","permalink":"https://lierabbit.cn/2018/03/08/从上往下打印二叉树/","excerpt":"","text":"从上往下打印出二叉树的每个节点，同层节点从左至右打印。 思路：使用队列从左到右依次保存孩子节点 1234567891011121314151617public ArrayList&lt;Integer&gt; PrintFromTopToBottom(TreeNode root) &#123; TreeNode node; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); if (root != null) queue.add(root); ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;(); while (!queue.isEmpty()) &#123; node = queue.poll(); if (node.left != null) queue.add(node.left); if (node.right != null) queue.add(node.right); res.add(node.val); &#125; return res;&#125;","categories":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://lierabbit.cn/categories/剑指Offer/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"栈的压入弹出序列","slug":"栈的压入弹出序列","date":"2018-03-07T15:52:21.000Z","updated":"2018-08-26T11:27:12.652Z","comments":true,"path":"2018/03/07/栈的压入弹出序列/","link":"","permalink":"https://lierabbit.cn/2018/03/07/栈的压入弹出序列/","excerpt":"","text":"输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的） 思路：借用一个辅助的栈，遍历压栈顺序，先讲第一个放入栈中，这里是1，然后判断栈顶元素是不是出栈顺序的第一个元素，这里是4，很显然1≠4，所以我们继续压栈，直到相等以后开始出栈，出栈一个元素，则将出栈顺序向后移动一位，直到不相等，这样循环等压栈顺序遍历完成，如果辅助栈还不为空，说明弹出序列不是该栈的弹出顺序。 举例：入栈1,2,3,4,5出栈4,5,3,2,1首先1入辅助栈，此时栈顶1≠4，继续入栈2此时栈顶2≠4，继续入栈3此时栈顶3≠4，继续入栈4此时栈顶4＝4，出栈4，弹出序列向后一位，此时为5，,辅助栈里面是1,2,3此时栈顶3≠5，继续入栈5此时栈顶5=5，出栈5,弹出序列向后一位，此时为3，,辅助栈里面是1,2,3······依次执行，最后辅助栈为空。如果不为空说明弹出序列不是该栈的弹出顺序。 12345678910111213public boolean IsPopOrder(int[] pushA, int[] popA) &#123; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); int popIndex = 0; for (int aPushA : pushA) &#123; stack.add(aPushA); while (!stack.empty() &amp;&amp; stack.peek() == popA[popIndex]) &#123; stack.pop(); popIndex++; &#125; &#125; return stack.empty();&#125;","categories":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://lierabbit.cn/categories/剑指Offer/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"可查询最值的栈","slug":"可查询最值的栈-1","date":"2018-03-06T15:21:34.000Z","updated":"2018-08-26T11:23:26.719Z","comments":true,"path":"2018/03/06/可查询最值的栈-1/","link":"","permalink":"https://lierabbit.cn/2018/03/06/可查询最值的栈-1/","excerpt":"","text":"定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的min函数。 思路：用一个栈data保存数据，用另外一个min栈保存依次入栈最小的数比如，data中依次入栈，5, 4, 3, 8, 10, 11, 12, 1则min依次入栈，5, 4, 3，no,no, no, no, 1no代表此次不如栈，每次入栈的时候，如果入栈的元素比min中的栈顶元素小或等于则入栈，否则不如栈。 1234567891011121314151617181920212223242526public class 包含min函数的栈 &#123; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); Stack&lt;Integer&gt; minStack = new Stack&lt;&gt;(); public void push(int node) &#123; stack.add(node); if (minStack.empty()) minStack.add(node); else if (node &lt;= minStack.peek()) minStack.add(node); &#125; public void pop() &#123; int value = stack.pop(); if (value == minStack.peek()) minStack.pop(); &#125; public int top() &#123; return stack.peek(); &#125; public int min() &#123; return minStack.peek(); &#125;&#125;","categories":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://lierabbit.cn/categories/剑指Offer/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"二叉树的镜像","slug":"二叉树的镜像","date":"2018-03-05T13:44:45.000Z","updated":"2018-08-26T11:22:15.889Z","comments":true,"path":"2018/03/05/二叉树的镜像/","link":"","permalink":"https://lierabbit.cn/2018/03/05/二叉树的镜像/","excerpt":"","text":"操作给定的二叉树，将其变换为源二叉树的镜像。 123456789101112二叉树的镜像定义：源二叉树 8 / \\ 6 10 / \\ / \\ 5 7 9 11 镜像二叉树 8 / \\ 10 6 / \\ / \\ 11 9 7 5 思路：递归左右颠倒即可 1234567891011public void Mirror(TreeNode root) &#123; if (root != null) &#123; TreeNode temp = root.left; root.left = root.right; root.right = temp; if (root.left != null) Mirror(root.left); if (root.right != null) Mirror(root.right); &#125;&#125;","categories":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://lierabbit.cn/categories/剑指Offer/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"树的子结构","slug":"树的子结构","date":"2018-03-04T15:22:53.000Z","updated":"2018-08-26T11:16:30.161Z","comments":true,"path":"2018/03/04/树的子结构/","link":"","permalink":"https://lierabbit.cn/2018/03/04/树的子结构/","excerpt":"","text":"输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构） 思路：遍历树找到第一个相同节点，以该节点为根搜索它们左右孩子是否一致 123456789101112131415161718192021222324252627282930313233public boolean HasSubtree(TreeNode root1, TreeNode root2) &#123; boolean res = false; // 当Tree1和Tree2都不为空的时候，才进行比较。否则直接返回false if (root1 != null &amp;&amp; root2 != null) &#123; // 如果找到了对应Tree2的根节点的点 if (root1.val == root2.val) // 以这个根节点为起点判断是否包含Tree2 res = isSubTree(root1, root2); // 如果找不到，那么就把root1的左孩子当作起点，去判断是否包含Tree2 if (!res) res = HasSubtree(root1.left, root2); // 如果还找不到，那么就再去root1的右孩子当作起点，去判断是否包含Tree2 if (!res) res = HasSubtree(root1.right, root2); &#125; return res;&#125;public boolean isSubTree(TreeNode node1, TreeNode node2) &#123; // 如果Tree2已经遍历完了都能对应的上，返回true if (node2 == null) return true; // 如果Tree2还没有遍历完，Tree1却遍历完了。返回false else if (node1 == null) return false; // 如果其中有一个点没有对应上，返回false else if (node1.val != node2.val) return false; // 如果根节点对应的上，那么就分别去子节点里面匹配 else return isSubTree(node1.left, node2.left) &amp;&amp; isSubTree(node1.right, node2.right);&#125;","categories":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://lierabbit.cn/categories/剑指Offer/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"Spring-IOC/DI主线","slug":"Spring-IOC-DI主线","date":"2018-03-04T08:19:21.000Z","updated":"2018-08-26T11:14:12.788Z","comments":true,"path":"2018/03/04/Spring-IOC-DI主线/","link":"","permalink":"https://lierabbit.cn/2018/03/04/Spring-IOC-DI主线/","excerpt":"","text":"IOC/DI主线 Bean生命周期","categories":[{"name":"Java从深入到放弃","slug":"Java从深入到放弃","permalink":"https://lierabbit.cn/categories/Java从深入到放弃/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://lierabbit.cn/tags/Spring/"}]},{"title":"合并两个排序的链表","slug":"合并两个排序的链表","date":"2018-03-04T06:12:58.000Z","updated":"2018-09-09T13:17:35.296Z","comments":true,"path":"2018/03/04/合并两个排序的链表/","link":"","permalink":"https://lierabbit.cn/2018/03/04/合并两个排序的链表/","excerpt":"","text":"输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。 思路：先比较头节点，然后递归比较剩下的 123456789101112131415161718public ListNode Merge(ListNode node1, ListNode node2) &#123; if (node1 == null) return node2; else if (node2 == null) return node1; ListNode node; if (node1.val &lt; node2.val) &#123; node = node1; node.next = Merge(node1.next, node2); &#125; else &#123; node = node2; node.next = Merge(node1, node2.next); &#125; return node;&#125;","categories":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://lierabbit.cn/categories/剑指Offer/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"反转链表","slug":"反转链表","date":"2018-03-04T05:32:45.000Z","updated":"2018-08-26T11:01:36.222Z","comments":true,"path":"2018/03/04/反转链表/","link":"","permalink":"https://lierabbit.cn/2018/03/04/反转链表/","excerpt":"","text":"输入一个链表，反转链表后，输出链表的所有元素。 思路：反序的过程整个链表分成两个部分，前面的代表已反序，后面的代表待反序，反序和待反序是断开的，所以要注意保存这两条链表的头节点ListNode next = null;//用来保存待反序的第一个节点（head 和 next节点）ListNode pre = null;//用来保存已经反序的第一个结点 12345678910111213public ListNode ReverseList(ListNode head) &#123; ListNode pre = null; ListNode next; while (head != null) &#123; next = head.next; head.next = pre; pre = head; head = next; &#125; return pre;&#125;","categories":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://lierabbit.cn/categories/剑指Offer/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"链表中倒数第k个节点","slug":"链表中倒数第k个节点","date":"2018-03-04T05:09:59.000Z","updated":"2018-08-26T09:50:23.587Z","comments":true,"path":"2018/03/04/链表中倒数第k个节点/","link":"","permalink":"https://lierabbit.cn/2018/03/04/链表中倒数第k个节点/","excerpt":"","text":"输入一个链表，输出该链表中倒数第k个结点。 思路：使用pre,cur两个指针，初始化都为头节点，让pre先走k-1步，若中途走到尾了则没有倒数第K个节点，因为k&gt;链表长度。然后再让两个指针同时走，当pre到尾了则cur就是倒数第K个节点 1234567891011121314151617181920212223public ListNode FindKthToTail(ListNode head, int k) &#123; if (head == null || k &lt;= 0) return null; ListNode pre = head; // 先走的指针 ListNode cur = head; // 当前的指针 // pre先走k-1步 for (int i = 0; i &lt; k - 1; i++) &#123; if (pre.next != null) pre = pre.next; else return null; &#125; // 当pre到尾cur就是倒数第K个节点 while (pre.next != null) &#123; pre = pre.next; cur = cur.next; &#125; return cur;&#125;","categories":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://lierabbit.cn/categories/剑指Offer/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"调整数组顺序使奇数位于偶数前面","slug":"调整数组顺序使奇数位于偶数前面","date":"2018-03-04T04:14:13.000Z","updated":"2018-08-26T09:48:42.472Z","comments":true,"path":"2018/03/04/调整数组顺序使奇数位于偶数前面/","link":"","permalink":"https://lierabbit.cn/2018/03/04/调整数组顺序使奇数位于偶数前面/","excerpt":"","text":"输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。 思路：首先统计奇数的个数，然后新建一个等长数组，设置两个指针，奇数指针从0开始，偶数指针从奇数个数的末尾开始 遍历，填数 1234567891011121314151617181920public void reOrderArray(int[] array) &#123; if (array == null || array.length == 0 || array.length == 1) return; int count = 0; // 记录奇数出现次数 for (int a : array) if (a % 2 == 1) count++; int[] temp = new int[array.length]; // 新建数组装入奇数和偶数 int pre = 0; // 从头开始 int back = count; // 从最后一个奇数后面开始 for (int a : array) if (a % 2 == 0) temp[back++] = a; else temp[pre++] = a; System.arraycopy(temp, 0, array, 0, array.length); // 复制temp到array&#125;","categories":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://lierabbit.cn/categories/剑指Offer/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"数组的整数次方","slug":"数组的整数次方","date":"2018-03-03T15:42:07.000Z","updated":"2018-08-26T09:46:23.273Z","comments":true,"path":"2018/03/03/数组的整数次方/","link":"","permalink":"https://lierabbit.cn/2018/03/03/数组的整数次方/","excerpt":"","text":"给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。 思路： 1234567891011121314151617181920public double Power(double base, int exponent) &#123; double result = 1; double temp = base; boolean isNegative; if (exponent &lt; 0) &#123; exponent = -exponent; isNegative = true; &#125; else isNegative = false; while (exponent != 0) &#123; if ((exponent &amp; 1) == 1) result *= temp; temp *= temp; exponent &gt;&gt;= 1; &#125; return isNegative ? 1 / result : result;&#125;","categories":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://lierabbit.cn/categories/剑指Offer/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"二进制中1的个数","slug":"二进制中1的个数","date":"2018-03-02T15:15:50.000Z","updated":"2018-08-26T09:40:08.490Z","comments":true,"path":"2018/03/02/二进制中1的个数/","link":"","permalink":"https://lierabbit.cn/2018/03/02/二进制中1的个数/","excerpt":"","text":"输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。 方法一：与1进行&amp;运算，无符号右移一位12345678910public int NumberOf1(int n) &#123; int count = 0; while (n != 0) &#123; if ((n &amp; 1) == 1) count++; n &gt;&gt;&gt;= 1; &#125; return count;&#125; 方法二：如果一个整数不为0，那么这个整数至少有一位是1。如果我们把这个整数减1，那么原来处在整数最右边的1就会变为0，原来在1后面的所有的0都会变成1(如果最右边的1后面还有0的话)。其余所有位将不会受到影响。举个例子：一个二进制数1100，从右边数起第三位是处于最右边的一个1。减去1后，第三位变成0，它后面的两位0变成了1，而前面的1保持不变，因此得到的结果是1011.我们发现减1的结果是把最右边的一个1开始的所有位都取反了。这个时候如果我们再把原来的整数和减去1之后的结果做与运算，从原来整数最右边一个1那一位开始所有位都会变成0。如1100&amp;1011=1000.也就是说，把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0.那么一个整数的二进制有多少个1，就可以进行多少次这样的操作。 12345678public int NumberOf1(int n) &#123; int count = 0; while (n != 0) &#123; count++; n = n &amp; (n - 1); &#125; return count;&#125;","categories":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://lierabbit.cn/categories/剑指Offer/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"矩形覆盖","slug":"矩形覆盖","date":"2018-03-02T13:16:17.000Z","updated":"2018-08-26T08:14:33.045Z","comments":true,"path":"2018/03/02/矩形覆盖/","link":"","permalink":"https://lierabbit.cn/2018/03/02/矩形覆盖/","excerpt":"","text":"我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？ 思路：依旧是斐波那契数列2*n的大矩形，和n个2*1的小矩形其中target*2为大矩阵的大小有以下几种情形： target &lt;= 0 大矩形为&lt;= 2*0,直接return 1； target = 1大矩形为2*1，只有一种摆放方法，return1； target = 2 大矩形为2*2，有两种摆放方法，return2； target = n 分为两步考虑：第一次摆放一块 2*1 的小矩阵（用YY表示），则摆放方法总共为f(target - 1) Y Y 第一次摆放一块1*2的小矩阵，则摆放方法总共为f(target-2)因为，摆放了一块1*2的小矩阵（用YY表示），对应下方的1*2（用XX表示）摆放方法就确定了，所以为f(targte-2) Y Y X X 则f(targte) = f(target-1) + f(target-2) 1234567891011121314151617181920public int RectCover(int target) &#123; if (target &lt;= 0) return 0; else if (target == 1) return 1; else if (target == 2) return 2; else &#123; int prePre = 1; int pre = 2; int res = 0; for (int i = 3; i &lt;= target; i++) &#123; res = pre + prePre; prePre = pre; pre = res; &#125; return res; &#125;&#125;","categories":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://lierabbit.cn/categories/剑指Offer/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"变态跳台阶","slug":"变态跳台阶","date":"2018-03-02T12:52:02.000Z","updated":"2018-08-26T07:59:05.249Z","comments":true,"path":"2018/03/02/变态跳台阶/","link":"","permalink":"https://lierabbit.cn/2018/03/02/变态跳台阶/","excerpt":"","text":"一只青蛙一次可以跳上1级台阶，也可以跳上2级，它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 思路：每个台阶都有跳与不跳两种情况（除了最后一个台阶），最后一个台阶必须跳。所以共用2^(n-1)中情况 123public int JumpFloorII(int target) &#123; return (int) Math.pow(2, target - 1);&#125;","categories":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://lierabbit.cn/categories/剑指Offer/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"跳台阶","slug":"跳台阶","date":"2018-03-02T11:17:53.000Z","updated":"2018-08-26T07:57:27.293Z","comments":true,"path":"2018/03/02/跳台阶/","link":"","permalink":"https://lierabbit.cn/2018/03/02/跳台阶/","excerpt":"","text":"一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 思路： 1级台阶只有一种方式：往上走一级 2级台阶2种方式：往上走两级 3级及以上台阶：f(i)=f(i-1)+f(i-2) 12345678910111213141516171819public int JumpFloor(int target) &#123; if (target == 1) return 1; else if (target == 2) return 2; else &#123; int prePre = 1; int pre = 2; int result = 0; for (int i = 3; i &lt;= target; i++) &#123; result = pre + prePre; prePre = pre; pre = result; &#125; return result; &#125;&#125;","categories":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://lierabbit.cn/categories/剑指Offer/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"斐波那契数列","slug":"斐波那契数列","date":"2018-03-02T11:09:14.000Z","updated":"2018-08-26T07:55:57.713Z","comments":true,"path":"2018/03/02/斐波那契数列/","link":"","permalink":"https://lierabbit.cn/2018/03/02/斐波那契数列/","excerpt":"","text":"大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。n&lt;=39斐波那契数列（Fibonacci sequence），又称黄金分割数列、因数学家列昂纳多·斐波那契（Leonardoda Fibonacci）以兔子繁殖为例子而引入，故又称为“兔子数列”，指的是这样一个数列：1、1、2、3、5、8、13、21、34、……在数学上，斐波纳契数列以如下被以递归的方法定义：F(0)=0，F(1)=1, F(n)=F(n-1)+F(n-2)（n&gt;=2，n∈N*）在现代物理、准晶体结构、化学等领域，斐波纳契数列都有直接的应用，为此，美国数学会从1963年起出版了以《斐波纳契数列季刊》为名的一份数学杂志，用于专门刊载这方面的研究成果。 思路：记录f(n-1)，f(n-2)，即可得出f(n) 12345678910111213141516171819public int Fibonacci(int n) &#123; if (n == 0) return 0; else if (n == 1 || n == 2) return 1; else &#123; int prePre = 1; // n - 2 int pre = 1; // n - 1 int result = 0; // n for (int i = 3; i &lt;= n; i++) &#123; result = prePre + pre; prePre = pre; pre = result; &#125; return result; &#125;&#125;","categories":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://lierabbit.cn/categories/剑指Offer/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"旋转数组的最小数字","slug":"旋转数组的最小数字","date":"2018-03-02T10:21:30.000Z","updated":"2018-08-26T07:44:07.076Z","comments":true,"path":"2018/03/02/旋转数组的最小数字/","link":"","permalink":"https://lierabbit.cn/2018/03/02/旋转数组的最小数字/","excerpt":"","text":"把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。 思路： 使用二分查找，当局部列表有序返回头元素 当局部列表有序返回头元素 当局部列表头元素小于中间元素，这里有循环，也就是有最小值，搜索左边 当局部列表中间元素小于尾元素，这里有循环，也就是有最小值，搜索右边 当局部列表头元素等于中间元素等于尾元素，遍历寻找最小值 12345678910111213141516171819202122232425262728293031323334public int minNumberInRotateArray(int[] array) &#123; if (array == null || array.length == 0) return 0; int left = 0; int right = array.length - 1; while (left &lt; right) &#123; int mid = left + (right - left) / 2; if (left + 1 == right) // 只剩2个数时直接比较其大小 break; else if (array[left] &lt; array[right]) // 当局部列表有序返回头 return array[left]; else if (array[left] &gt; array[mid]) // 当局部列表头元素大于中间元素，这里有循环，也就是有最小值，搜索左边 right = mid; else if (array[mid] &gt; array[right]) // 当局部列表中间元素大于尾元素，这里有循环，也就是有最小值，搜索右边 left = mid; else &#123; // 当局部列表头元素等于中间元素等于尾元素，遍历寻找最小值 while (left &lt; right) &#123; if (array[left] == array[mid]) left++; else if (array[left] &lt; array[mid]) return array[left]; else &#123; right = mid; break; &#125; &#125; &#125; &#125; return Math.min(array[left], array[right]);&#125;","categories":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://lierabbit.cn/categories/剑指Offer/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"用两个栈实现队列","slug":"用两个栈实现队列","date":"2018-03-01T15:38:47.000Z","updated":"2018-08-26T07:41:29.710Z","comments":true,"path":"2018/03/01/用两个栈实现队列/","link":"","permalink":"https://lierabbit.cn/2018/03/01/用两个栈实现队列/","excerpt":"","text":"用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。 思路： 当弹出栈不空时不能压入弹出栈 必须一次性将压入栈倒出到弹出栈 12345678910111213141516171819202122232425262728293031public class 用两个栈实现队列 &#123; Stack&lt;Integer&gt; stack1 = new Stack&lt;Integer&gt;(); Stack&lt;Integer&gt; stack2 = new Stack&lt;Integer&gt;(); public void push(int node) &#123; stack1.push(node); &#125; public int pop() &#123; if (stack2.isEmpty()) &#123; while (!stack1.isEmpty()) stack2.add(stack1.pop()); &#125; return stack2.pop(); &#125; public static void main(String[] args) &#123; 用两个栈实现队列 twoStackQueue = new 用两个栈实现队列(); twoStackQueue.push(1); twoStackQueue.push(2); twoStackQueue.push(3); System.out.println(twoStackQueue.pop()); System.out.println(twoStackQueue.pop()); twoStackQueue.push(4); System.out.println(twoStackQueue.pop()); twoStackQueue.push(5); System.out.println(twoStackQueue.pop()); System.out.println(twoStackQueue.pop()); &#125;&#125;","categories":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://lierabbit.cn/categories/剑指Offer/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"重建二叉树","slug":"重建二叉树","date":"2018-03-01T14:52:29.000Z","updated":"2018-08-26T07:37:42.347Z","comments":true,"path":"2018/03/01/重建二叉树/","link":"","permalink":"https://lierabbit.cn/2018/03/01/重建二叉树/","excerpt":"","text":"输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 思路：每次将左右两颗子树当成新的子树进行处理，中序的左右子树索引很好找，前序的开始结束索引通过计算中序中左右子树的大小来计算，然后递归求解，直到startPre&gt;endPre||startIn&gt;endIn。 12345678910111213141516171819202122public TreeNode reConstructBinaryTree(int[] pre, int[] in) &#123; TreeNode root = process(pre, 0, pre.length - 1, in, 0, in.length - 1); return root;&#125;public TreeNode process(int[] pre, int startPre, int endPre, int in[], int startIn, int endIn) &#123; if (startPre &gt; endPre || startIn &gt; endIn) return null; // 先序的每个节点都是子树的头节点 TreeNode root = new TreeNode(pre[startPre]); for (int i = startIn; i &lt;= endIn; i++) &#123; if (pre[startPre] == in[i]) &#123; root.left = process(pre, startPre + 1, startPre + i - startIn, in, startIn, i - 1); root.right = process(pre, startPre + i - startIn + 1, endPre, in, i + 1, endIn); break; &#125; &#125; return root;&#125;","categories":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://lierabbit.cn/categories/剑指Offer/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"从尾到头打印链表","slug":"从尾到头打印链表","date":"2018-02-28T15:49:14.000Z","updated":"2018-08-26T07:24:55.235Z","comments":true,"path":"2018/02/28/从尾到头打印链表/","link":"","permalink":"https://lierabbit.cn/2018/02/28/从尾到头打印链表/","excerpt":"","text":"输入一个链表，从尾到头打印链表每个节点的值。 递归到最后，在一个个的添加进List1234567891011121314public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123; ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;(); printListFromTailToHead(listNode, res); return res;&#125;public void printListFromTailToHead(ListNode node, List&lt;Integer&gt; res) &#123; if (node != null) &#123; printListFromTailToHead(node.next, res); res.add(node.val); &#125;&#125; 使用栈从头到尾装入所有节点即可，因为栈先进后出的特性，在弹出的时候就是从尾到头123456789101112131415public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123; ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;(); Stack&lt;ListNode&gt; stack = new Stack&lt;&gt;(); ListNode node = listNode; while (node != null) &#123; stack.add(node); node = node.next; &#125; while (!stack.empty()) &#123; node = stack.pop(); res.add(node.val); &#125; return res;&#125; 反转链表后再打印1234567891011121314151617181920212223242526public ArrayList&lt;Integer&gt; printListFromTailToHead3(ListNode listNode) &#123; ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;(); ListNode node = reverseList(listNode); while (node != null) &#123; res.add(node.val); node = node.next; &#125; return res;&#125;public ListNode reverseList(ListNode head) &#123; ListNode pre = null; ListNode next; while (head != null) &#123; next = head.next; head.next = pre; pre = head; head = next; &#125; return pre;&#125;","categories":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://lierabbit.cn/categories/剑指Offer/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"替换空格","slug":"替换空格","date":"2018-02-28T15:46:46.000Z","updated":"2018-08-26T07:22:25.618Z","comments":true,"path":"2018/02/28/替换空格/","link":"","permalink":"https://lierabbit.cn/2018/02/28/替换空格/","excerpt":"","text":"请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 思路：一、使用replaceAlliniString.replaceAll(“ “,”%20”)二、手动实现思路：记录空格出现次数，新数组长度等于原数组长度+空格数*2，遍历原数组按规则放入新数组即可 1234567891011121314151617181920public String replaceSpace(StringBuffer str) &#123; int count = 0; for (int i = 0; i &lt; str.length(); i++) if (str.charAt(i) == ' ') count++; int charsLen = str.length() + count * 2; char[] chars = new char[charsLen]; for (int i = str.length() - 1; i &gt;= 0; i--) &#123; char ch = str.charAt(i); if (ch == ' ') &#123; chars[--charsLen] = '0'; chars[--charsLen] = '2'; chars[--charsLen] = '%'; &#125; else chars[--charsLen] = str.charAt(i); &#125; return new String(chars);&#125;","categories":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://lierabbit.cn/categories/剑指Offer/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"二维数组中的查找","slug":"二维数组中的查找","date":"2018-02-28T15:31:31.000Z","updated":"2018-08-26T07:20:56.572Z","comments":true,"path":"2018/02/28/二维数组中的查找/","link":"","permalink":"https://lierabbit.cn/2018/02/28/二维数组中的查找/","excerpt":"","text":"在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 思路： 从数组的右上角开始寻找 当前数大于目前位置时，不用往左找了，因为左边的数都比当前位置的小，往下找 当前数小于目前位置时，不用往下走了，因为下面的数都比当前位置的大，往左找 123456789101112131415public boolean Find(int target, int[][] array) &#123; int row = 0; int col = array[0].length - 1; while (row &lt; array.length &amp;&amp; col &gt;= 0) &#123; if (array[row][col] &gt; target) col--; else if (array[row][col] &lt; target) row++; else return true; &#125; return false;&#125;","categories":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://lierabbit.cn/categories/剑指Offer/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"游戏","slug":"游戏","date":"2018-02-27T12:19:44.000Z","updated":"2018-08-25T10:04:10.032Z","comments":true,"path":"2018/02/27/游戏/","link":"","permalink":"https://lierabbit.cn/2018/02/27/游戏/","excerpt":"","text":"A与B做游戏。 在一个n*m的矩阵中的出发点是（1，m），终点是（n,1），规则是只能向左移动一格，向下一格或向左下移动一格，先走到终点的为winner。 A先走。给定两个整数n和m，请返回最后的获胜者的名字(A或B)。 测试样例：125 3返回：B 思路：最优策略是两个人每次共走2格，如果A向左下2移动一格，相当于移动2格，此时B也应该向左下移动，总共是4格 123456789public char getWinner(int n, int m) &#123; // write code here // 最优策略是两个人每次共走2格， // 如果A向左下2移动一格，相当于移动2格，此时B也应该向左下移动，总共是4格 if (m % 2 != 0 &amp;&amp; n % 2 != 0) return 'B';// // 此时B距离终点只有1格 else return 'A';&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"数组清空","slug":"数组清空","date":"2018-02-27T12:08:20.000Z","updated":"2018-08-25T10:00:51.924Z","comments":true,"path":"2018/02/27/数组清空/","link":"","permalink":"https://lierabbit.cn/2018/02/27/数组清空/","excerpt":"","text":"现在有一个整数数组，其元素值均为1-n范围内的某个整数，现在你和你的朋友在玩一个游戏，游戏的目的是把数组清空，你们轮流操作，你是先手，每次操作你可以删除数组中值为某个数的元素任意多个(当然数组中值为这个数的元素个数应大于等于你删除的个数,且你至少要删除一个数)。最先把数组清空的人获得胜利。假设你们都采取最优策略，请你计算你能否获得胜利。给定一个整数数组A和元素个数n。请返回一个整数，1代表你能获胜，0代表你不能获胜。 测试样例：12[1,1,1]返回：1 思路：最优策略为和对方删除同样数量的元素，导致最后留下只能两次删除完所有元素，这样在对方再走一步后你就获胜了 1234567891011121314151617public int getWinner(int[] A, int n) &#123; // write code here HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); // 统计所有数字出现次数 for (int num : A) map.merge(num, 1, (a, b) -&gt; a + b); // 将所有次数进行异或运算 int res = 0; for (int count : map.values()) &#123; res ^= count; &#125; // 出现次数成对则为0 return res != 0 ? 1 : 0;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"跳格子","slug":"跳格子","date":"2018-02-27T08:54:47.000Z","updated":"2018-08-25T09:54:01.466Z","comments":true,"path":"2018/02/27/跳格子/","link":"","permalink":"https://lierabbit.cn/2018/02/27/跳格子/","excerpt":"","text":"你和你的朋友正在玩棋子跳格子的游戏，而棋盘是一个由n个格子组成的长条，你们两人轮流移动一颗棋子，每次可以选择让棋子跳1-3格，先将棋子移出棋盘的人获得胜利。我们知道你们两人都会采取最优策略，现在已知格子数目，并且初始时棋子在第一格由你操作。请你计算你是否能获胜。给定格子的数目n(n为不超过300的正整数)。返回一个整数，1代表能获胜，0代表不能获胜。 测试样例：123返回：1 思路： 通过列举1、2、3、4格的情况发现，只要轮到我的时候还剩4格，我必输无疑，因为无论我选择走多少格对方都可以一次走出棋盘。更巧的是，无论我走多少格，对方都可以选择走一种格数来使这一回合凑齐4格。因此，只要总格数是4的整数倍，我就必输无疑。而在其他任何种格数下，在走第一步的时候我都可以选择走一种格数使得剩下的格数为4的整数倍，这样对方就必输无疑。 1234public int checkWin(int n) &#123; // write code here return (n - 1) % 4 == 0 ? 0 : 1;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"赛马","slug":"赛马","date":"2018-02-27T08:43:49.000Z","updated":"2018-08-25T09:50:20.935Z","comments":true,"path":"2018/02/27/赛马/","link":"","permalink":"https://lierabbit.cn/2018/02/27/赛马/","excerpt":"","text":"作为一个马场的主人，你要安排你的n匹赛马和另一个马场的n匹马比赛。你已经知道了对方马场的出战表，即参加每一场的马的强壮程度。当然你也知道你自己的所有马的强壮程度。我们假定比赛的结果直接由马的强壮程度决定，即更壮的马获胜(若相同则双方均不算获胜)，请你设计一个策略，使你能获得尽量多的场次的胜利。给定对方每场比赛的马的强壮程度oppo及你的所有马的强壮程度horses(强壮程度为整数，且数字越大越强壮)同时给定n，请返回最多能获胜的场次。 测试样例：12[1,2,3],[1,2,3],3返回：2 思路：和田忌赛马类似，用最强的马与能赢别人的最强的马比 1234567891011public int winMost(int[] oppo, int[] horses, int n) &#123; // write code here Arrays.sort(oppo); Arrays.sort(horses); int res = 0; for (int i = n - 1; i &gt;= 0; --i) if (horses[n - res - 1] &gt; oppo[i]) res++; return res;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"涂色","slug":"涂色","date":"2018-02-27T08:26:06.000Z","updated":"2018-08-25T09:45:21.943Z","comments":true,"path":"2018/02/27/涂色/","link":"","permalink":"https://lierabbit.cn/2018/02/27/涂色/","excerpt":"","text":"你要在一个nxm的格子图上涂色，你每次可以选择一个未涂色的格子涂上你开始选定的那种颜色。同时为了美观，我们要求你涂色的格子不能相邻，也就是说，不能有公共边，现在问你，在采取最优策略的情况下，你最多能涂多少个格子？给定格子图的长n和宽m。请返回最多能涂的格子数目。 测试样例：121,2返回：1 思路：只有一种颜色，要想不相邻，每行一个隔一个涂色即可，如果行数或者列数为偶数，最多的格子即为(m / 2) n或者(n / 2) m，显然就是m n / 2如果行列均不为偶数，假设多加一列，则最大格子就为((n + 1) / 2) m,然后需要减去多加的格子数为(m - 1) / 2,两式合并即为(n m + 1) / 2又由int除法特性，可以将两式合并为(n m + 1) / 2,即为所求 1234public int getMost(int n, int m) &#123; // write code here return (n * m + 1) / 2;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"最优编辑","slug":"最优编辑","date":"2018-02-27T08:03:25.000Z","updated":"2018-08-25T09:29:01.079Z","comments":true,"path":"2018/02/27/最优编辑/","link":"","permalink":"https://lierabbit.cn/2018/02/27/最优编辑/","excerpt":"","text":"对于两个字符串A和B，我们需要进行插入、删除和修改操作将A串变为B串，定义c0，c1，c2分别为三种操作的代价，请设计一个高效算法，求出将A串变为B串所需要的最少代价。给定两个字符串A和B，及它们的长度和三种操作代价，请返回将A串变为B串所需要的最小代价。保证两串长度均小于等于300，且三种代价值均小于等于100。 测试样例：12&quot;abc&quot;,3,&quot;adc&quot;,3,5,3,100返回：8 思路：下面具体说明dp矩阵每个位置的值是如何计算的: dp[0][0]设置为0，表示str1空的子串编辑成str2空的子串，故代价为0。 矩阵dp第一列即dp[0..M][0],dp[i][0]表示str1[0.i-1]编辑成空串的最小代价，即把str1[0..i-1]所有字符都删掉的代价，故dp[i][0]=dc*i。 矩阵dp第一行即dp[0][0..N]。dp[0][j]表示空串编辑成str2[0.j-1]的最小代价，即在空串里插入str2[0..j-1]的所有字符的代价，故dp[0][j]=ic*j。 其他位置按照先从左到右，再从上到下来计算，dp[i][j]的值只可能来自以下四种情况:(1) str1[0..i-1]可以先编辑成str1[0..i-2] 也就是删除字符str1[i-1],然后由str1[0..i-2]编辑成str2[0..j-1] dp[i-1][j]就表示str1[0..i-2]编辑成str2[0..j-1]的最小代价，那么dp[i][j]可能等于dc+dp[i-1][j].(2) str1[0..i-1]可以先编辑成str2[0.j-2],然后将str2[0..j-2]插入字符str2[j-1],编辑成str2[0..j-1] dp[i][j-1]表示str1[0..i-1]编辑成str2[0..j-2]的最小代价，那么dp[i][j]可能等于dp[ij][j-1]+ic.(3) 如果str1[i-1]!=str2[j-1].先把str1[0..i-1]中str1[0..i-2]的部分变成str2[0..j-2],然后把字符str1[i-1]替换成str2[j-1],这样str1[0..i-1]就编辑成str2[0..j-1]了.dp[i-1][j-1]就表示str1[0.i-2]编辑成str2[0.i-2]的最小代价，那么dp[i][j]可能等于dp[i-1][j-1] +rC。(4) 如果str1[i-1]==str2[j-1],先把str1[0..i-1]中str1[0..i-2]的部分变成str2[0.j-2],因为此时字符str1[i-1]等于str2[j-1],所以str1[0..i-1]已经编辑成str2[0.j-1]了。dp[i-1][j-1]就表示str1[0.i-2]编辑成str2[0.i-2]的最小代价，那么dp[i]j]可能等于dp[i-1j[j-1].以上四种可能的值中，选最小值作为dp[i][j]的值。 最终结果返回dp最右下角的值 123456789101112131415161718192021222324252627282930public int findMinCost(String str1, int n, String str2, int m, int ic, int dc, int rc) &#123; // write code here int[][] dp = new int[n + 1][m + 1]; int col = 0; int row = 0; // 初始化列 while (row &lt;= n) &#123; dp[row][0] = row * dc; row++; &#125; // 初始化行 while (col &lt;= m) &#123; dp[0][col] = col * ic; col++; &#125; for (row = 1; row &lt;= n; row++) &#123; for (col = 1; col &lt;= m; col++) &#123; if (str1.charAt(row - 1) == str2.charAt(col - 1)) dp[row][col] = Math.min(dp[row - 1][col] + dc, Math.min(dp[row][col - 1] + ic, dp[row - 1][col - 1])); else dp[row][col] = Math.min(dp[row - 1][col] + dc, Math.min(dp[row][col - 1] + ic, dp[row - 1][col - 1] + rc)); &#125; &#125; return dp[n][m];&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"01背包","slug":"01背包","date":"2018-02-27T05:56:21.000Z","updated":"2018-08-25T09:24:56.788Z","comments":true,"path":"2018/02/27/01背包/","link":"","permalink":"https://lierabbit.cn/2018/02/27/01背包/","excerpt":"","text":"一个背包有一定的承重cap，有N件物品，每件都有自己的价值，记录在数组v中，也都有自己的重量，记录在数组w中，每件物品只能选择要装入背包还是不装入背包，要求在不超过背包承重的前提下，选出物品的总价值最大。给定物品的重量w价值v及物品数n和承重cap。请返回最大总价值。 测试样例：12[1,2,3],[1,2,3],3,6返回：6 思路：物品编号从1到n，一件一件物品考虑是否加入背包。假设dp[x] [y]表示前x件物品，不超过重量y的时候的最大价值。枚举一下第x件物品的情况:情况一:如果选择第x件物品，则前X-1件物品得到的重量不能超过y-w[x]。情况二:如果不选第x件物品，则前X-1件物品得到的重量不能超过y。所以，dp[x] [y]可能等于dp[x-1][y],也就是不取第x件物品的时，价值和之前一样。也可能是dp[x-1][y-w[x]] +v[x]，也就是决定拿第x件物品的情况，当然会获得x物品的价值。两种可能性中，应该选择价值最大的那个。dp[x][y]=max{dp[x-1][y],dp[x-1][y-w[x]]+v[x]}。对于dp矩阵来说，行数是物品的数量n，行数是背包的重量W。从左到右，再从上到下依次计算所有的dp值即可 12345678910111213141516171819202122232425262728public int maxValue(int[] w, int[] v, int n, int cap) &#123; // write code here int[][] dp = new int[n][cap + 1]; int row; int col = 0; // 初始化列 while (col &lt;= cap) &#123; if (col &gt;= w[0]) break; col++; &#125; while (col &lt;= cap) dp[0][col++] = v[0]; for (row = 1; row &lt; n; row++) &#123; for (col = 1; col &lt;= cap; col++) &#123; if (col - w[row] &lt; 0) dp[row][col] = dp[row - 1][col]; else dp[row][col] = Math.max(dp[row - 1][col - w[row]] + v[row], dp[row - 1][col]); &#125; &#125; return dp[n - 1][cap];&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"LCS（最长公共子序列）","slug":"LCS（最长公共子序列）","date":"2018-02-27T05:14:01.000Z","updated":"2018-08-25T09:20:13.004Z","comments":true,"path":"2018/02/27/LCS（最长公共子序列）/","link":"","permalink":"https://lierabbit.cn/2018/02/27/LCS（最长公共子序列）/","excerpt":"","text":"给定两个字符串A和B，返回两个字符串的最长公共子序列的长度。例如，A=”1A2C3D4B56”，B=”B1D23CA45B6A”，”123456”或者”12C4B6”都是最长公共子序列。给定两个字符串A和B，同时给定两个串的长度n和m，请返回最长公共子序列的长度。保证两串长度均小于等于300。 测试样例：12&quot;1A2C3D4B56&quot;,10,&quot;B1D23CA45B6A&quot;,12返回：6 思路： 矩阵dp第一列，即dp[i][0],代表str1[0..i]与str2[0]的最长公共子序列长度。str2[0]只有一个字符，所以dp[i][0]最大为1。如果str1[i]==str2[0],则令dp[i][0]为1，一旦dp[i][0]被设为1，则令dp[i+1..M][0]全部为1 矩阵dp第一行，即dp[0][j]，与步骤1同理。如果str1[0]==str2[j],则令dp[0][j]为1，一旦dp[0][j]被设为1，则令dp[0][j+1..N]全部为1 其他位置，dp[i][j]的值只可能来自以下三种情况:情况一:可能是dp[i-1][j]的值。这代表str1[0..i-1]与str2[0..j]的最长公共子序列长度。举例:str1=”A1BC2”，str2=”AB34C”。str1[0..3]为” A1BC”,str2[0..4]为” AB34C”，这两部分最长公共子序列为”ABC”即dp[3][4]为3。str1整体和str2整体最长公共子序列也是”ABC”，所以dp[4][4]可能来自dp[3][4].情况二:同理可知，dp[i][j]的值也可能是dp[i][j-1].情况三:如果str1[i]==str2[j],还可能是dp[i-1][j-1]+1的值。举例:比如str1=”ABCD”,str2=”ABCD”.str1[0..2]即”ABC”与str2[0..2]即”ABC”的最长公共子序列为”ABC”，也就是dp[2][2]为3。因为str1和str2的最后一个字符都是” D”，所以dp[i][j]=dp[i-1][j-1]+1.三种可能的值中，选最大值作为dp[i][j]的值。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public int findLCS(String A, int n, String B, int m) &#123; // write code here if (A == null || A.length() == 0 || B == null || B.length() == 0) return 0; int[][] dp = new int[n][m]; // 初始化列 int row = 0; while (row &lt; n) &#123; if (B.charAt(0) == A.charAt(row)) &#123; dp[row][0] = 1; row++; break; &#125; else dp[row][0] = 0; row++; &#125; while (row &lt; n) dp[row++][0] = 1; // 初始化行 int col = 0; while (col &lt; m) &#123; if (A.charAt(0) == B.charAt(col)) &#123; dp[0][col] = 1; col++; break; &#125; else dp[0][col] = 0; col++; &#125; while (col &lt; m) dp[0][col++] = 1; for (row = 1; row &lt; n; row++) &#123; for (col = 1; col &lt; m; col++) &#123; int max = Math.max(dp[row - 1][col], dp[row][col - 1]); if (A.charAt(row) == B.charAt(col)) max = Math.max(max, dp[row - 1][col - 1] + 1); dp[row][col] = max; &#125; &#125; return dp[row - 1][col - 1];&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"LIS（最长上升子序列）","slug":"LIS（最长上升子序列）","date":"2018-02-27T05:06:20.000Z","updated":"2018-08-25T09:12:31.522Z","comments":true,"path":"2018/02/27/LIS（最长上升子序列）/","link":"","permalink":"https://lierabbit.cn/2018/02/27/LIS（最长上升子序列）/","excerpt":"","text":"这是一个经典的LIS(即最长上升子序列)问题，请设计一个尽量优的解法求出序列的最长上升子序列的长度。给定一个序列A及它的长度n(长度小于等于500)，请返回LIS的长度。 测试样例：12[1,4,2,5,3],5返回：3 思路：记录以每一个数结尾的最大上升子序列长度，取最大的即为结果maxs[i]表示以maxs[i]结尾的最大上升子序列长度，maxs[i] = 前面所有比它小的数的最大上升子序列长度中最大的+1 1234567891011121314151617181920public int getLIS(int[] arr, int n) &#123; // write code here if (arr == null || arr.length == 0) return 0; int[] maxs = new int[n]; maxs[0] = 1; int maxLen = 1; for (int i = 1; i &lt; n; i++) &#123; int max = 1; for (int k = 0; k &lt; i; k++) &#123; if (arr[i] &gt; arr[k]) max = Math.max(max, maxs[k] + 1); &#125; maxs[i] = max; maxLen = Math.max(maxLen, max); &#125; return maxLen;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"矩阵最小路径和","slug":"矩阵最小路径和","date":"2018-02-26T15:34:42.000Z","updated":"2018-08-25T09:08:32.395Z","comments":true,"path":"2018/02/26/矩阵最小路径和/","link":"","permalink":"https://lierabbit.cn/2018/02/26/矩阵最小路径和/","excerpt":"","text":"有一个矩阵map，它每个格子有一个权值。从左上角的格子开始每次只能向右或者向下走，最后到达右下角的位置，路径上所有的数字累加起来就是路径和，返回所有的路径中最小的路径和。给定一个矩阵map及它的行数n和列数m，请返回最小路径和。保证行列数均小于等于100. 测试样例：12[[1,2,3],[1,1,1]],2,3返回：4 思路： 1234567891011121314151617181920public int getMin(int[][] map, int n, int m) &#123; // write code here int[][] dp = new int[n][m]; for (int row = 0; row &lt; n; row++) &#123; if (row == 0) dp[row][0] = map[row][0]; else dp[row][0] = dp[row - 1][0] + map[row][0]; &#125; for (int col = 1; col &lt; m; col++) dp[0][col] = dp[0][col - 1] + map[0][col]; for (int row = 1; row &lt; n; row++) &#123; for (int col = 1; col &lt; m; col++) &#123; dp[row][col] = map[row][col] + Math.min(dp[row - 1][col], dp[row][col - 1]); &#125; &#125; return dp[n - 1][m - 1];&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"台阶问题","slug":"台阶问题","date":"2018-02-26T15:00:08.000Z","updated":"2018-08-25T09:05:48.592Z","comments":true,"path":"2018/02/26/台阶问题/","link":"","permalink":"https://lierabbit.cn/2018/02/26/台阶问题/","excerpt":"","text":"有n级台阶，一个人每次上一级或者两级，问有多少种走完n级台阶的方法。为了防止溢出，请将结果Mod 1000000007给定一个正整数int n，请返回一个数，代表上楼的方式数。保证n小于等于100000。测试样例： 121返回：1 思路： 1级台阶只有一种方式：往上走一级 2级台阶2种方式：往上走两级 3级及以上台阶：f(i)=f(i-1)+f(i-2) 1234567891011121314151617public int countWays(int n) &#123; // write code here if (n == 1) return 1; else if (n == 2) return 2; else &#123; int[] a = new int[n + 1]; a[1] = 1; a[2] = 2; for (int i = 3; i &lt;= n; i++) &#123; a[i] = (a[i - 1] + a[i - 2]) % 1000000007; &#125; return a[n]; &#125;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"找零钱","slug":"找零钱","date":"2018-02-26T07:01:49.000Z","updated":"2018-08-25T08:48:12.496Z","comments":true,"path":"2018/02/26/找零钱/","link":"","permalink":"https://lierabbit.cn/2018/02/26/找零钱/","excerpt":"","text":"有数组money，money中所有的值都为正数且不重复。每个值代表一种面值的货币，每种面值的货币可以使用任意张，再给定一个整数aim(小于等于1000)代表要找的钱数，求换钱有多少种方法。给定数组money及它的大小(小于等于50)，同时给定一个整数aim，请返回有多少种方法可以凑成aim。测试样例： 12[1,2,4],3,3返回：2 假设arr={5、10、25、1},aim=1000。 暴力搜索 用0张5元的货币，让[10,25,1]组成剩下的1000 ，最终方法数记为—————- res1 用1张5元的货币，让[10,25,1]组成剩下的995 ，最终方法数记为—————- res2 用2张5元的货币，让[10,25,1]组成剩下的990 ，最终方法数记为—————- res3············································································································································································································································································································································································································ 用200张5元的货币，让[10,25,1]组成剩下的0 ，最终方法数记为————— res201res = res1 + res2 + res3 + ······+ res201 123456789101112public int process1(int[] money, int index, int aim) &#123; int res = 0; if (index == money.length) res = aim == 0 ? 1 : 0; // 是否成功组成aim else &#123; for (int i = 0; money[index] * i &lt;= aim; i++) &#123; res += process1(money, index + 1, aim - money[index] * i); &#125; &#125; return res;&#125; 记忆搜索：由于暴力搜索由许多重复计算，改进而得例如：如果已经使用0张5元和1张10元的情况下，后续将求:process1(money,2,990)2 :表示money剩下的钱为money[2,3],即[25,1]990 :表示要找的剩余钱数。当已经使用2张5元和0张10元的情况下，后续还是要求process1(money,2,990)改进方式：发现递归过程只与index与aim有关，将index与aim的结果保存起来，若已经出现，则直接返回之前计算的结果 12345678910111213141516171819202122public int process2(int[] money, int index, int aim, int[][] map) &#123; int res = 0; if (index == money.length) res = aim == 0 ? 1 : 0; else &#123; int row = index + 1; int col; int cacheWays; for (int i = 0; money[index] * i &lt;= aim; i++) &#123; col = aim - money[index] * i; cacheWays = map[row][col]; if (cacheWays != 0) &#123; res += cacheWays == -1 ? 0 : cacheWays; &#125; else res += process2(money, row, col, map); &#125; &#125; map[index][aim] = res == 0 ? -1 : res; return res;&#125; 动态规划：按序计算从简单到复杂的情况记忆搜索方法与动态规划方法的联系 记忆化搜索方法就是某种形态的动态规划方法，记忆化搜索方法不关心到达某一个递归过程的路径。 只是单纯地对计算过的递归过程进行记录，避免重复的递归过程。 动态规划的方法则是规定好每一个递归过程的计算顺序，依次进行计算，后面的计算过程严格依赖前面的计算过程。 两者都是空间换时间的方法，也都有枚举的过程，区别就在于动态规划规定计算顺序，而记忆搜索不用规定。 什么是动态规划方法 其本质是利用申请的空间来记录每一个暴力搜索的计算结果，下次要用结果的时候直接使用，而不在进行重复的递归过程。 动态规划规定每一种递归状态的计算顺序，依次进行计算。 1234567891011121314151617181920212223public int process3(int[] money, int index, int aim) &#123; int[][] dp = new int[money.length][aim + 1]; for (int i = 0; i &lt; money.length; i++) &#123; // 组成0的方法只有1种那就是不用 dp[i][0] = 1; &#125; for (int i = 0; i &lt;= aim; i++) &#123; // 只使用money[0]货币的情况下组成i的方法有几种 if (i % money[0] == 0) dp[0][i] = 1; else dp[0][i] = 0; &#125; for (int i = 1; i &lt; money.length; i++) &#123; for (int j = 1; j &lt;= aim; j++) &#123; for (int k = 0; k * money[i] &lt;= j; k++) dp[i][j] += dp[i - 1][j - money[i] * k]; &#125; &#125; return dp[money.length - 1][aim];&#125; 优化动态规划 12345678910111213141516171819202122232425public int process4(int[] money, int index, int aim) &#123; int[][] dp = new int[money.length][aim + 1]; for (int i = 0; i &lt; money.length; i++) &#123; // 组成0的方法只有1种那就是不用 dp[i][0] = 1; &#125; for (int i = 0; i &lt;= aim; i++) &#123; // 只使用money[0]货币的情况下组成i的方法有几种 if (i % money[0] == 0) dp[0][i] = 1; else dp[0][i] = 0; &#125; for (int i = 1; i &lt; money.length; i++) &#123; for (int j = 1; j &lt;= aim; j++) &#123; if (j - money[i] &gt;= 0) dp[i][j] = dp[i][j - money[i]] + dp[i - 1][j]; else dp[i][j] = dp[i - 1][j]; &#125; &#125; return dp[money.length - 1][aim];&#125; 4种方法的集合123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145public class Exchange &#123; public int countWays(int[] money, int n, int aim) &#123; // write code here if (money == null || money.length == 0 || aim &lt;= 0) return 0; // 暴力搜索// return process1(money, 0, aim); // 记忆搜索// int[][] map = new int[n + 1][aim + 1];// return process2(money, 0, aim, map); // 由记忆搜索引出的动态规划// return process3(money, n, aim); // 动态规划 return process4(money, n, aim); &#125; /** * 暴力搜索 * 用money[index...money.length-1]这里的钱组成aim，有几种方法 * * @param money * @param index * @param aim * @return */ public int process1(int[] money, int index, int aim) &#123; int res = 0; if (index == money.length) res = aim == 0 ? 1 : 0; // 是否成功组成aim else &#123; for (int i = 0; money[index] * i &lt;= aim; i++) &#123; res += process1(money, index + 1, aim - money[index] * i); &#125; &#125; return res; &#125; /** * 记忆搜索 * 用money[index...money.length-1]这里的钱组成aim，有几种方法 * * @param money * @param index * @param aim * @return */ public int process2(int[] money, int index, int aim, int[][] map) &#123; int res = 0; if (index == money.length) res = aim == 0 ? 1 : 0; else &#123; int row = index + 1; int col; int cacheWays; for (int i = 0; money[index] * i &lt;= aim; i++) &#123; col = aim - money[index] * i; cacheWays = map[row][col]; if (cacheWays != 0) &#123; res += cacheWays == -1 ? 0 : cacheWays; &#125; else res += process2(money, row, col, map); &#125; &#125; map[index][aim] = res == 0 ? -1 : res; return res; &#125; /** * 由记忆搜索引出的动态规划 * @param money * @param index * @param aim * @return */ public int process3(int[] money, int index, int aim) &#123; int[][] dp = new int[money.length][aim + 1]; for (int i = 0; i &lt; money.length; i++) &#123; // 组成0的方法只有1种那就是不用 dp[i][0] = 1; &#125; for (int i = 0; i &lt;= aim; i++) &#123; // 只使用money[0]货币的情况下组成i的方法有几种 if (i % money[0] == 0) dp[0][i] = 1; else dp[0][i] = 0; &#125; for (int i = 1; i &lt; money.length; i++) &#123; for (int j = 1; j &lt;= aim; j++) &#123; for (int k = 0; k * money[i] &lt;= j; k++) dp[i][j] += dp[i - 1][j - money[i] * k]; &#125; &#125; return dp[money.length - 1][aim]; &#125; /** * 优化后的动态规划 * @param money * @param index * @param aim * @return */ public int process4(int[] money, int index, int aim) &#123; int[][] dp = new int[money.length][aim + 1]; for (int i = 0; i &lt; money.length; i++) &#123; // 组成0的方法只有1种那就是不用 dp[i][0] = 1; &#125; for (int i = 0; i &lt;= aim; i++) &#123; // 只使用money[0]货币的情况下组成i的方法有几种 if (i % money[0] == 0) dp[0][i] = 1; else dp[0][i] = 0; &#125; for (int i = 1; i &lt; money.length; i++) &#123; for (int j = 1; j &lt;= aim; j++) &#123; if (j - money[i] &gt;= 0) dp[i][j] = dp[i][j - money[i]] + dp[i - 1][j]; else dp[i][j] = dp[i - 1][j]; &#125; &#125; return dp[money.length - 1][aim]; &#125; public static void main(String[] args) &#123; int[] money = &#123;1, 2, 5&#125;; Exchange exchange = new Exchange(); int ways = exchange.countWays(money, 3, 100); System.out.println(ways); &#125;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"机器吐球","slug":"机器吐球","date":"2018-02-25T06:36:35.000Z","updated":"2018-08-25T08:31:23.978Z","comments":true,"path":"2018/02/25/机器吐球/","link":"","permalink":"https://lierabbit.cn/2018/02/25/机器吐球/","excerpt":"","text":"有一个机器按自然数序列的方式吐出球，1号球，2号球，3号球等等。你有一个袋子，袋子里最多只能装下K个球，并且除袋子以外，你没有更多的空间，一个球一旦扔掉，就再也不可拿回。设计一种选择方式，使得当机器吐出第N号球的时候，你袋子中的球数是K个，同时可以保证从1号球到N号球中的每一个，被选进袋子的概率都是K/N。举一个更具体的例子，有一个只能装下10个球的袋子，当吐出100个球时，袋子里有10 球，并且1~100号中的每一个球被选中的概率都是10/100。然后继续吐球，当吐出1000个球时，袋子里有 10 个球，并且1~1000号中的每一个球被选中的概率都是10/1000。继续吐球，当吐出i个球时，袋子里有10个球，并且1~i号中的每一个球被选中的概率都是10/i。也就是随着N的变化，1~N号球被选中的概率动态变化成k/N。请将吐出第N个球时袋子中的球的编号返回。 思路：此题核心解法为蓄水池抽样算法，过程如下: 处理1~k号球时，直接放进袋子里 处理第i号球时，以k/i的概率决定是否将第i号球放进袋子。如果不决定将第i号球放进袋子，直接扔掉第i号球。如果决定将第i号球放进袋子，那么就从袋子里的k个球中随机扔掉一个，然后把第i号球放入袋子 处理第i+1号球时，重复步骤1或步骤2 123456789101112131415private int[] selected = null;private static Random rand = new Random(12345);// 每次拿一个球都会调用这个函数，N表示第i次调用public int[] carryBalls(int N, int k) &#123; if (selected == null) selected = new int[k]; if (N &lt;= k) &#123; selected[N - 1] = N; &#125; else &#123; if (rand.nextInt(N) &lt; k) // i/k的概率是否放入 selected[rand.nextInt(k)] = N; // 1/k的概率随机丢弃一个旧的，放入新的 &#125; return selected;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"随机数组打印","slug":"随机数组打印","date":"2018-02-25T06:05:56.000Z","updated":"2018-08-25T08:30:12.857Z","comments":true,"path":"2018/02/25/随机数组打印/","link":"","permalink":"https://lierabbit.cn/2018/02/25/随机数组打印/","excerpt":"","text":"给定一个长度为N且没有重复元素的数组arr和一个整数M，实现函数等概率随机打印arr中的M个数。 思路： 随机在[0，N-1]抽一个数打印，与N-1交换 随机在[0，N-2]抽一个数打印，与N-2交换 …… 123456789101112131415161718public int[] print(int[] arr, int N, int M) &#123; Random random = new Random(); int[] res = new int[M]; int randomValue; for (int i = 0; i &lt; M; i++) &#123; randomValue = random.nextInt(N - i); res[0] = arr[randomValue]; swap(arr, randomValue, N - i - 1); &#125; return res;&#125;public void swap(int[] arr, int i, int j) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"随机区间函数","slug":"随机区间函数","date":"2018-02-25T05:49:42.000Z","updated":"2018-08-25T08:30:17.577Z","comments":true,"path":"2018/02/25/随机区间函数/","link":"","permalink":"https://lierabbit.cn/2018/02/25/随机区间函数/","excerpt":"","text":"假设函数f()等概率随机返回一个在[0,1)范围上的浮点数，那么我们知道，在[0,x)区间上的数出现的概率为x(0&lt;x≤1)。给定一个大于0的整数k，并且可以使用f()函数，请实现一个函数依然返回在[0,1)范围上的数，但是在[0,x)区间上的数出现的概率为x的k次方。 思路：先来看看如何把[0，X )范围上的数，从概率X调整为概率X^2作法:调用两次f( )，返回较大的数即可。所以本题只用调用K次f( )，返回较大的数，即可。 12345678910111213private Random rand = new Random(12345);public double f() &#123; return rand.nextFloat();&#125;// 请调用f()函数实现public double random(int k, double x) &#123; double max = -1; for (int i = 0; i &lt; k; i++) max = Math.max(max, f()); return max;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"随机01","slug":"随机01","date":"2018-02-25T05:14:39.000Z","updated":"2018-08-25T08:16:40.812Z","comments":true,"path":"2018/02/25/随机01/","link":"","permalink":"https://lierabbit.cn/2018/02/25/随机01/","excerpt":"","text":"给定一个以p概率产生0，以1-p概率产生1的随机函数RandomP::f()，p是固定的值，但你并不知道是多少。除此之外也不能使用任何额外的随机机制，请用RandomP::f()实现等概率随机产生0和1的随机函数。 思路： f()产生0的概率P，产生1的概率1-P 产生01和10序列的概率都为P * (1-P ) 不断调用f(),直到能够产生01或10，序列终止。 如果产生了01，返回0。 如果产生了10，则返回1,即可。 123456789101112131415161718private static double p = new Random().nextFloat();// 随机概率ppublic static int f() &#123; return new Random().nextFloat() &lt; p ? 0 : 1;&#125;public int random01() &#123; // 通过f函数实现01等概率返回 int a; int b; while (true) &#123; a = f(); b = f(); if (a != b) return a &gt; b ? 1 : 0; &#125;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"随机函数","slug":"随机函数","date":"2018-02-25T05:02:24.000Z","updated":"2018-08-25T08:11:21.765Z","comments":true,"path":"2018/02/25/随机函数/","link":"","permalink":"https://lierabbit.cn/2018/02/25/随机函数/","excerpt":"","text":"给定一个等概率随机产生1~5的随机函数，除此之外，不能使用任何额外的随机机制，请实现等概率随机产生1~7的随机函数。(给定一个可调用的Random5::random()方法,可以等概率地随机产生1～5的随机函数) 思路：得到一串均匀分布且长度大于7的连续序列即可（甚至都不需要连续，只要保证能产生7个以上等概率的数即可），在这个序列里选中7个（或7的倍数个），若得到的数不是这7个中的，重新产生，这样这7个数的概率肯定是相同的。步骤：1.已经有等概率随机产生1、2、3、4、5的随机函数。2.根据步骤1得到的结果减1，将得到f( ) -&gt; 0、1、2、3、43.f( )x5 -&gt; 0、5、10、15、204.f( )x5+f () -&gt; 0、1、2、3、4…..24 注意这两个f( )是分别调用的，不要化简。5.如果步骤4产生的数大于20，则重复进行步骤4直到产生的结果在0~20之间。6.步骤5的结果将等概率随机产生0~20，所以步骤5的结果%7之后等概率产生0~6。7.步骤6的结果加1，将等概率产生1~7。 1234567891011121314private static Random rand = new Random(123456);// 随机产生[1,5]private int rand5() &#123; return 1 + rand.nextInt(5);&#125;// 通过rand5实现rand7public int randomNumber() &#123; int value = (rand5() - 1) * 5 + rand5() - 1; while (value &gt; 20) value = (rand5() - 1) * 5 + rand5() - 1; return value % 7 + 1;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"蚂蚁","slug":"蚂蚁","date":"2018-02-25T03:13:03.000Z","updated":"2018-08-25T07:48:33.014Z","comments":true,"path":"2018/02/25/蚂蚁/","link":"","permalink":"https://lierabbit.cn/2018/02/25/蚂蚁/","excerpt":"","text":"n只蚂蚁从正n边形的n个定点沿着边移动，速度是相同的，问它们碰头的概率是多少？给定一个正整数n，请返回一个数组，其中两个元素分别为结果的分子和分母，请化为最简分数。测试样例： 123返回：[3,4] 思路：如果蚂蚁移动方向不都相同，则必定碰头。只有全部顺时针或者逆时针方向移动才不会碰头 123456789101112131415161718192021222324public int[] collision(int n) &#123; // write code here int all = (int) Math.pow(2, n); int g = gcd(all, all - 2); int[] res = new int[2]; res[0] = (all - 2) / g; res[1] = all / g; return res;&#125;// 最大公约数public int gcd(int x, int y) &#123; int temp; while (y != 0) &#123; temp = y; y = x % y; x = temp; &#125; return x;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"足球比赛","slug":"足球比赛","date":"2018-02-24T04:24:20.000Z","updated":"2018-08-25T07:47:26.554Z","comments":true,"path":"2018/02/24/足球比赛/","link":"","permalink":"https://lierabbit.cn/2018/02/24/足球比赛/","excerpt":"","text":"有2k只球队，有k-1个强队，其余都是弱队，随机把它们分成k组比赛，每组两个队，问两强相遇的概率是多大？给定一个数k，请返回一个数组，其中有两个元素，分别为最终结果的分子和分母，请化成最简分数测试样例： 124返回：[3,7] 思路：1.求出全部分组情况2.求出两强不相遇的情况3.全部分组-两强不相遇=两强相遇 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public int[] calc(int k) &#123; // write code here int all = 1; // 分组全部情况 int k2 = 2 * k; while (k2 != 0) &#123; all *= k2 - 1; k2 -= 2; &#125; int noTowStrong = C(k + 1, k - 1) * A(k - 1, k - 1); // 两强不相遇的情况 int[] res = new int[2]; res[0] = all - noTowStrong; res[1] = all; int g = gcd(res[0], res[1]); res[0] /= g; res[1] /= g; return res;&#125;// 最大公约数int gcd(int x, int y) &#123; while (y != 0) &#123; int t = y; y = x % y; x = t; &#125; return x;&#125;/** * 模拟C运算 * * @param down 下标 * @param up 上标 * @return */public int C(int down, int up) &#123; return A(down, up) / A(up, up);&#125;/** * 模拟A运算 * * @param down 下标 * @param up 上标 * @return */public int A(int down, int up) &#123; int data = 1; for (int i = 0; i &lt; up; i++) data *= down--; return data;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"错装信封","slug":"错装信封","date":"2018-02-24T03:46:24.000Z","updated":"2018-08-25T07:42:57.311Z","comments":true,"path":"2018/02/24/错装信封/","link":"","permalink":"https://lierabbit.cn/2018/02/24/错装信封/","excerpt":"","text":"有n个信封，包含n封信，现在把信拿出来，再装回去，要求每封信不能装回它原来的信封，问有多少种装法?给定一个整数n，请返回装发个数，为了防止溢出，请返回结果Mod 1000000007的值。保证n的大小小于等于300。测试样例： 122返回：1 思路：对于n封信按照题目要求的装法即为f(n)假设第n封信放入了第i个信封情况一:第i封信也放入了第n个信封中，后续为f(n-2)情况二:第i封信没放入了第n个信封中，后续为f(n-1)n封信放入i个信封，i的选择有(n-1)种所以总数为f(n)= (n-1)*(f(n-1)+f(n-2)) 1234567891011121314public int countWays(int n) &#123; // write code here if (n == 1) return 0; else if (n == 2) return 1; else &#123; int pre = 0, last = 1; for (int i = 3; i &lt;= n; ++i) &#123; int tmp = (int) ((long) (i - 1) * (long) (pre + last) % 1000000007); pre = last; last = tmp; &#125; return last; &#125;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"高矮排列","slug":"高矮排列","date":"2018-02-24T02:34:11.000Z","updated":"2018-08-25T07:39:29.781Z","comments":true,"path":"2018/02/24/高矮排列/","link":"","permalink":"https://lierabbit.cn/2018/02/24/高矮排列/","excerpt":"","text":"12个高矮不同的人，排成两排，每排必须是从矮到高排列，而且第二排比对应的第一排的人高，问排列方式有多少种？ 给定一个偶数n，请返回所求的排列方式个数。保证结果在int范围内。 测试样例： 121返回：1 思路：同进出栈 1234567891011121314151617181920212223242526272829public int countWays(int n) &#123; // write code here return C(n, n / 2) / (n / 2 + 1);&#125;/** * 模拟C运算 * * @param down 下标 * @param up 上标 * @return */public int C(int down, int up) &#123; return A(down, up) / A(up, up);&#125;/** * 模拟A运算 * * @param down 下标 * @param up 上标 * @return */public int A(int down, int up) &#123; int data = 1; for (int i = 0; i &lt; up; i++) data *= down--; return data;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"二叉树统计","slug":"二叉树统计","date":"2018-02-24T02:24:22.000Z","updated":"2018-08-25T07:36:25.056Z","comments":true,"path":"2018/02/24/二叉树统计/","link":"","permalink":"https://lierabbit.cn/2018/02/24/二叉树统计/","excerpt":"","text":"求n个无差别的节点构成的二叉树有多少种不同的结构？给定一个整数n，请返回不同结构的二叉树的个数。保证结果在int范围内。测试样例： 121返回：1 思路：假设n个无差别的节点构成不同的结构数为f(n)f(0)表示空树，所以规定种数为1种。以1节点为头时，结构数为1f(n-1).以2节点为头时，结构数为1f(n-2).以3节点为头时，结构数为f(2)f(n-3).以4节点为头时，结构数为f(3)f(n-4).以5节点为头时，结构数为f(4)f(n-5).。。。。。。。。。。。。。。。。假设n个无差别的节点构成不同的结构数为f(n)f(0)=1,f(1)=1,f(2)=2,f(3)=5时f(n)=f(0)f(n-1)+f(1)f(n-2)+f(3)f(n-4)+……..+ ……..+f(n-1)*f(0)=C(2n,n)/n+1 123456789101112131415161718192021222324252627282930public int countWays(int n) &#123; // write code here return C(2 * n, n) / (n + 1);&#125;/** * 模拟C运算 * * @param down 下标 * @param up 上标 * @return */public int C(int down, int up) &#123; return A(down, up) / A(up, up);&#125;/** * 模拟A运算 * * @param down 下标 * @param up 上标 * @return */public int A(int down, int up) &#123; int data = 1; for (int i = 0; i &lt; up; i++) data *= down--; return data;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"排队买票","slug":"排队买票","date":"2018-02-24T02:00:11.000Z","updated":"2018-08-25T07:33:26.515Z","comments":true,"path":"2018/02/24/排队买票/","link":"","permalink":"https://lierabbit.cn/2018/02/24/排队买票/","excerpt":"","text":"2n个人排队买票，n个人拿5块钱，n个人拿10块钱，票价是5块钱1张，每个人买一张票，售票员手里没有零钱，问有多少种排队方法让售票员可以顺利卖票。给定一个整数n，请返回所求的排队方案个数。保证结果在int范围内。测试样例： 121返回：1 思路：同进出栈，将持5元者到达视作将5元入栈，持10元者到达视作使栈中某5元出栈 123456789101112131415161718192021222324252627282930public int countWays(int n) &#123; // write code here return C(2 * n, n) / (n + 1);&#125;/** * 模拟C运算 * * @param down 下标 * @param up 上标 * @return */public int C(int down, int up) &#123; return A(down, up) / A(up, up);&#125;/** * 模拟A运算 * * @param down 下标 * @param up 上标 * @return */public int A(int down, int up) &#123; int data = 1; for (int i = 0; i &lt; up; i++) data *= down--; return data;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"括号序列","slug":"括号序列","date":"2018-02-24T01:19:10.000Z","updated":"2018-08-25T07:30:59.912Z","comments":true,"path":"2018/02/24/括号序列/","link":"","permalink":"https://lierabbit.cn/2018/02/24/括号序列/","excerpt":"","text":"假设有n对左右括号，请求出合法的排列有多少个？合法是指每一个括号都可以找到与之配对的括号，比如n=1时，()是合法的，但是)(为不合法。给定一个整数n，请返回所求的合法排列数。保证结果在int范围内。测试样例： 121返回：1 思路：同进出栈，只需将左括号看成进栈，右括号看成出栈 123456789101112131415161718192021222324252627282930public int countLegalWays(int n) &#123; // write code here return C(2 * n, n) / (n + 1);&#125;/** * 模拟C运算 * * @param down 下标 * @param up 上标 * @return */public int C(int down, int up) &#123; return A(down, up) / A(up, up);&#125;/** * 模拟A运算 * * @param down 下标 * @param up 上标 * @return */public int A(int down, int up) &#123; int data = 1; for (int i = 0; i &lt; up; i++) data *= down--; return data;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"进出栈","slug":"进出栈","date":"2018-02-24T00:35:15.000Z","updated":"2018-08-25T07:34:53.710Z","comments":true,"path":"2018/02/24/进出栈/","link":"","permalink":"https://lierabbit.cn/2018/02/24/进出栈/","excerpt":"","text":"n个数进出栈的顺序有多少种？假设栈的容量无限大。给定一个整数n，请返回所求的进出栈顺序个数。保证结果在int范围内。测试样例： 121返回：1 常规分析：首先，我们设f（n）=序列个数为n的出栈序列种数。（我们假定，最后出栈的元素为k，显然，k取不同值时的情况是相互独立的，也就是求出每种k最后出栈的情况数后可用加法原则，由于k最后出栈，因此，在k入栈之前，比k小的值均出栈，此处情况有f(k-1)种，而之后比k大的值入栈，且都在k之前出栈，因此有f(n-k)种方式，由于比k小和比k大的值入栈出栈情况是相互独立的，此处可用乘法原则，f(n-k)*f(k-1)种，求和便是Catalan递归式）首次出空之前第一个出栈的序数k将1~n的序列分成两个序列，其中一个是1~k-1，序列个数为k-1，另外一个是k+1~n，序列个数是n-k。此时，我们若把k视为确定一个序数，那么根据乘法原理，f（n）的问题就等价于——序列个数为k-1的出栈序列种数乘以序列个数为n - k的出栈序列种数，即选择k这个序数的f（n）=f（k-1）×f（n-k）。而k可以选1到n，所以再根据加法原理，将k取不同值的序列种数相加，得到的总序列种数为：f（n）=f（0）f（n-1）+f（1）f（n-2）+……+f（n-1）f（0）。看到此处，再看看卡特兰数的递推式，答案不言而喻，即为f（n）=h（n）= C（2n,n）/（n+1）= c（2n,n）-c（2n,n-1）（n=0，1，2，……）。最后，令f（0）=1，f（1）=1。 非常规分析：对于每一个数来说，必须进栈一次、出栈一次。我们把进栈设为状态‘1’，出栈设为状态‘0’。n个数的所有状态对应n个1和n个0组成的2n位二进制数。由于等待入栈的操作数按照1‥n的顺序排列、入栈的操作数b大于等于出栈的操作数a(a≤b)，因此输出序列的总数目=由左而右扫描由n个1和n个0组成的2n位二进制数，1的累计数不小于0的累计数的方案种数。在2n位二进制数中填入n个1的方案数为c(2n,n),不填1的其余n位自动填0。从中减去不符合要求（由左而右扫描，0的累计数大于1的累计数）的方案数即为所求。不符合要求的数的特征是由左而右扫描时，必然在某一奇数位2m+1位上首先出现m+1个0的累计数和m个1的累计数，此后的2(n-m)-1位上有n-m个 1和n-m-1个0。如若把后面这2(n-m)-1位上的0和1互换，使之成为n-m个0和n-m-1个1，结果得1个由n+1个0和n-1个1组成的2n位数，即一个不合要求的数对应于一个由n+1个0和n-1个1组成的排列。反过来，任何一个由n+1个0和n-1个1组成的2n位二进制数，由于0的个数多2个，2n为偶数，故必在某一个奇数位上出现0的累计数超过1的累计数。同样在后面部分0和1互换，使之成为由n个0和n个1组成的2n位数，即n+1个0和n-1个1组成的2n位数必对应一个不符合要求的数。因而不合要求的2n位数与n+1个0，n－1个1组成的排列一一对应。显然，不符合要求的方案数为c(2n,n+1)。由此得出输出序列的总数目=c(2n,n)-c(2n,n+1)=c(2n,n)/(n+1)=h(n)。 1234567891011121314151617181920212223242526272829public int countWays(int n) &#123; // write code here return C(2 * n, n) / (n + 1);&#125;/** * 模拟C运算 * * @param down 下标 * @param up 上标 * @return */public int C(int down, int up) &#123; return A(down, up) / A(up, up);&#125;/** * 模拟A运算 * * @param down 下标 * @param up 上标 * @return */public int A(int down, int up) &#123; int data = 1; for (int i = 0; i &lt; up; i++) data *= down--; return data;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"分糖果","slug":"分糖果","date":"2018-02-23T13:18:04.000Z","updated":"2018-08-25T07:21:48.909Z","comments":true,"path":"2018/02/23/分糖果/","link":"","permalink":"https://lierabbit.cn/2018/02/23/分糖果/","excerpt":"","text":"n颗相同的糖果，分给m个人，每人至少一颗，问有多少种分法。给定n和m，请返回方案数，保证n小于等于12，且m小于等于n。测试样例： 1210,3返回：36 思路：如果有10颗，要分给3个人，则相当于在10颗糖中插入两个挡板，分出三个部分，则C(9，2) = 36种 123456789101112131415161718192021222324252627282930public int getWays(int n, int m) &#123; // write code here return C(n - 1, m - 1);&#125;/** * 模拟C运算 * * @param down 下标 * @param up 上标 * @return */public int C(int down, int up) &#123; return A(down, up) / A(up, up);&#125;/** * 模拟A运算 * * @param down 下标 * @param up 上标 * @return */public int A(int down, int up) &#123; int data = 1; for (int i = 0; i &lt; up; i++) data *= down--; return data;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"孤傲的A","slug":"孤傲的A","date":"2018-02-23T13:09:07.000Z","updated":"2018-08-25T07:16:45.859Z","comments":true,"path":"2018/02/23/孤傲的A/","link":"","permalink":"https://lierabbit.cn/2018/02/23/孤傲的A/","excerpt":"","text":"A(A也是他的编号)是一个孤傲的人，在一个n个人(其中编号依次为1到n)的队列中，他于其中的标号为b和标号c的人都有矛盾，所以他不会和他们站在相邻的位置。现在问你满足A的要求的对列有多少种？给定人数n和三个人的标号A,b和c，请返回所求答案，保证人数小于等于11且大于等于3。测试样例： 126,1,2,3288 思路：1.统计全排列情况2.统计ab，ac相邻的情况3.因为ab，ac相邻包含了bac，cab，所以要统计bac，cab的情况4.全排列-ab-ac+bac+cab即为结果 12345678910111213141516171819202122public int getWays(int n, int a, int b, int c) &#123; // write code here int ab = A(n - 1, n - 1) * 2; // ab相邻的情况分为ab,ba两种 int bac = A(n - 2, n - 2) * 2; // bac相邻的情况有bac,cab两种 int all = A(n, n); // 全排列 return all - ab * 2 + bac; // ac与ab一致所以ab*2&#125;/** * 模拟A运算 * * @param down 下标 * @param up 上标 * @return */public int A(int down, int up) &#123; int data = 1; for (int i = 0; i &lt; up; i++) data *= down--; return data;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"站队问题","slug":"站队问题","date":"2018-02-23T12:26:32.000Z","updated":"2018-08-25T07:13:27.388Z","comments":true,"path":"2018/02/23/站队问题/","link":"","permalink":"https://lierabbit.cn/2018/02/23/站队问题/","excerpt":"","text":"n个人站队，他们的编号依次从1到n，要求编号为a的人必须在编号为b的人的左边，但不要求一定相邻，请问共有多少种排法？第二问如果要求a必须在b的左边，并且一定要相邻，请问一共有多少种排法？给定人数n及两个人的编号a和b，请返回一个两个元素的数组，其中两个元素依次为两个问题的答案。保证人数小于等于10。测试样例： 127,1,2返回：[2520,720] 思路： 12345678910111213141516171819202122public int[] getWays(int n, int a, int b) &#123; // write code here int[] res = new int[2]; res[0] = A(n, n) / 2; res[1] = A(n - 1, n - 1); return res;&#125;/** * 模拟A运算 * * @param down 下标 * @param up 上标 * @return */public int A(int down, int up) &#123; int data = 1; for (int i = 0; i &lt; up; i++) data *= down--; return data;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"方格移动","slug":"方格移动","date":"2018-02-23T11:00:06.000Z","updated":"2018-08-25T07:09:42.730Z","comments":true,"path":"2018/02/23/方格移动/","link":"","permalink":"https://lierabbit.cn/2018/02/23/方格移动/","excerpt":"","text":"在XxY的方格中，以左上角格子为起点，右下角格子为终点，每次只能向下走或者向右走，请问一共有多少种不同的走法给定两个正整数int x,int y，请返回走法数目。保证x＋y小于等于12。测试样例： 122,2返回：2 思路：一共走x-1+y-1步，其中必然有y-1步向下，则C(x-1+y-1,y-1)第一个为下标，第二个为上标 1234567891011121314151617181920212223242526272829303132public int countWays(int x, int y) &#123; // write code here --x; --y; return C(x + y, y);&#125;/** * 模拟C运算 * * @param down 下标 * @param up 上标 * @return */public int C(int down, int up) &#123; return A(down, up) / A(up, up);&#125;/** * 模拟A运算 * * @param down 下标 * @param up 上标 * @return */public int A(int down, int up) &#123; int data = 1; for (int i = 0; i &lt; up; i++) data *= down--; return data;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"寻找奇数出现II","slug":"寻找奇数出现II","date":"2018-02-23T07:20:24.000Z","updated":"2018-08-25T07:08:34.798Z","comments":true,"path":"2018/02/23/寻找奇数出现II/","link":"","permalink":"https://lierabbit.cn/2018/02/23/寻找奇数出现II/","excerpt":"","text":"给定一个整型数组arr，其中有两个数出现了奇数次，其他的数都出现了偶数次，找到这两个数。要求时间复杂度为O(N)，额外空间复杂度为O(1)。给定一个整形数组arr及它的大小n，请返回一个数组，其中两个元素为两个出现了奇数次的元素,请将他们按从小到大排列。测试样例： 12[1,2,4,4,2,1,3,5],8返回：[3,5] 思路： 1234567891011121314151617181920212223public int[] findOdds(int[] arr, int n) &#123; // write code here int k1 = 0; int k2 = 0; for (int a : arr) // 假设出现奇数次的两个数为a,b则，k1 = a ^ b k1 ^= a; int rightOne = k1 &amp; (~k1 + 1); // 获取k1的二进制最右边第一个1 for (int a : arr) // 最后k2为a或者b if ((rightOne &amp; a) != 0) // 只有和rightOne在相同位一致的数才有可能是a或b k2 ^= a; int small = Math.min(k2, k1 ^ k2); int big = Math.max(k2, k1 ^ k2); int[] res = new int[2]; res[0] = small; res[1] = big; return res;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"寻找奇数出现","slug":"寻找奇数出现","date":"2018-02-23T06:53:41.000Z","updated":"2018-08-25T07:05:37.674Z","comments":true,"path":"2018/02/23/寻找奇数出现/","link":"","permalink":"https://lierabbit.cn/2018/02/23/寻找奇数出现/","excerpt":"","text":"有一个整型数组A，其中只有一个数出现了奇数次，其他的数都出现了偶数次，请打印这个数。要求时间复杂度为O(N)，额外空间复杂度为O(1)。给定整形数组A及它的大小n，请返回题目所求数字。测试样例： 12[1,2,3,2,1],5返回：3 思路：由于0 ^ n = nn ^ n = 0只要让0^数组里每个元素，最后得到的数就是只出现奇数次的数 12345678public int findOdd(int[] A, int n) &#123; // write code here int temp = 0; for (int a : A) temp ^= a; return temp;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"比较","slug":"比较","date":"2018-02-23T06:39:41.000Z","updated":"2018-08-25T07:02:17.010Z","comments":true,"path":"2018/02/23/比较/","link":"","permalink":"https://lierabbit.cn/2018/02/23/比较/","excerpt":"","text":"对于两个32位整数a和b，请设计一个算法返回a和b中较大的。但是不能用任何比较判断。若两数相同，返回任意一个。给定两个整数a和b，请返回较大的数。测试样例： 121,2返回：2 思路：本函数规定符号位：1非负，0负若a，b符号不同，返回aa符号位+bb符号位，防止溢出若a，b符号相同，使用a-b的符号位c，即返回ac+b(-c) 1234567891011121314151617181920212223public int getMax(int a, int b) &#123; // write code here int c = a - b; int as = sign(a); // 1表示非负，0表示负数 int bs = sign(b); int cs = sign(c); int disab = as ^ bs; // ab符号不相同为1，相同为0 int sameab = flip(disab); // ab符号相同为1，不相同为0 int returnA = disab * as + sameab * cs; int returnB = flip(returnA); return returnA * a + returnB * b;&#125;// 获取int符号位public int sign(int n) &#123; return flip((n &gt;&gt; 31) &amp; 1);&#125;// 反转位public int flip(int n) &#123; return n ^ 1;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"交换","slug":"交换","date":"2018-02-23T06:08:16.000Z","updated":"2018-08-25T06:45:14.594Z","comments":true,"path":"2018/02/23/交换/","link":"","permalink":"https://lierabbit.cn/2018/02/23/交换/","excerpt":"","text":"请编写一个算法，不用任何额外变量交换两个整数的值。给定一个数组num，其中包含两个值，请不用任何额外变量交换这两个值，并将交换后的数组返回。测试样例： 12[1,2]返回：[2,1] 思路：使用异或进行交换例如 a = a0, b = b0a = a ^ b，则a = a0 ^ b0b = a ^ b，则b = a0 ^ b0 ^ b0 = a0a = a ^ b，则a = a0 ^ b0 ^ a0 = b0至此交换完成 12345678public int[] getSwap(int[] num) &#123; // write code here num[0] = num[0] ^ num[1]; num[1] = num[0] ^ num[1]; num[0] = num[0] ^ num[1]; return num;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"最大二叉子树","slug":"最大二叉子树","date":"2018-02-23T05:36:11.000Z","updated":"2018-08-25T06:26:47.536Z","comments":true,"path":"2018/02/23/最大二叉子树/","link":"","permalink":"https://lierabbit.cn/2018/02/23/最大二叉子树/","excerpt":"","text":"有一棵二叉树，其中所有节点的值都不一样,找到含有节点最多 的搜索二叉子树,并返回这棵子树的头节点.给定二叉树的头结点root，请返回所求的头结点,若出现多个节点最多的子树，返回头结点权值最大的。 思路：以节点node为头的树中，最大的搜索二叉子树只可能来自以下两种情况:1.来自node左子树上的最大搜索二叉子树是以node左孩子为头的，并且来自node右子树上的最大搜索二叉子树是以node右孩子为头的，node左子树上的最大搜索二叉子树的最大值小于node的节点值，node右子树上的最大搜索二叉子树的最小值大于node的节点值，那么以节点node为头的整棵树都是搜索二叉树。2.如果不满足第1种情况，说明以节点node为头的树整体不能连成搜索二叉树。这种情况下，以node为头的树上的最大搜索二叉子树是来自node的左子树上的最大搜索二叉子树和来自node的右子树上的最大搜索二叉子树之间，节点数较多的那个。 12345678910111213141516171819202122232425262728293031323334public TreeNode getMax(TreeNode root) &#123; // write code here return getMax(root, new int[3]);&#125;public TreeNode getMax(TreeNode node, int[] temp) &#123; if (node == null) &#123; temp[0] = Integer.MAX_VALUE; // 最小值取最大值，这样所有的数都能比它小 temp[1] = Integer.MIN_VALUE; // 最大值取最小值，这样所有的数都能比它大 temp[2] = 0; return null; &#125; TreeNode lMaxNode = getMax(node.left, temp); int lMin = temp[0]; // 最小值 int lMax = temp[1]; // 最大值 int lNum = temp[2]; // 节点数 TreeNode rMaxNode = getMax(node.right, temp); int rMin = temp[0]; int rMax = temp[1]; int rNum = temp[2]; temp[0] = Math.min(lMin, node.val); // 更新最小值 temp[1] = Math.max(rMax, node.val); // 更新最大值 if (lMaxNode == node.left &amp;&amp; rMaxNode == node.right &amp;&amp; lMax &lt; node.val &amp;&amp; rMin &gt; node.val) &#123; temp[2] = lNum + rNum + 1; // 更新节点数 return node; &#125; else &#123; temp[2] = Math.max(lNum, rNum); return lNum &gt; rNum ? lMaxNode : rMaxNode; // 当相等的时候取右边的，因为右边的权值大 &#125;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"树上最远距离","slug":"树上最远距离","date":"2018-02-22T15:04:52.000Z","updated":"2018-08-24T14:30:34.072Z","comments":true,"path":"2018/02/22/树上最远距离/","link":"","permalink":"https://lierabbit.cn/2018/02/22/树上最远距离/","excerpt":"","text":"从二叉树的节点A出发，可以向上或者向下走，但沿途的节点只能经过一次，当到达节点B时，路径上的节点数叫作A到B的距离。对于给定的一棵二叉树，求整棵树上节点间的最大距离。给定一个二叉树的头结点root，请返回最大距离。保证点数大于等于2小于等于500. 思路：一个以h为头的树上,最大距离只可能来自以下三种情况:1.h的左子树上的最大距离2.h的右子树上的最大距离3.h左子树上离h左孩子最远的距离，加上h自身这个节点，再加h右子树上离h右孩子的最远距离，也就是两个节点分别来自h两侧子树的情况三个值中最大的那个就是以h为头的整棵树上最远的距离。 123456789101112131415161718192021public int findLongest(TreeNode root) &#123; int[] temp = new int[1]; return find(root, temp);&#125;public int find(TreeNode node, int[] temp) &#123; if (node == null) &#123; temp[0] = 0; return 0; &#125; int lMax = find(node.left, temp); int maxFormLeft = temp[0]; int rMax = find(node.right, temp); int maxFormRight = temp[0]; int cMax = maxFormLeft + maxFormRight + 1; temp[0] = Math.max(maxFormLeft, maxFormRight) + 1; return Math.max(Math.max(lMax, rMax), cMax);&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"寻找错误节点","slug":"寻找错误节点","date":"2018-02-22T15:01:03.000Z","updated":"2018-08-24T14:23:50.260Z","comments":true,"path":"2018/02/22/寻找错误节点/","link":"","permalink":"https://lierabbit.cn/2018/02/22/寻找错误节点/","excerpt":"","text":"一棵二叉树原本是搜索二叉树，但是其中有两个节点调换了位置，使得这棵二叉树不再是搜索二叉树，请找到这两个错误节点并返回他们的值。保证二叉树中结点的值各不相同。给定一棵树的根结点，请返回两个调换了位置的值，其中小的值在前。 思路： 对二叉树进行中序遍历，依次出现的节点值会一直升序，如果两个节点值错了，会出现降序。 如果在中序遍历时节点值出现了两次降序，第一个错误的节点为第一次降序时较大的节点，第二个错误的节点为第二次降序时较小的节点。 如果在中序遍历时节点值只出现了一次降序，第一个错误的节点为这次降序时较大的节点，第二个错误的节点为这次降序时较小的节点。 12345678910111213141516171819202122232425262728293031323334public int[] findError(TreeNode root) &#123; // write code here int[] result = new int[2]; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode cur = root; TreeNode preNode = null; // 上一个打印节点 TreeNode curNode; // 当前打印节点 int count = 0; while (cur != null || !stack.empty()) &#123; if (cur == null) &#123; curNode = stack.pop(); if (preNode != null) &#123; if (preNode.val &gt; curNode.val) &#123; count++; if (count == 1) &#123; result[0] = curNode.val; result[1] = preNode.val; &#125; else &#123; result[0] = curNode.val; &#125; &#125; &#125; preNode = curNode; cur = curNode.right; &#125; else &#123; stack.add(cur); cur = cur.left; &#125; &#125; return result;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"折纸","slug":"折纸","date":"2018-02-22T14:25:00.000Z","updated":"2018-08-24T14:21:18.670Z","comments":true,"path":"2018/02/22/折纸/","link":"","permalink":"https://lierabbit.cn/2018/02/22/折纸/","excerpt":"","text":"请把纸条竖着放在桌⼦上，然后从纸条的下边向上⽅对折，压出折痕后再展 开。此时有1条折痕，突起的⽅向指向纸条的背⾯，这条折痕叫做“下”折痕 ；突起的⽅向指向纸条正⾯的折痕叫做“上”折痕。如果每次都从下边向上⽅ 对折，对折N次。请从上到下计算出所有折痕的⽅向。给定折的次数n,请返回从上到下的折痕的数组，若为下折痕则对应元素为”down”,若为上折痕则为”up”.测试样例： 121返回：[&quot;down&quot;] 思路： 1234567891011121314151617181920212223242526272829public String[] foldPaper(int n) &#123; // write code here List&lt;String&gt; temp = new ArrayList&lt;&gt;(); fold(1, n, true, temp); int resultSize = temp.size(); String[] result = new String[resultSize]; resultSize--; while (resultSize &gt;= 0) &#123; result[resultSize] = temp.get(resultSize); resultSize--; &#125; return result;&#125;/** * 模拟右中左遍历 * @param level 层数 * @param high 高度 * @param down 是否是down * @param res 结果 */public void fold(int level, int high, boolean down, List&lt;String&gt; res) &#123; if (level &gt; high) return; fold(level + 1, high, true, res); res.add(down ? \"down\" : \"up\"); fold(level + 1, high, false, res);&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"完全二叉树判断","slug":"完全二叉树判断","date":"2018-02-22T13:35:08.000Z","updated":"2018-08-24T14:14:30.570Z","comments":true,"path":"2018/02/22/完全二叉树判断/","link":"","permalink":"https://lierabbit.cn/2018/02/22/完全二叉树判断/","excerpt":"","text":"有一棵二叉树,请设计一个算法判断它是否是完全二叉树。给定二叉树的根结点root，请返回一个bool值代表它是否为完全二叉树。树的结点个数小于等于500。 思路： 采用按层遍历二叉树的方式，从每层的左边向右边依次遍历所有的节点 如果当前节点有右孩子，但没有左孩子，直接返回false 如果当前节点并不是左右孩子全有，那之后的节点必须都为叶节点，否则返回false 遍历过程中如果不返回false，遍历结束后返回true即可 12345678910111213141516171819202122232425public boolean chk(TreeNode root) &#123; // write code here Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); TreeNode node; boolean isCheckLeaf = false; // 是否检查是叶子节点 while (!queue.isEmpty()) &#123; node = queue.poll(); if (node.left == null) &#123; // 有右孩子，必须有左孩子 if (node.right != null) return false; &#125; else &#123; if (isCheckLeaf) return false; else queue.add(node.left); &#125; if (node.right == null) &#123; // 当前节点右孩子为空则以后的节点都是叶子节点 isCheckLeaf = true; &#125; else &#123; queue.add(node.right); &#125; &#125; return true;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"平衡二叉树判断","slug":"平衡二叉树判断","date":"2018-02-22T12:25:16.000Z","updated":"2018-08-24T14:14:32.485Z","comments":true,"path":"2018/02/22/平衡二叉树判断/","link":"","permalink":"https://lierabbit.cn/2018/02/22/平衡二叉树判断/","excerpt":"","text":"有一棵二叉树,请设计一个算法判断它是否是完全二叉树。给定二叉树的根结点root，请返回一个bool值代表它是否为完全二叉树。树的结点个数小于等于500。 平衡二叉树（Self-balancing binary search tree）又被称为AVL树（有别于AVL算法），且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树 思路：递归分别获取左右子树深度，然后进行高度差判断 123456789101112131415161718192021public boolean check(TreeNode root) &#123; // write code here boolean[] result = new boolean[1]; result[0] = true; getHeight(root, 1, result); return result[0];&#125;public int getHeight(TreeNode node, int level, boolean[] res) &#123; if (node == null) return level; int lh = getHeight(node.left, level + 1, res); if (!res[0]) return level; int rh = getHeight(node.right, level + 1, res); if (!res[0]) return level; if (Math.abs(lh - rh) &gt; 1) res[0] = false; return Math.max(lh, rh);&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"二叉树的序列化","slug":"二叉树的序列化","date":"2018-02-22T09:54:03.000Z","updated":"2018-08-24T14:06:54.733Z","comments":true,"path":"2018/02/22/二叉树的序列化/","link":"","permalink":"https://lierabbit.cn/2018/02/22/二叉树的序列化/","excerpt":"","text":"首先我们介绍二叉树先序序列化的方式，假设序列化的结果字符串为str，初始时str等于空字符串。先序遍历二叉树，如果遇到空节点，就在str的末尾加上“#!”，“#”表示这个节点为空，节点值不存在，当然你也可以用其他的特殊字符，“!”表示一个值的结束。如果遇到不为空的节点，假设节点值为3，就在str的末尾加上“3!”。现在请你实现树的先序序列化。给定树的根结点root，请返回二叉树序列化后的字符串。 思路：用先序遍历即可 为什么要用“#!” 1234567891011121314151617public String toString(TreeNode root) &#123; // write code here StringBuilder stringBuilder = new StringBuilder(); preOrderWalk(root, stringBuilder); return stringBuilder.toString();&#125;public void preOrderWalk(TreeNode node, StringBuilder builder) &#123; if (node == null) builder.append(\"#!\"); else &#123; builder.append(node.val).append(\"!\"); preOrderWalk(node.left, builder); preOrderWalk(node.right, builder); &#125;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"二叉树的打印","slug":"二叉树的打印","date":"2018-02-22T09:38:22.000Z","updated":"2018-08-24T14:00:01.365Z","comments":true,"path":"2018/02/22/二叉树的打印/","link":"","permalink":"https://lierabbit.cn/2018/02/22/二叉树的打印/","excerpt":"","text":"有一棵二叉树，请设计一个算法，按照层次打印这棵二叉树。给定二叉树的根结点root，请返回打印结果，结果按照每一层一个数组进行储存，所有数组的顺序按照层数从上往下，且每一层的数组内元素按照从左往右排列。保证结点数小于等于500。 思路：使用队列保存按行从左往右的节点，使用last记录当前行的最右节点，使用nLast表示下一行的最右节点，当队列弹出的节点等于last表示当前行以打印完毕，进行换行 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public int[][] printTree(TreeNode root) &#123; // write code here Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); List&lt;List&lt;Integer&gt;&gt; datas = new ArrayList&lt;&gt;(); List&lt;Integer&gt; rowData = new ArrayList&lt;&gt;(); queue.add(root); TreeNode last = root; TreeNode nLast = null; TreeNode node; TreeNode left; TreeNode right; while (!queue.isEmpty()) &#123; node = queue.poll(); left = node.left; if (left != null) &#123; queue.add(left); nLast = left; &#125; right = node.right; if (right != null) &#123; queue.add(right); nLast = right; &#125; rowData.add(node.val); if (last == node) &#123; datas.add(rowData); rowData = new ArrayList&lt;&gt;(); last = nLast; &#125; &#125; int row = datas.size(); int[][] result = new int[row][]; for (int i = 0; i &lt; row; i++) &#123; List&lt;Integer&gt; colDatas = datas.get(i); int col = colDatas.size(); int[] colResult = new int[col]; for (int j = 0; j &lt; col; j++) &#123; colResult[j] = colDatas.get(j); &#125; result[i] = colResult; &#125; return result;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"非递归二叉树的序列打印","slug":"非递归二叉树的序列打印","date":"2018-02-22T08:31:40.000Z","updated":"2018-08-24T13:55:51.966Z","comments":true,"path":"2018/02/22/非递归二叉树的序列打印/","link":"","permalink":"https://lierabbit.cn/2018/02/22/非递归二叉树的序列打印/","excerpt":"","text":"非递归方式实现先序遍历1.首先申请一个新的栈，记为stack。2.然后将头节点head压入stack中。3.每次从stack中弹出栈顶节点，记为cur,然后打印cur节点的值。如果cur右孩子不为空的话，将cur的右孩子先压入stack中。最后如果cur的左孩子不为空的话，将cur的左孩子压入stack中。4.不断重复步骤3 ,直到stack为空，全部过程结束。 非递归方法实现中序遍历1.申请一个新的栈，记为stack,申请一个变量cur,初始时令cur等于头节点。2.先把cur节点压入栈中，对以cur节点为头的整棵子树来说，依次把整棵树的左边界压入栈中，即不断令cur=cur.left,然后重复步骤2。3.不断重复步骤2,直到发现cur为空，此时从stack中弹出一个节点，记为node。打印node的值，并让cur=node.right,然后继续重复步骤2。4.当stack为空并且cur为空时，整个过程结束。 非递归方法实现后序遍历使用两个栈实现1.申请一个栈，记为Si,然后将头节点压入si中。2.从si中弹出的节点记为cur,然后先把cur的左孩子压入si中，然后把curl的右孩子压入si中。3.在整个过程中，每一个从si中弹出的节点都放进第二个栈s2中。4.不断重复步骤2和步骤3,直到si为空，过程停止。5.从s2中依次弹出节点并打印，打印的顺序就是后序遍历的顺序了。 使用一个栈实现1.申请一个栈,记为stack,将头节点压入stack，同时设置两个变量h和C。在整个流程中,h代表最近一次弹出并打印的节点,c代表当前stack的栈顶节点,初始时令h为头节点,c为null.2.每次令c等于当前stack的栈顶节点,但是不从stack中弹出节点,此时分以下三种情况。 (1)如果c的左孩子不为空,并且h不等于c的左孩子，也不等于c的右孩子,则把c的左孩子压入stack中。 (2)如果情况1不成立,并且c的右孩子不为空，并且h不等于c的右孩子,则把c的右孩子压入stack中。 (3)如果情况1和情况2都不成立,那么从stack中弹出c并打印,然后令h等于C。3.一直重复步骤2 ,直到stack为空,过程停止。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990public int[][] convert(TreeNode root) &#123; // write code here int[][] result = new int[3][]; for (int i = 0; i &lt; 3; i++) &#123; List&lt;Integer&gt; tempList = new ArrayList&lt;&gt;(); if (i == 0) preOrderWalk(root, tempList); else if (i == 1) midOrderWalk(root, tempList); else backOrderWalk2(root, tempList); int dataSize = tempList.size(); int data[] = new int[dataSize]; for (int index = 0; index &lt; dataSize; index++) data[index] = tempList.get(index); result[i] = data; &#125; return result;&#125;// 先序遍历public void preOrderWalk(TreeNode root, List result) &#123; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.add(root); while (!stack.isEmpty()) &#123; TreeNode node = stack.pop(); result.add(node.val); if (node.right != null) stack.add(node.right); if (node.left != null) stack.add(node.left); &#125;&#125;// 中序遍历public void midOrderWalk(TreeNode root, List result) &#123; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode cur = root; TreeNode node; while (cur != null || !stack.isEmpty()) &#123; if (cur == null) &#123; node = stack.pop(); result.add(node.val); cur = node.right; &#125; else &#123; stack.add(cur); cur = cur.left; &#125; &#125;&#125;// 后序遍历1public void backOrderWalk1(TreeNode root, List result) &#123; Stack&lt;TreeNode&gt; s1 = new Stack&lt;&gt;(); Stack&lt;TreeNode&gt; s2 = new Stack&lt;&gt;(); s1.add(root); TreeNode cur; while (!s1.isEmpty()) &#123; cur = s1.pop(); s2.add(cur); if (cur.left != null) s1.add(cur.left); if (cur.right != null) s1.add(cur.right); &#125; while (!s2.isEmpty()) result.add(s2.pop().val);&#125;// 后序遍历2public void backOrderWalk2(TreeNode root, List result) &#123; Stack&lt;TreeNode&gt; s1 = new Stack&lt;&gt;(); s1.add(root); TreeNode h = root; TreeNode c; while (!s1.isEmpty()) &#123; c = s1.peek(); if (c.left != null &amp;&amp; h != c.left &amp;&amp; h != c.right) s1.add(c.left); else if (c.right != null &amp;&amp; h != c.right) s1.add(c.right); else &#123; h = s1.pop(); result.add(h.val); &#125; &#125;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"递归二叉树的序列打印","slug":"递归二叉树的序列打印","date":"2018-02-22T06:51:08.000Z","updated":"2018-08-24T13:39:51.036Z","comments":true,"path":"2018/02/22/递归二叉树的序列打印/","link":"","permalink":"https://lierabbit.cn/2018/02/22/递归二叉树的序列打印/","excerpt":"","text":"请用非递归方式实现二叉树的先序、中序和后序的遍历打印。给定一个二叉树的根结点root，请依次返回二叉树的先序，中序和后续遍历(二维数组的形式)。 思路： 前序遍历：先访问根节点，再访问左子树，最后访问右子树，简称中左右 中序遍历：先访问左子树，再访问根节点，最后访问右子树，简称左中右 后序遍历：先访问左子树，再访问右子树，最后访问根节点，简称左右中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public int[][] convert(TreeNode root) &#123; // write code here int[][] result = new int[3][]; for (int i = 0; i &lt; 3; i++) &#123; List&lt;Integer&gt; tempList = new ArrayList&lt;&gt;(); if (i == 0) preOrderWalk(root, tempList); else if (i == 1) midOrderWalk(root, tempList); else backOrderWalk(root, tempList); int dataSize = tempList.size(); int data[] = new int[dataSize]; for (int index = 0; index &lt; dataSize; index++) data[index] = tempList.get(index); result[i] = data; &#125; return result;&#125;// 前序遍历public void preOrderWalk(TreeNode node, List&lt;Integer&gt; result) &#123; if (node == null) return; result.add(node.val); preOrderWalk(node.left, result); preOrderWalk(node.right, result);&#125;// 中序遍历public void midOrderWalk(TreeNode node, List&lt;Integer&gt; result) &#123; if (node == null) return; midOrderWalk(node.left, result); result.add(node.val); midOrderWalk(node.right, result);&#125;// 后序遍历public void backOrderWalk(TreeNode node, List&lt;Integer&gt; result) &#123; if (node == null) return; backOrderWalk(node.left, result); backOrderWalk(node.right, result); result.add(node.val);&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"快速N次方","slug":"快速N次方","date":"2018-02-22T05:59:39.000Z","updated":"2018-08-24T13:38:15.553Z","comments":true,"path":"2018/02/22/快速N次方/","link":"","permalink":"https://lierabbit.cn/2018/02/22/快速N次方/","excerpt":"","text":"如果更快的求一个整数k的n次方。如果两个整数相乘并得到结果的时间复杂度为O(1)，得到整数k的N次方的过程请实现时间复杂度为O(logN)的方法。给定k和n，请返回k的n次方，为了防止溢出，请返回结果Mod 1000000007的值。测试样例： 122,3返回：8 思路： 12345678910111213141516public int getPower(int a, int n) &#123; BigInteger res = BigInteger.valueOf(1); BigInteger temp = BigInteger.valueOf(a); while (n != 0) &#123; if ((n &amp; 1) == 1) &#123; res = res.multiply(temp); &#125; temp = temp.multiply(temp); res = res.mod(BigInteger.valueOf(1000000007)); temp = temp.mod(BigInteger.valueOf(1000000007)); n &gt;&gt;= 1; &#125; return res.intValue();&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"完全二叉树计数","slug":"完全二叉树计数","date":"2018-02-21T06:56:40.000Z","updated":"2018-08-24T13:21:13.573Z","comments":true,"path":"2018/02/21/完全二叉树计数/","link":"","permalink":"https://lierabbit.cn/2018/02/21/完全二叉树计数/","excerpt":"","text":"给定一棵完全二叉树的根节点root，返回这棵树的节点个数。如果完全二叉树的节点数为N，请实现时间复杂度低于O(N)的解法。给定树的根结点root，请返回树的大小。 思路：与二分查找相似，如果右子树的高度等于左子树高度则表示左子树是一棵满二叉树，可用公示计算左子树大小，然后遍历右子树重复本操作。如果不相等表示右子树是一棵满二叉树且比左子树低一层，可用公式计算右子树大小，然后遍历左子树重复本操作 12345678910111213141516171819202122232425public int count(TreeNode head) &#123; if (head == null) &#123; return 0; &#125; return bs(head, 1, mostLeftLevel(head, 1));&#125;public int bs(TreeNode node, int level, int high) &#123; if (level == high) return 1; // 如果右子树的高度等于左子树高度则表示左子树是一棵满二叉树，可用公示计算左子树大小（带头节点），然后遍历右子树重复本操作 if (mostLeftLevel(node.right, level + 1) == high) return (int) (Math.pow(2, high - level) + bs(node.right, level + 1, high)); else return (int) (Math.pow(2, high - level - 1) + bs(node.left, level + 1, high));&#125;// 获取高度public int mostLeftLevel(TreeNode node, int level) &#123; while (node != null) &#123; level++; node = node.left; &#125; return level - 1;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"最左原位","slug":"最左原位","date":"2018-02-21T06:52:57.000Z","updated":"2018-08-24T13:13:41.623Z","comments":true,"path":"2018/02/21/最左原位/","link":"","permalink":"https://lierabbit.cn/2018/02/21/最左原位/","excerpt":"","text":"有一个有序数组arr，其中不含有重复元素，请找到满足arr[i]==i条件的最左的位置。如果所有位置上的数都不满足条件，返回-1。给定有序数组arr及它的大小n，请返回所求值。测试样例： 12[-1,0,2,3],4返回：2 思路：使用二分查找 当arr[mid] &gt; mid，由于数组有序，从左往右元素每次递增&gt;=1，下标每次递增1，所以右边不会出现arr[i]==i的情况 当arr[mid] &lt; mid，由于数组有序，从右往左元素每次递减&gt;=1，下标每次递减1，所以左边不会出现arr[i]==i的情况 123456789101112131415161718192021public int findPos(int[] arr, int n) &#123; // write code here if (arr == null || arr.length == 0) return -1; int left = 0; int right = n - 1; int mid; int result = -1; while (left &lt;= right) &#123; mid = left + (right - left) / 2; if (arr[mid] == mid) &#123; // 继续搜索左边 result = mid; right = mid - 1; &#125; else if (arr[mid] &gt; mid) // 由于数组有序，从左往右元素每次递增&gt;=1，下标每次递增1，所以右边不会出现arr[i]==i的情况 right = mid - 1; else // 由于数组有序，从右往左元素每次递减&gt;=1，下标每次递减1，所以左边不会出现arr[i]==i的情况 left = mid + 1; &#125; return result;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"循环有序数组最小值","slug":"循环有序数组最小值","date":"2018-02-21T06:20:34.000Z","updated":"2018-08-24T13:06:26.352Z","comments":true,"path":"2018/02/21/循环有序数组最小值/","link":"","permalink":"https://lierabbit.cn/2018/02/21/循环有序数组最小值/","excerpt":"","text":"对于一个有序循环数组arr，返回arr中的最小值。有序循环数组是指，有序数组左边任意长度的部分放到右边去，右边的部分拿到左边来。比如数组[1,2,3,3,4]，是有序循环数组，[4,1,2,3,3]也是。给定数组arr及它的大小n，请返回最小值。测试样例： 12[4,1,2,3,3],5返回：1 思路： 使用二分查找，当局部列表有序返回头元素 当局部列表有序返回头元素 当局部列表头元素小于中间元素，这里有循环，也就是有最小值，搜索左边 当局部列表中间元素小于尾元素，这里有循环，也就是有最小值，搜索右边 当局部列表头元素等于中间元素等于尾元素，遍历寻找最小值 1234567891011121314151617181920212223242526272829303132333435public int getMin(int[] arr, int n) &#123; // write code here if (arr == null || arr.length == 0) return -1; else &#123; int left = 0; int right = arr.length - 1; int mid; while (left &lt; right) &#123; mid = left + (right - left) / 2; if (left == right - 1) // 只剩2个数时直接比较其大小 break; else if (arr[left] &lt; arr[right]) // 当局部列表有序返回头 return arr[left]; else if (arr[left] &gt; arr[mid]) // 当局部列表头元素大于中间元素，这里有循环，也就是有最小值，搜索左边 right = mid; else if (arr[mid] &gt; arr[right]) // 当局部列表中间元素大于尾元素，这里有循环，也就是有最小值，搜索右边 left = mid; else &#123; // 当局部列表头元素等于中间元素等于尾元素，遍历寻找最小值 while (left &lt; right) &#123; if (arr[left] == arr[mid]) left++; else if (arr[left] &lt; arr[mid]) return arr[left]; else &#123; right = mid; break; &#125; &#125; &#125; &#125; return Math.min(arr[left], arr[right]); &#125;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"元素最左出现","slug":"元素最左出现","date":"2018-02-21T05:20:15.000Z","updated":"2018-08-24T13:03:52.902Z","comments":true,"path":"2018/02/21/元素最左出现/","link":"","permalink":"https://lierabbit.cn/2018/02/21/元素最左出现/","excerpt":"","text":"对于一个有序数组arr，再给定一个整数num，请在arr中找到num这个数出现的最左边的位置。给定一个数组arr及它的大小n，同时给定num。请返回所求位置。若该元素在数组中未出现，请返回-1。测试样例： 12[1,2,3,3,4],5,3返回：2 思路：使用折半查找，当找到num后使用result记录当前找到的num位置，接着再对其左边进行搜索，直到搜索完毕，返回的result就是最左位置 123456789101112131415161718192021222324public int findPos(int[] arr, int n, int num) &#123; // write code here if (arr == null || n == 0) return -1; int left = 0; int right = n - 1; int mid; int result = -1; while (left &lt;= right) &#123; mid = left + (right - left) / 2; // 如果找到num，则对其左边继续搜索 if (arr[mid] == num) &#123; result = mid; right = mid - 1; &#125; else if (arr[mid] &gt; num) right = mid - 1; else left = mid + 1; &#125; return result;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"局部最小值位置","slug":"局部最小值位置","date":"2018-02-21T04:44:42.000Z","updated":"2018-08-24T10:16:21.123Z","comments":true,"path":"2018/02/21/局部最小值位置/","link":"","permalink":"https://lierabbit.cn/2018/02/21/局部最小值位置/","excerpt":"","text":"定义局部最小的概念。arr长度为1时，arr[0]是局部最小。arr的长度为N(N&gt;1)时，如果arr[0]&lt;arr[1]，那么arr[0]是局部最小；如果arr[N-1]&lt;arr[N-2]，那么arr[N-1]是局部最小；如果0&lt;i&lt;N-1，既有arr[i]&lt;arr[i-1]又有arr[i]&lt;arr[i+1]，那么arr[i]是局部最小。 给定无序数组arr，已知arr中任意两个相邻的数都不相等，写一个函数，只需返回arr中任意一个局部最小出现的位置即可。 思路：由于相邻数不相等，所以必定能分出大小，先找两头，接着使用二分查找从中间开始找起。 123456789101112131415161718192021222324public int getLessIndex(int[] arr) &#123; if (arr == null || arr.length == 0) return -1; if (arr.length == 1 || arr[0] &lt; arr[1]) return 0; if (arr[arr.length - 1] &lt; arr[arr.length - 2]) return arr.length - 1; int left = 1; int right = arr.length - 2; int mid; while (left &lt; right) &#123; mid = left + (right - left) / 2; // 如果mid大于左边的值，从中间往左边看是递减的，则局部最小值就在左边 if (arr[mid] &gt; arr[mid - 1]) right = mid - 1; // 如果mid大于右边的值，从中间往右边看是递减的，则局部最小值就在右边 else if (arr[mid] &gt; arr[mid + 1]) left = mid + 1; // 小于相邻值就是局部最小值 else return mid; &#125; return left;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"单链表相交判断","slug":"单链表相交判断","date":"2018-02-19T05:09:45.000Z","updated":"2018-08-24T10:11:34.427Z","comments":true,"path":"2018/02/19/单链表相交判断/","link":"","permalink":"https://lierabbit.cn/2018/02/19/单链表相交判断/","excerpt":"","text":"给定两个单链表的头节点head1和head2，如何判断两个链表是否相交？相交的话返回true，不想交的话返回false。给定两个链表的头结点head1和head2(注意，另外两个参数adjust0和adjust1用于调整数据,与本题求解无关)。请返回一个bool值代表它们是否相交。 思路：3种情况 两链表都是无环链表，若相交则尾节点必定一致 两链表都是有环链表，转圈寻找相交点 一个链表有环一个链表无环，必定不相交 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class TreeNode &#123; public int val = 0; public TreeNode left = null; public TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125; public boolean chkInter(ListNode head1, ListNode head2, int adjust0, int adjust1) &#123; // write code here if (head1 == null || head2 == null) return false; ListNode entryNode1 = find(head1); ListNode entryNode2 = find(head2); if (entryNode1 == null &amp;&amp; entryNode2 == null) &#123; // 两个链表都是无环链表，若相交尾节点必定一致 ListNode node1 = head1; ListNode node2 = head2; while (node1.next != null) node1 = node1.next; while (node2.next != null) node2 = node2.next; return node1 == node2; &#125; else if (entryNode1 != null &amp;&amp; entryNode2 != null) &#123; // 两个链表都是有环链表，转圈寻找相交点 if (entryNode1 == entryNode2) return true; ListNode cur = entryNode1.next; while (cur != entryNode1) &#123; if (cur == entryNode2) return true; cur = cur.next; &#125; return false; &#125; else &#123; // 一个有环一个无环，必定不相交 return false; &#125; &#125; // 寻找入环点 public ListNode find(ListNode head) &#123; ListNode fast = head; ListNode normal = head; while (fast.next != null &amp;&amp; fast.next.next != null) &#123; normal = normal.next; fast = fast.next.next; if (normal == fast) break; &#125; if (normal == fast) &#123; // 有环 fast = head; while (fast != normal) &#123; fast = fast.next; normal = normal.next; &#125; return fast; &#125; return null; &#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"有环单链表相交判断","slug":"有环单链表相交判断","date":"2018-02-19T05:06:14.000Z","updated":"2018-08-24T10:11:47.446Z","comments":true,"path":"2018/02/19/有环单链表相交判断/","link":"","permalink":"https://lierabbit.cn/2018/02/19/有环单链表相交判断/","excerpt":"","text":"如何判断两个有环单链表是否相交？相交的话返回第一个相交的节点，不想交的话返回空。如果两个链表长度分别为N和M，请做到时间复杂度O(N+M)，额外空间复杂度O(1)。给定两个链表的头结点head1和head2(注意，另外两个参数adjust0和adjust1用于调整数据,与本题求解无关)。请返回一个bool值代表它们是否相交。 思路： 在入环前相交，则入环点一致 在环里相交，则绕环转一圈寻找一致点 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class TreeNode &#123; public int val = 0; public TreeNode left = null; public TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125; public boolean chkInter(ListNode head1, ListNode head2, int adjust0, int adjust1) &#123; // write code here ListNode node1 = find(head1); ListNode node2 = find(head2); if(node1 == node2) return true; ListNode cur = node1.next; // 在环里寻找 while (node1 != cur)&#123; if(cur == node2) return true; cur = cur.next; &#125; return false; &#125; public ListNode find(ListNode head) &#123; // 找到入环点 ListNode fast = head; ListNode normal = head; while (fast.next != null &amp;&amp; fast.next.next != null) &#123; normal = normal.next; fast = fast.next.next; if (fast == normal) break; &#125; fast = head; while (fast != normal) &#123; fast = fast.next; normal = normal.next; &#125; return fast; &#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"无环单链表判相交","slug":"无环单链表判相交","date":"2018-02-19T05:02:04.000Z","updated":"2018-08-24T09:57:08.603Z","comments":true,"path":"2018/02/19/无环单链表判相交/","link":"","permalink":"https://lierabbit.cn/2018/02/19/无环单链表判相交/","excerpt":"","text":"现在有两个无环单链表，若两个链表的长度分别为m和n，请设计一个时间复杂度为O(n + m)，额外空间复杂度为O(1)的算法，判断这两个链表是否相交。给定两个链表的头结点headA和headB，请返回一个bool值，代表这两个链表是否相交。保证两个链表长度小于等于500。 思路：如果无环单链表相交则尾节点必定一致 1234567891011121314151617181920212223public class TreeNode &#123; public int val = 0; public TreeNode left = null; public TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125; public boolean chkIntersect(ListNode headA, ListNode headB) &#123; if (headA == null || headB == null) return false; ListNode nodeA = headA; ListNode nodeB = headB; while (nodeA.next != null) nodeA = nodeA.next; while (nodeB.next != null) nodeB = nodeB.next; return nodeA == nodeB; &#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"链表判环","slug":"链表判环","date":"2018-02-19T04:57:32.000Z","updated":"2018-08-24T09:53:47.025Z","comments":true,"path":"2018/02/19/链表判环/","link":"","permalink":"https://lierabbit.cn/2018/02/19/链表判环/","excerpt":"","text":"如何判断一个单链表是否有环？有环的话返回进入环的第一个节点的值，无环的话返回-1。如果链表的长度为N，请做到时间复杂度O(N)，额外空间复杂度O(1)。给定一个单链表的头结点head（注意另一个参数adjust为加密后的数据调整参数，方便数据设置，与本题求解无关)，请返回所求值。 思路：使用快慢指针，一个每次走一步，一个每次走两步，如果快慢指针相遇则有环，令快指针等于头节点，这次快指针和慢指针同步走，当他们再次相遇时就是入环点 1234567891011121314151617181920212223242526272829303132333435363738public class TreeNode &#123; public int val = 0; public TreeNode left = null; public TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125; public int chkLoop(ListNode head, int adjust) &#123; // write code here if (head == null) return -1; ListNode fast = head; ListNode normal = head; while (fast.next != null &amp;&amp; fast.next.next != null) &#123; normal = normal.next; fast = fast.next.next; if (fast == normal) break; &#125; if(fast == normal)&#123; fast = head; while (true)&#123; if(fast == normal) return fast.val; fast = fast.next; normal = normal.next; &#125; &#125; return -1; &#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"复杂链表的复制","slug":"复杂链表的复制","date":"2018-02-19T04:44:30.000Z","updated":"2018-08-24T09:51:18.438Z","comments":true,"path":"2018/02/19/复杂链表的复制/","link":"","permalink":"https://lierabbit.cn/2018/02/19/复杂链表的复制/","excerpt":"","text":"输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点） 思路：使用在原始元素后面插入克隆元素解决难以设置随机指针问题，第一次遍历在每个元素后面添加一个克隆元素，第二次遍历设置克隆元素的随机指针即原随机指针的下一个，第三次遍历分割出克隆链表 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class RandomListNode &#123; int label; RandomListNode next = null; RandomListNode random = null; RandomListNode(int label) &#123; this.label = label; &#125;&#125; public RandomListNode Clone(RandomListNode head) &#123; if (head == null) return null; RandomListNode cur = head; while (cur != null) &#123; // 在链表每个元素后面添加一个克隆元素 RandomListNode newNode = new RandomListNode(cur.label); newNode.next = cur.next; cur.next = newNode; cur = newNode.next; &#125; cur = head; RandomListNode newNode; while (cur != null) &#123; // 给每个克隆元素设置随机指针 newNode = cur.next; newNode.random = cur.random == null ? null : cur.random.next; cur = cur.next.next; &#125; cur = head; RandomListNode newHead = cur.next; RandomListNode next; while (cur != null) &#123; // 分割出克隆链表，还原原链表 next = cur.next.next; newNode = cur.next; newNode.next = next == null ? null : next.next; cur.next = next; cur = next; &#125; return newHead; &#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"链表的回文结构","slug":"链表的回文结构","date":"2018-02-19T04:36:55.000Z","updated":"2018-08-24T09:41:13.063Z","comments":true,"path":"2018/02/19/链表的回文结构/","link":"","permalink":"https://lierabbit.cn/2018/02/19/链表的回文结构/","excerpt":"","text":"请编写一个函数，检查链表是否为回文。给定一个链表ListNode* pHead，请返回一个bool，代表链表是否为回文。测试样例： 1234&#123;1,2,3,2,1&#125;返回：true&#123;1,2,3,2,3&#125;返回：false 思路：反转链表中间节点之后的节点，然后再进行对比，最后还原链表。注意：可以用快慢指针，一个每次走一步，一个每次都两步，直到快指针到尾结束，此时慢指针就是中间节点 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class TreeNode &#123; public int val = 0; public TreeNode left = null; public TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125; public boolean isPalindrome(ListNode head) &#123; // write code here if (head == null || head.next == null) return true; ListNode leftNode = head; ListNode rightNode = head; while (rightNode.next != null &amp;&amp; rightNode.next.next != null) &#123;// 找到中间节点 leftNode = leftNode.next; // 中间节点 rightNode = rightNode.next.next; &#125; ListNode node = reserve(leftNode.next); // 反转右边部分，并获得原链表最后一个节点即反转后的第一个节点 rightNode = node; leftNode = head; boolean result = true; while (rightNode != null) &#123; if (leftNode.val != rightNode.val) &#123; result = false; break; &#125; leftNode = leftNode.next; rightNode = rightNode.next; &#125; reserve(node); // 还原右边部分 return result; &#125; public ListNode reserve(ListNode head) &#123; ListNode pre = head; ListNode cur = pre.next; pre.next = null; ListNode next; while (cur != null) &#123; next = cur.next; cur.next = pre; pre = cur; cur = next; &#125; return pre; &#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"链表指定值清除","slug":"链表指定值清除","date":"2018-02-19T04:33:42.000Z","updated":"2018-08-24T09:36:20.766Z","comments":true,"path":"2018/02/19/链表指定值清除/","link":"","permalink":"https://lierabbit.cn/2018/02/19/链表指定值清除/","excerpt":"","text":"现在有一个单链表。链表中每个节点保存一个整数，再给定一个值val，把所有等于val的节点删掉。给定一个单链表的头结点head，同时给定一个值val，请返回清除后的链表的头结点，保证链表中有不等于该值的其它值。请保证其他元素的相对顺序。测试样例： 12&#123;1,2,3,4,3,2,1&#125;,2&#123;1,3,4,3,1&#125; 思路：遍历删除指定值 1234567891011121314151617181920212223242526272829public class TreeNode &#123; public int val = 0; public TreeNode left = null; public TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125; public ListNode clear(ListNode head, int num) &#123; // 删除头节点直到头节点不为num while (head != null) &#123; if (head.val != num) break; head = head.next; &#125; ListNode pre = head; ListNode cur = head; while (cur != null) &#123; if (cur.val == num) pre.next = cur.next; else pre = cur; cur = cur.next; &#125; return head; &#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"链表的K逆序","slug":"链表的K逆序","date":"2018-02-19T04:07:11.000Z","updated":"2018-08-24T09:30:00.423Z","comments":true,"path":"2018/02/19/链表的K逆序/","link":"","permalink":"https://lierabbit.cn/2018/02/19/链表的K逆序/","excerpt":"","text":"有一个单链表，请设计一个算法，使得每K个节点之间逆序，如果最后不够K个节点一组，则不调整最后几个节点。例如链表1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;8-&gt;null，K=3这个例子。调整后为，3-&gt;2-&gt;1-&gt;6-&gt;5-&gt;4-&gt;7-&gt;8-&gt;null。因为K==3，所以每三个节点之间逆序，但其中的7，8不调整，因为只有两个节点不够一组。给定一个单链表的头指针head,同时给定K值，返回逆序后的链表的头指针。 思路：使用count计数当等于k时反转刚才遍历过的局部链表注意：反转的时候注意首尾连接 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class TreeNode &#123; public int val = 0; public TreeNode left = null; public TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125; public ListNode inverse(ListNode head, int k) &#123; // write code here if (k &lt; 2) return head; ListNode cur = head; ListNode start; ListNode pre = null; ListNode next; int count = 1; while (cur != null) &#123; next = cur.next; if (count == k) &#123; start = pre == null ? head : pre.next; head = pre == null ? cur : head; reverse(pre, start, cur, next); pre = start; count = 0; &#125; count++; cur = next; &#125; return head; &#125; /** * 反转局部链表 * @param left 局部链表头节点的前一个节点 * @param start 局部链表的头节点 * @param end 局部链表的尾节点 * @param right 局部链表尾节点的后一个节点 */ public void reverse(ListNode left, ListNode start, ListNode end, ListNode right) &#123; ListNode pre = start; ListNode cur = pre.next; ListNode next; while (cur != right) &#123; next = cur.next; cur.next = pre; pre = cur; cur = next; &#125; if (left != null) left.next = end; start.next = right; &#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"打印两个链表的公共值","slug":"打印两个链表的公共值","date":"2018-02-19T04:02:20.000Z","updated":"2018-08-24T09:22:20.954Z","comments":true,"path":"2018/02/19/打印两个链表的公共值/","link":"","permalink":"https://lierabbit.cn/2018/02/19/打印两个链表的公共值/","excerpt":"","text":"现有两个升序链表，且链表中均无重复元素。请设计一个高效的算法，打印两个链表的公共值部分。给定两个链表的头指针headA和headB，请返回一个vector，元素为两个链表的公共部分。请保证返回数组的升序。两个链表的元素个数均小于等于500。保证一定有公共值测试样例： 12&#123;1,2,3,4,5,6,7&#125;,&#123;2,4,6,8,10&#125;返回：[2.4.6] 思路：遍历2个链表进行对比，若相等则同时进一步，若A&lt;B则A进一步，直到其中一个链表遍历完成 12345678910111213141516171819202122232425262728293031323334353637383940public class TreeNode &#123; public int val = 0; public TreeNode left = null; public TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125; public int[] findCommonParts(ListNode headA, ListNode headB) &#123; // write code here if (headA == null || headB == null) return null; List&lt;Integer&gt; resultList = new ArrayList&lt;&gt;(); ListNode nodeA = headA; ListNode nodeB = headB; while (nodeA != null &amp;&amp; nodeB != null) &#123; if (nodeA.val == nodeB.val) &#123; resultList.add(nodeA.val); nodeA = nodeA.next; nodeB = nodeB.next; &#125; else if (nodeA.val &lt; nodeB.val) nodeA = nodeA.next; else nodeB = nodeB.next; &#125; int resultSize = resultList.size(); int[] result = new int[resultSize]; for (int i = 0; i &lt; resultSize; i++) &#123; result[i] = resultList.get(i); &#125; return result; &#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"链表的分化","slug":"链表的分化","date":"2018-02-19T03:42:18.000Z","updated":"2018-08-24T09:13:31.273Z","comments":true,"path":"2018/02/19/链表的分化/","link":"","permalink":"https://lierabbit.cn/2018/02/19/链表的分化/","excerpt":"","text":"对于一个链表，我们需要用一个特定阈值完成对它的分化，使得小于等于这个值的结点移到前面，大于该值的结点在后面，同时保证两类结点内部的位置关系不变。给定一个链表的头结点head，同时给定阈值val，请返回一个链表，使小于等于它的结点在前，大于等于它的在后，保证结点值不重复。测试样例： 12&#123;1,4,2,5&#125;,3&#123;1,2,4,5&#125; 思路：使用2个链表，一个放小于等于阈值的节点，一个放大于阈值的节点，最后连接2个链表注意：阈(yu)值(zhi)不是阀(fa)值(zhi) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class TreeNode &#123; public int val = 0; public TreeNode left = null; public TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125; public ListNode listDivide(ListNode head, int val) &#123; // write code here if (head == null) return head; ListNode leftHead = null; ListNode leftNode = null; ListNode rightHead = null; ListNode rightNode = null; ListNode node = head; while (node != null) &#123; if (node.val &lt;= val) &#123; if (leftHead == null) &#123; leftHead = node; leftNode = leftHead; &#125; else &#123; leftNode.next = node; leftNode = node; &#125; &#125; else &#123; if (rightHead == null) &#123; rightHead = node; rightNode = rightHead; &#125; else &#123; rightNode.next = node; rightNode = node; &#125; &#125; node = node.next; &#125; // 如果没有小于等于阈值，则只有大于阀值的部分，令头节点等于右边起始节点 if (leftHead == null) head = rightHead; else &#123; // 否则就是要连接左右部分 head = leftHead; leftNode.next = rightHead; &#125; if (rightHead != null) // 如果有右部分，则把尾节点的next置空 rightNode.next = null; return head; &#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"访问单个节点的删除","slug":"访问单个节点的删除","date":"2018-02-19T03:27:02.000Z","updated":"2018-08-24T09:10:44.470Z","comments":true,"path":"2018/02/19/访问单个节点的删除/","link":"","permalink":"https://lierabbit.cn/2018/02/19/访问单个节点的删除/","excerpt":"","text":"实现一个算法，删除单向链表中间的某个结点，假定你只能访问该结点。给定带删除的头节点和要删除的数字，请执行删除操作，返回删除后的头结点。链表中没有重复数字 思路：复制后一个节点即可，不可删除最后一个节点 1234567891011121314151617181920212223public class TreeNode &#123; public int val = 0; public TreeNode left = null; public TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125; public boolean removeNode(ListNode pNode) &#123; if (pNode == null) &#123; return false; &#125; ListNode next = pNode.next; if (next == null) &#123; return false; &#125; pNode.val = next.val; pNode.next = next.next; return true; &#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"环形链表插值","slug":"环形链表插值","date":"2018-02-19T03:21:27.000Z","updated":"2018-08-24T09:01:07.494Z","comments":true,"path":"2018/02/19/环形链表插值/","link":"","permalink":"https://lierabbit.cn/2018/02/19/环形链表插值/","excerpt":"","text":"有一个整数val，如何在节点值有序的环形链表中插入一个节点值为val的节点，并且保证这个环形单链表依然有序。给定链表的信息，及元素的值A及对应的nxt指向的元素编号同时给定val，请构造出这个环形链表，并插入该值。测试样例： 12[1,3,4,5,7],[1,2,3,4,0],2返回：&#123;1,2,3,4,5,7&#125; 思路：构建环形链表，首尾相连。插值的时候注意如果插入值小于链表中所有元素则返回该节点作为头节点 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class TreeNode &#123; public int val = 0; public TreeNode left = null; public TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125; public ListNode insert(int[] A, int[] nxt, int val) &#123; // write code here ListNode head; if (A == null || A.length == 0) &#123; head = new ListNode(val); head.next = head; &#125; else &#123; head = new ListNode(A[0]); ListNode pre = head;// 前一个节点 ListNode cur;// 当前节点 for (int next : nxt) &#123; if (next == 0) cur = head; else cur = new ListNode(A[next]); pre.next = cur; pre = cur; &#125; head = insertValue(head, val); &#125; return head; &#125; public ListNode insertValue(ListNode head, int val) &#123; ListNode pre = head; ListNode cur = head.next; while (cur != head) &#123; if (pre.val &lt;= val &amp;&amp; val &lt;= cur.val) break; pre = cur; cur = cur.next; &#125; ListNode realHead;// 插入后的头节点 // 没有在中间找到插入点，则要么val大于或者小于链表里所有数 ListNode node = new ListNode(val); pre.next = node; node.next = cur; if (cur == head) &#123; if (val &lt; head.val) realHead = node; else realHead = head; &#125; else &#123; realHead = head; &#125; return realHead; &#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"数组变树","slug":"数组变树","date":"2018-02-18T15:43:34.000Z","updated":"2018-08-24T08:51:28.356Z","comments":true,"path":"2018/02/18/数组变树/","link":"","permalink":"https://lierabbit.cn/2018/02/18/数组变树/","excerpt":"","text":"对于一个没有重复元素的整数数组，请用其中元素构造一棵MaxTree，MaxTree定义为一棵二叉树，其中的节点与数组元素一一对应，同时对于MaxTree的每棵子树，它的根的元素值为子树的最大值。现有一建树方法，对于数组中的每个元素，其在树中的父亲为数组中它左边比它大的第一个数和右边比它大的第一个数中更小的一个。若两边都不存在比它大的数，那么它就是树根。请设计O(n)的算法实现这个方法。给定一个无重复元素的数组A和它的大小n，请返回一个数组，其中每个元素为原数组中对应位置元素在树中的父亲节点的编号，若为根则值为-1。测试样例： 12[3,1,4,2],4返回：[2,0,-1,2] 思路：第一次遍历数组找到左边第一个比当前数大的下标，第二次遍历数组找到右边第一个比当前数大的下标，并和左边第一个比当前数大的数比较，取较小的 1234567891011121314151617181920212223242526272829303132333435public int[] buildMaxTree(int[] arr, int n) &#123; // write code here Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); int[] res = new int[n]; // 找到左边第一个比当前数大的下标 for (int i = 0; i &lt; n; i++) &#123; while (!stack.empty() &amp;&amp; arr[stack.peek()] &lt; arr[i]) stack.pop(); if (stack.empty()) res[i] = -1; else res[i] = stack.peek(); stack.push(i); &#125; stack.clear(); // 找到右边第一个比当前数大的下标，并和左边第一个比当前数大的数比较，取较小的 for (int i = n - 1; i &gt;= 0; i--) &#123; while (!stack.empty() &amp;&amp; arr[stack.peek()] &lt; arr[i]) stack.pop(); if (!stack.empty())&#123; if(res[i] == -1) res[i] = stack.peek(); else &#123; res[i] = arr[stack.peek()] &lt; arr[res[i]] ? stack.peek() : res[i]; &#125; &#125; stack.push(i); &#125; return res;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"滑动窗口","slug":"滑动窗口","date":"2018-02-18T15:04:52.000Z","updated":"2018-08-24T08:47:41.250Z","comments":true,"path":"2018/02/18/滑动窗口/","link":"","permalink":"https://lierabbit.cn/2018/02/18/滑动窗口/","excerpt":"","text":"有一个整型数组 arr 和一个大小为 w 的窗口从数组的最左边滑到最右边,窗口每次向右边滑一个位置。 返回一个长度为n-w+1的数组res，res[i]表示每一种窗口状态下的最大值。 以数组为[4,3,5,4,3,3,6,7]，w=3为例。因为第一个窗口[4,3,5]的最大值为5，第二个窗口[3,5,4]的最大值为5，第三个窗口[5,4,3]的最大值为5。第四个窗口[4,3,3]的最大值为4。第五个窗口[3,3,6]的最大值为6。第六个窗口[3,6,7]的最大值为7。所以最终返回[5,5,5,4,6,7]。给定整形数组arr及它的大小n，同时给定w，请返回res数组。保证w小于等于n，同时保证数组大小小于等于500。测试样例： 12[4,3,5,4,3,3,6,7],8,3返回：[5,5,5,4,6,7] 思路：使用双端队列记录访问到的最大值，判断该值是否还在窗口内 123456789101112131415161718192021public int[] slide(int[] arr, int n, int w) &#123; // write code here int result[] = new int[n - w + 1]; int resultSize = 0; // 从大到小的队列 Deque&lt;Integer&gt; qMax = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; n; i++) &#123; while (!qMax.isEmpty() &amp;&amp; arr[i] &gt;= arr[qMax.peekLast()]) qMax.pollLast(); qMax.add(i); if (i &gt;= w - 1) &#123; // 判断最大值是否在窗口内 if (qMax.peekFirst() == i - w) qMax.pollFirst(); result[resultSize++] = arr[qMax.peekFirst()]; &#125; &#125; return result;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"双栈排序","slug":"双栈排序","date":"2018-02-18T13:42:41.000Z","updated":"2018-08-24T08:42:39.080Z","comments":true,"path":"2018/02/18/双栈排序/","link":"","permalink":"https://lierabbit.cn/2018/02/18/双栈排序/","excerpt":"","text":"请编写一个程序，按升序对栈进行排序（即最大元素位于栈顶），要求最多只能使用一个额外的栈存放临时数据，但不得将元素复制到别的数据结构中。给定一个int[] numbers(C++中为vector&amp;ltint&gt;)，其中第一个元素为栈顶，请返回排序后的栈。请注意这是一个栈，意味着排序过程中你只能访问到第一个元素。测试样例： 12[1,2,3,4,5]返回：[5,4,3,2,1] 思路：用一个排序栈help，大于等于help栈顶则压入，小于则help弹出栈顶，继续比较，直到找到插入的位置 123456789101112131415161718192021222324252627282930313233343536373839404142434445public ArrayList&lt;Integer&gt; twoStacksSort(int[] numbers) &#123; // write code here Stack&lt;Integer&gt; data = new Stack&lt;&gt;(); Stack&lt;Integer&gt; help = new Stack&lt;&gt;(); for (int i = numbers.length - 1; i &gt;= 0; i--) data.push(numbers[i]); while (!data.empty()) &#123; Integer value = data.pop(); if (help.empty()) help.push(value); else &#123; if (value &lt;= help.peek()) help.push(value); else &#123; int popNumber = 0; while (!help.empty()) &#123; if (value &gt; help.peek()) &#123; data.push(help.pop()); popNumber++; &#125; else break; &#125; help.push(value); while (popNumber != 0) &#123; help.push(data.pop()); popNumber--; &#125; &#125; &#125; &#125; while (!help.empty()) &#123; data.push(help.pop()); &#125; ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); while (!data.empty()) &#123; list.add(data.pop()); &#125; return list;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"栈的反转","slug":"栈的反转","date":"2018-02-18T11:32:33.000Z","updated":"2018-08-24T08:37:53.261Z","comments":true,"path":"2018/02/18/栈的反转/","link":"","permalink":"https://lierabbit.cn/2018/02/18/栈的反转/","excerpt":"","text":"实现一个栈的逆序，但是只能用递归函数和这个栈本身的pop操作来实现，而不能自己申请另外的数据结构。给定一个整数数组A即为给定的栈，同时给定它的大小n，请返回逆序后的栈。测试样例： 12[4,3,2,1],4返回：[1,2,3,4] 思路：利用递归获取栈底，弹出-&gt;弹出-&gt;弹出（栈底）-&gt;返回栈底-&gt;返回栈底-&gt;返回栈底，栈底-&gt;栈底-&gt;栈底（最后一个）-&gt;压入栈底-&gt;压入栈底-&gt;压入栈底 1234567891011121314151617181920212223242526272829303132333435363738public class StackReverse &#123; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); public int[] reverseStack(int[] A, int n) &#123; // write code here for (int i = n - 1; i &gt;= 0; i--) stack.add(A[i]); reverse(); int index = 0; while (!stack.empty()) A[index++] = stack.pop(); return A; &#125; // 反转栈 public void reverse() &#123; if (stack.empty()) return; int i = getBottom(); reverse(); stack.push(i); &#125; // 得到栈底元素 public int getBottom() &#123; int result = stack.pop(); if (stack.empty()) return result; else &#123; int last = getBottom(); stack.push(result); return last; &#125; &#125;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"双栈队列","slug":"双栈队列","date":"2018-02-18T11:24:16.000Z","updated":"2018-08-24T08:33:04.299Z","comments":true,"path":"2018/02/18/双栈队列/","link":"","permalink":"https://lierabbit.cn/2018/02/18/双栈队列/","excerpt":"","text":"编写一个类,只能用两个栈结构实现队列,支持队列的基本操作(push，pop)。给定一个操作序列ope及它的长度n，其中元素为正数代表push操作，为0代表pop操作，保证操作序列合法且一定含pop操作，请返回pop的结果序列。测试样例： 12[1,2,3,0,4,0],6返回：[1,2] 思路：一个栈用来压入，一个栈用来弹出，先压入到压入栈，然后再全部弹出压入弹出栈即可模拟队列，注意：当弹出栈不空时不能压入弹出栈必须一次性将压入栈倒出到弹出栈 123456789101112131415161718192021222324252627282930313233343536373839public class TwoStack &#123; private Stack&lt;Integer&gt; pushStack = new Stack&lt;&gt;(); private Stack&lt;Integer&gt; popStack = new Stack&lt;&gt;(); public int[] twoStack(int[] ope, int n) &#123; // write code here List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int a : ope) &#123; if (a != 0) add(a); else &#123; list.add(pop()); &#125; &#125; int[] result = new int[list.size()]; int resultLen = 0; for(int a:list) result[resultLen++] = a; return result; &#125; private void add(int value) &#123; while (!popStack.empty()) &#123; pushStack.add(popStack.pop()); &#125; pushStack.add(value); &#125; private int pop() &#123; while (!pushStack.empty()) &#123; popStack.add(pushStack.pop()); &#125; return popStack.pop(); &#125;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"可查询最值的栈","slug":"可查询最值的栈","date":"2018-02-18T11:13:06.000Z","updated":"2018-08-24T08:30:49.577Z","comments":true,"path":"2018/02/18/可查询最值的栈/","link":"","permalink":"https://lierabbit.cn/2018/02/18/可查询最值的栈/","excerpt":"","text":"定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的min函数。 思路：使用2个栈stack和minStack，stack压入所有元素，minStack只压入最小值，弹出元素的时候，stack正常弹出，minStack只有栈顶元素==stack弹出的元素才弹出 12345678910111213141516171819202122232425262728293031public class Solution &#123; private Stack&lt;Integer&gt; stack; private Stack&lt;Integer&gt; minStack; public Solution() &#123; stack = new Stack&lt;&gt;(); minStack = new Stack&lt;&gt;(); &#125; public void push(int value) &#123; stack.add(value); if (minStack.empty()) minStack.push(value); else if (minStack.peek() &gt;= value) minStack.push(value); &#125; public void pop() &#123; Integer value = stack.pop(); if (value == minStack.peek()) minStack.pop(); &#125; public int top() &#123; return stack.peek(); &#125; public int min() &#123; return minStack.peek(); &#125;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"最长无重复字符字串","slug":"最长无重复字符字串","date":"2018-02-18T10:55:23.000Z","updated":"2018-08-24T08:19:54.321Z","comments":true,"path":"2018/02/18/最长无重复字符字串/","link":"","permalink":"https://lierabbit.cn/2018/02/18/最长无重复字符字串/","excerpt":"","text":"对于一个字符串,请设计一个高效算法，找到字符串的最长无重复字符的子串长度。给定一个字符串A及它的长度n，请返回它的最长无重复字符子串长度。保证A中字符全部为小写英文字符，且长度小于等于500。测试样例： 12&quot;aabcb&quot;,5返回：3 思路：使用数组模拟HashMap记录字符上次出现的位置，用pre记录最近重复字符出现最近的位置，则i(当前位置)-pre就是当前字符最长无重复字符的长度，取最大的就是字符串的最长无重复字符的长度 1234567891011121314151617181920212223public int longestSubstring(String A, int n) &#123; if (A == null || n == 0) &#123; return 0; &#125; int[] map = new int[256]; for (int i = 0; i &lt; 256; i++) map[i] = -1; char[] chars = A.toCharArray(); int len = 0; int pre = -1;//之前出现的地方 int cur;//当前最长无重复字符子串长度 for (int i = 0; i &lt; chars.length; i++) &#123; pre = Math.max(pre, map[chars[i]]); cur = i - pre; len = Math.max(len, cur); map[chars[i]] = i; &#125; return len;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"合法括号序列判断","slug":"合法括号序列判断","date":"2018-02-18T10:37:20.000Z","updated":"2018-08-24T08:17:16.089Z","comments":true,"path":"2018/02/18/合法括号序列判断/","link":"","permalink":"https://lierabbit.cn/2018/02/18/合法括号序列判断/","excerpt":"","text":"对于一个字符串，请设计一个算法，判断其是否为一个合法的括号串。给定一个字符串A和它的长度n，请返回一个bool值代表它是否为一个合法的括号串。测试样例： 12345678910&quot;(()())&quot;,6返回：true测试样例：&quot;()a()()&quot;,7返回：false测试样例：&quot;()(()()&quot;,7返回：false 思路：用num记录括号出现次数，出现’(‘则+1，出现’)’则-1，若num&lt;0说明’)’出现过多，若遍历完整个数组num不为0说明’(‘过多 12345678910111213141516public boolean chkParenthesis(String A, int n) &#123; // write code here int num = 0; char[] chars = A.toCharArray(); for (char ch : chars) &#123; if (ch == '(') num++; if (ch == ')') num--; if (num &lt; 0) return false; &#125; return num == 0;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"空格替换","slug":"空格替换","date":"2018-02-18T10:28:12.000Z","updated":"2018-08-24T08:14:45.950Z","comments":true,"path":"2018/02/18/空格替换/","link":"","permalink":"https://lierabbit.cn/2018/02/18/空格替换/","excerpt":"","text":"请编写一个方法，将字符串中的空格全部替换为“%20”。假定该字符串有足够的空间存放新增的字符，并且知道字符串的真实长度(小于等于1000)，同时保证字符串由大小写的英文字母组成。给定一个string iniString 为原始的串，以及串的长度 int len, 返回替换后的string。测试样例： 1234&quot;Mr John Smith”,13返回：&quot;Mr%20John%20Smith&quot;”Hello World”,12返回：”Hello%20%20World” 使用replaceAlliniString.replaceAll(“ “,”%20”) 手动实现思路：记录空格出现次数，新数组长度等于原数组长度+空格数*2，遍历原数组按规则放入新数组即可 123456789101112131415161718192021222324public String replaceSpace(String iniString, int length) &#123; // write code here if (iniString == null || iniString.length() == 0) return iniString; char[] chars = iniString.toCharArray(); int space = 0; for (char ch : chars) if (ch == ' ') space++; int resultLen = length + space * 2; char[] result = new char[resultLen]; for (int i = length - 1; i &gt;= 0; i--) &#123; if (chars[i] == ' ') &#123; result[--resultLen] = '0'; result[--resultLen] = '2'; result[--resultLen] = '%'; &#125; else result[--resultLen] = chars[i]; &#125; return String.valueOf(result);&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"拼接最小字典序","slug":"拼接最小字典序","date":"2018-02-18T10:15:44.000Z","updated":"2018-08-24T08:11:27.769Z","comments":true,"path":"2018/02/18/拼接最小字典序/","link":"","permalink":"https://lierabbit.cn/2018/02/18/拼接最小字典序/","excerpt":"","text":"对于一个给定的字符串数组，请找到一种拼接顺序，使所有小字符串拼接成的大字符串是所有可能的拼接中字典序最小的。给定一个字符串数组strs，同时给定它的大小，请返回拼接成的串。测试样例： 12[&quot;abc&quot;,&quot;de&quot;],2&quot;abcde&quot; 思路：将字符串数组排序，然后按序拼接。有字符串a和b，若a+b&lt;b+a，则a在前b在后。 123456789101112131415public String findSmallest(String[] strs, int n) &#123; // write code here if (strs == null) return null; if (strs.length == 1) return strs[0]; Arrays.sort(strs, (a, b) -&gt; (a + b).compareTo(b + a)); StringBuilder result = new StringBuilder(); for (String str : strs) result.append(str); return result.toString();&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"字符串位移","slug":"字符串位移","date":"2018-02-18T10:12:02.000Z","updated":"2018-08-24T08:00:41.927Z","comments":true,"path":"2018/02/18/字符串位移/","link":"","permalink":"https://lierabbit.cn/2018/02/18/字符串位移/","excerpt":"","text":"对于一个字符串，请设计一个算法，将字符串的长度为len的前缀平移到字符串的最后。给定一个字符串A和它的长度，同时给定len，请返回平移后的字符串。测试样例： 12&quot;ABCDE&quot;,5,3返回：&quot;DEABC&quot; 思路：首先将长度为len的字符逆序，再把len之后的字符逆序，最后把整个字符串逆序即可 123456789101112131415161718192021222324public String stringTranslation(String A, int n, int len) &#123; // write code here char[] chars = A.toCharArray(); reverse(chars, 0, len - 1); reverse(chars, len, n - 1); reverse(chars, 0, n - 1); return String.valueOf(chars);&#125;public void reverse(char[] chars, int start, int end) &#123; while (start &lt; end) &#123; swap(chars, start, end); start++; end--; &#125;&#125;public void swap(char[] chars, int i, int j) &#123; char temp = chars[i]; chars[i] = chars[j]; chars[j] = temp;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"句子的逆序","slug":"句子的逆序","date":"2018-02-18T10:04:17.000Z","updated":"2018-08-24T07:56:00.011Z","comments":true,"path":"2018/02/18/句子的逆序/","link":"","permalink":"https://lierabbit.cn/2018/02/18/句子的逆序/","excerpt":"","text":"对于一个字符串，请设计一个算法，只在字符串的单词间做逆序调整，也就是说，字符串由一些由空格分隔的部分组成，你需要将这些部分逆序。给定一个原字符串A和他的长度，请返回逆序后的字符串。测试样例： 12&quot;dog loves pig&quot;,13返回：&quot;pig loves dog&quot; 思路：首先反转整个字符串，接着一个一个的反转局部单词即可 12345678910111213141516171819202122232425262728293031323334353637383940public String reverseSentence(String A, int n) &#123; // write code here char[] chars = A.toCharArray(); // 反转整个字符串 reverse(chars, 0, chars.length - 1); int l = -1; int r = -1; for (int i = 0; i &lt; chars.length; i++) &#123; if (chars[i] != ' ') &#123; if (i == 0 || chars[i - 1] == ' ') // 寻找需要局部反转的单词的起始下标 l = i; if (i == chars.length - 1 || chars[i + 1] == ' ') // 寻找需要局部反转的单词的末尾下标 r = i; &#125; if (l != -1 &amp;&amp; r != -1) &#123; reverse(chars, l, r); l = -1; r = -1; &#125; &#125; return String.valueOf(chars);&#125;// 反转字符串public void reverse(char[] chars, int start, int end) &#123; while (start &lt; end) &#123; swap(chars, start, end); start++; end--; &#125;&#125;// 交换public void swap(char[] chars, int i, int j) &#123; char temp = chars[i]; chars[i] = chars[j]; chars[j] = temp;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"两串旋转","slug":"两串旋转","date":"2018-02-18T09:53:37.000Z","updated":"2018-08-24T07:54:19.640Z","comments":true,"path":"2018/02/18/两串旋转/","link":"","permalink":"https://lierabbit.cn/2018/02/18/两串旋转/","excerpt":"","text":"如果对于一个字符串A，将A的前面任意一部分挪到后边去形成的字符串称为A的旋转词。比如A=”12345”,A的旋转词有”12345”,”23451”,”34512”,”45123”和”51234”。对于两个字符串A和B，请判断A和B是否互为旋转词。给定两个字符串A和B及他们的长度lena，lenb，请返回一个bool值，代表他们是否互为旋转词。测试样例：12&quot;cdab&quot;,4,&quot;abcd&quot;,4返回：true 思路：如果A，B互为旋转词，则A+A必定包含B例如A=”abcd”，B=”cdab”，则A+A=”abcdabcd”，里面有”abcd”，”bcda”，”cdab”，”dabc”枚举了所有的旋转词 12345678public boolean chkRotation(String A, int lena, String B, int lenb) &#123; // write code here if (lena == lenb) &#123; String C = A + A; return C.contains(B); &#125; else return false;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"词语变形","slug":"词语变形","date":"2018-02-18T09:48:13.000Z","updated":"2018-08-24T07:46:11.079Z","comments":true,"path":"2018/02/18/词语变形/","link":"","permalink":"https://lierabbit.cn/2018/02/18/词语变形/","excerpt":"","text":"对于两个字符串A和B，如果A和B中出现的字符种类相同且每种字符出现的次数相同，则A和B互为变形词，请设计一个高效算法，检查两给定串是否互为变形词。给定两个字符串A和B及他们的长度，请返回一个bool值，代表他们是否互为变形词。测试样例： 12&quot;abc&quot;,3,&quot;bca&quot;,3返回：true 思路：使用数组模拟hashMap计数，只要字符出现次数一致就互为变形词 12345678910111213141516171819public boolean chkTransform(String str1, int lena, String str2, int lenb) &#123; // write code here if (str1 == null || str2 == null || lena != lenb) return false; char[] chars1 = str1.toCharArray(); char[] chars2 = str2.toCharArray(); int[] map = new int[256]; for (char char1 : chars1) map[char1]++; for (char char2 : chars2) &#123; if (map[char2]-- == 0) return false; &#125; return true;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"拓扑结构相同子树","slug":"拓扑结构相同子树","date":"2018-02-18T09:33:25.000Z","updated":"2018-08-24T07:41:54.834Z","comments":true,"path":"2018/02/18/拓扑结构相同子树/","link":"","permalink":"https://lierabbit.cn/2018/02/18/拓扑结构相同子树/","excerpt":"","text":"对于两棵彼此独立的二叉树A和B，请编写一个高效算法，检查A中是否存在一棵子树与B树的拓扑结构完全相同。给定两棵二叉树的头结点A和B，请返回一个bool值，代表A中是否存在一棵同构于B的子树。 思路：将树序列化成字符串。如果A树中存在一棵子树与B树的拓扑结构完全相同则A序列化后的字符串必定包含B序列化后的字符串。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class TreeNode &#123; public int val = 0; public TreeNode left = null; public TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125; public boolean chkIdentical(TreeNode A, TreeNode B) &#123; // write code here String AS = treeToStringWithStack(A); String BS = treeToStringWithStack(B); return AS.contains(BS); &#125; // 先序遍历 public String treeToStringWithStack(TreeNode root) &#123; StringBuilder result = new StringBuilder(); Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.add(root); TreeNode node; while (!stack.empty()) &#123; node = stack.pop(); if (node == null) result.append(\"#!\"); else &#123; result.append(node.val).append(\"!\"); stack.add(node.right); stack.add(node.left); &#125; &#125; return result.toString(); &#125; // 递归先序遍历 public String serialByPre(TreeNode head) &#123; if (head == null) &#123; return \"#!\"; &#125; String res = head.val + \"!\"; res += serialByPre(head.left); res += serialByPre(head.right); return res; &#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"相邻两数最大差值","slug":"相邻两数最大差值","date":"2018-02-18T08:24:09.000Z","updated":"2018-08-24T07:40:49.628Z","comments":true,"path":"2018/02/18/相邻两数最大差值/","link":"","permalink":"https://lierabbit.cn/2018/02/18/相邻两数最大差值/","excerpt":"","text":"有一个整形数组A，请设计一个复杂度为O(n)的算法，算出排序后相邻两数的最大差值。给定一个int数组A和A的大小n，请返回最大的差值。保证数组元素多于1个。测试样例： 12[1,2,5,4,6],5返回：2 思路：使用2个n+1大小的桶按区间来放置最大和最小数，第n+1个桶单独放置最大值，取每个桶之间的最大差值即可 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public int maxGap(int[] nums, int n) &#123; // write code here if (nums == null || nums.length &lt; 2) return 0; int len = nums.length; int min = Integer.MAX_VALUE; int max = Integer.MIN_VALUE; // 获取数组中最大最小值用来划分桶区间 for (int num : nums) &#123; min = Math.min(min, num); max = Math.max(max, num); &#125; if (max == min) return 0; boolean[] hasNums = new boolean[len + 1]; int[] maxs = new int[len + 1]; int[] mins = new int[len + 1]; int bid; // 将数放入桶中 for (int num : nums) &#123; bid = bucket(num, len, min, max); mins[bid] = hasNums[bid] ? Math.min(mins[bid], num) : num; maxs[bid] = hasNums[bid] ? Math.max(maxs[bid], num) : num; hasNums[bid] = true; &#125; int lastMax = 0; int index = 0; // 寻找第一个不为空的桶 while (index &lt;= len) &#123; if (hasNums[index]) &#123; lastMax = maxs[index]; break; &#125; index++; &#125; int result = 0; while (index &lt;= len) &#123; if (hasNums[index]) &#123; // 当桶的最小值减去上一个不为空的桶最大值即为2个桶的最大差值 result = Math.max(result, mins[index] - lastMax); lastMax = maxs[index]; &#125; index++; &#125; return result;&#125;// 使用long类型是为了防止相乘时溢出// 根据区间获取桶号public int bucket(long num, long len, long min, long max) &#123; return (int) ((num - min) * len / (max - min));&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"最短子数组","slug":"最短子数组","date":"2018-02-18T08:05:18.000Z","updated":"2018-08-24T07:35:29.447Z","comments":true,"path":"2018/02/18/最短子数组/","link":"","permalink":"https://lierabbit.cn/2018/02/18/最短子数组/","excerpt":"","text":"对于一个数组，请设计一个高效算法计算需要排序的最短子数组的长度。给定一个int数组A和数组的大小n，请返回一个二元组，代表所求序列的长度。(原序列位置从0开始标号,若原序列有序，返回0)。保证A中元素均为正整数。测试样例： 12[1,4,6,5,9,10],6返回：2 思路：从左往右记录最大值，并记录最大值大于当前遍历数的位置，因为排序后最大值至少在当前位置或者更右的位置。从右往左记录最小值，并记录最小值小于当前遍历数的位置，因为排序后最小值至少在当前位置或者更左的位置。 12345678910111213141516171819202122232425public int shortestSubsequence(int[] A, int n) &#123; int maxIndex = 0; int max = A[maxIndex]; int minIndex = n - 1; int min = A[n - 1]; for (int i = maxIndex + 1; i &lt; n; i++) &#123; if (max &lt;= A[i]) max = A[i]; else maxIndex = i; &#125; for (int i = minIndex - 1; i &gt;= 0; i--) &#123; if (min &gt;= A[i]) min = A[i]; else minIndex = i; &#125; if (maxIndex == 0 &amp;&amp; minIndex == n - 1) return 0; else return maxIndex - minIndex + 1;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"有序矩阵查找","slug":"有序矩阵查找","date":"2018-02-18T07:57:22.000Z","updated":"2018-08-24T07:26:53.382Z","comments":true,"path":"2018/02/18/有序矩阵查找/","link":"","permalink":"https://lierabbit.cn/2018/02/18/有序矩阵查找/","excerpt":"","text":"现在有一个行和列都排好序的矩阵，请设计一个高效算法，快速查找矩阵中是否含有值x。给定一个int矩阵mat，同时给定矩阵大小nxm及待查找的数x，请返回一个bool值，代表矩阵中是否存在x。所有矩阵中数字及x均为int范围内整数。保证n和m均小于等于1000。测试样例： 12[[1,2,3],[4,5,6],[7,8,9]],3,3,10返回：false 思路：从右上角开始找 1234567891011121314151617181920public boolean findX(int[][] mat, int n, int m, int x) &#123; // write code here int row = 0; int col = m - 1; while (row &lt; n &amp;&amp; col &gt;= 0) &#123; if (mat[row][col] == x) return true; // 比它大往左走 else if (x &lt;= mat[row][col]) &#123; col--; &#125; // 比它小往下走 else if (x &gt;= mat[row][col]) &#123; row++; &#125; &#125; return false; &#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"三色排序","slug":"三色排序","date":"2018-02-17T11:38:54.000Z","updated":"2018-08-24T07:15:50.052Z","comments":true,"path":"2018/02/17/三色排序/","link":"","permalink":"https://lierabbit.cn/2018/02/17/三色排序/","excerpt":"","text":"有一个只由0，1，2三种元素构成的整数数组，请使用交换、原地排序而不是使用计数进行排序。给定一个只含0，1，2的整数数组A及它的大小，请返回排序后的数组。保证数组大小小于等于500。测试样例：12[0,1,1,0,2,2],6返回：[0,0,1,1,2,2] 思路：类似于快排，小的放左边，大的放右边 123456789101112131415161718192021public int[] sortThreeColor(int[] arr, int n) &#123; // write code here int left = -1; int right = n; int index = 0; while (index &lt; right) &#123; if (arr[index] == 0) swap(arr, ++left, index++); // 由于前面的数已经遍历过，所以交换后可以后移即(index++) else if (arr[index] == 2) swap(arr, --right, index); // 右边的数没有遍历过，所以交换后index不增 else index++; &#125; return arr;&#125;public void swap(int[] arr, int i, int j) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"有序数组合并","slug":"有序数组合并","date":"2018-02-17T10:48:59.000Z","updated":"2018-08-24T07:13:44.641Z","comments":true,"path":"2018/02/17/有序数组合并/","link":"","permalink":"https://lierabbit.cn/2018/02/17/有序数组合并/","excerpt":"","text":"有两个从小到大排序以后的数组A和B，其中A的末端有足够的缓冲空容纳B。请编写一个方法，将B合并入A并排序。给定两个有序int数组A和B，A中的缓冲空用0填充，同时给定A和B的真实大小int n和int m，请返回合并后的数组。 思路：从后往前按序填充 12345678910111213public int[] mergeAB(int[] A, int[] B, int n, int m) &#123; // write code here while (m != 0) &#123; if (n == 0) &#123; A[m - 1] = B[m - 1]; m--; &#125; else &#123; A[m + n - 1] = A[n - 1] &gt; B[m - 1] ? A[--n] : B[--m]; &#125; &#125; return A;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"重复值判断","slug":"重复值判断","date":"2018-02-17T08:21:12.000Z","updated":"2018-08-24T07:06:17.346Z","comments":true,"path":"2018/02/17/重复值判断/","link":"","permalink":"https://lierabbit.cn/2018/02/17/重复值判断/","excerpt":"","text":"请设计一个高效算法，判断数组中是否有重复值。必须保证额外空间复杂度为O(1)。给定一个int数组A及它的大小n，请返回它是否有重复值。测试样例： 12[1,2,3,4,5,5,6],7返回：true 思路：使用堆排序后判断下一个元素是否与当前元素相等 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public boolean checkDuplicate(int[] arr, int n) &#123; // write code here makeHeap(arr); for (int i = arr.length - 1; i &gt; 0; i--) &#123; swap(arr, 0, i); adjustHeap(arr, 0, i); &#125; for (int i = 0; i &lt; arr.length - 1; i++) &#123; if (arr[i] == arr[i + 1]) return true; &#125; return false;&#125;public void makeHeap(int[] arr) &#123; for (int i = arr.length / 2 - 1; i &gt;= 0; i--) &#123; adjustHeap(arr, i, arr.length); &#125;&#125;public void adjustHeap(int[] arr, int index, int size) &#123; int max = arr[index]; for (int k = index * 2 + 1; k &lt; size; k = k * 2 + 1) &#123; if (k + 1 &lt; size &amp;&amp; arr[k] &lt; arr[k + 1]) &#123; k++; &#125; if (max &lt; arr[k]) &#123; arr[index] = arr[k]; index = k; &#125; else break; &#125; arr[index] = max;&#125;public void swap(int[] arr, int i, int j) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"小范围排序","slug":"小范围排序","date":"2018-02-13T16:44:14.000Z","updated":"2018-08-24T02:18:13.523Z","comments":true,"path":"2018/02/14/小范围排序/","link":"","permalink":"https://lierabbit.cn/2018/02/14/小范围排序/","excerpt":"","text":"已知一个几乎有序的数组，几乎有序是指，如果把数组排好顺序的话，每个元素移动的距离可以不超过k，并且k相对于数组来说比较小。请选择一个合适的排序算法针对这个数据进行排序。给定一个int数组A，同时给定A的大小n和题意中的k，请返回排序后的数组。 测试样例：12[2,1,4,3,6,5,8,7,10,9],10,2返回：[1,2,3,4,5,6,7,8,9,10] 思路：特殊版的堆排序，建立大小为K的小根堆，按照堆排序排序 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public int[] sortElement(int[] A, int n, int k) &#123; // write code here if (A == null || n &lt; 2 || n &lt; k) return A; // 获取大小为k的小根堆 int[] heap = getHeap(A, k); for (int i = k; i &lt; n; i++) &#123; A[i - k] = heap[0]; heap[0] = A[i]; adjustHeap(heap, 0, k); &#125; // 把剩余堆的值一个一个弹出 int temp; for (int i = n - k; i &lt; n; i++) &#123; A[i] = heap[0]; temp = heap[0]; heap[0] = heap[k - 1]; heap[k - 1] = temp; adjustHeap(heap, 0, --k); &#125; return A;&#125;public int[] getHeap(int[] arr, int size) &#123; int[] heap = new int[size]; for (int i = 0; i &lt; size; i++) &#123; heap[i] = arr[i]; &#125; adjustHeap(heap, 0, size); for (int i = size / 2 - 1; i &gt;= 0; i--) &#123; adjustHeap(heap, i, size); &#125; return heap;&#125;// 调整堆public void adjustHeap(int[] arr, int i, int length) &#123; int min = arr[i]; for (int k = i * 2 + 1; k &lt; length; k = k * 2 + 1) &#123; if (k + 1 &lt; length &amp;&amp; arr[k] &gt; arr[k + 1]) &#123; k++; &#125; if (min &gt; arr[k]) &#123; arr[i] = arr[k]; i = k; &#125; else &#123; break; &#125; &#125; arr[i] = min;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"基数排序","slug":"基数排序","date":"2018-02-13T16:26:46.000Z","updated":"2018-08-23T14:51:30.700Z","comments":true,"path":"2018/02/14/基数排序/","link":"","permalink":"https://lierabbit.cn/2018/02/14/基数排序/","excerpt":"","text":"对于一个int数组，请编写一个基数排序算法，对数组元素排序。给定一个int数组A及数组的大小n，请返回排序后的数组。保证元素均小于等于2000。测试样例： 12[1,2,3,5,2,3],6[1,2,2,3,3,5] 时间复杂度：O(n)空间复杂度：O(m) // m：桶的数量 思路：放置顺序的0-9号桶，将所有元素先按个位放入，按桶序倒出，再按十位放入，按桶序倒出，依次重复下去 12345678910111213141516171819202122232425262728293031323334353637public int[] radixSort(int[] A, int n) &#123; int max = A[0]; for (int a : A) &#123; max = Math.max(max, a); &#125; List&lt;List&lt;Integer&gt;&gt; boxs = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 10; i++) &#123; boxs.add(new ArrayList&lt;&gt;()); &#125; int k = 1; int index; while (max &gt; 0) &#123; for (int a : A) &#123; boxs.get(a / k % 10).add(a); &#125; index = 0; for (int i = 0; i &lt; 10; i++) &#123; List&lt;Integer&gt; box = boxs.get(i); for (int j = 0; j &lt; box.size(); j++) &#123; A[index++] = box.get(j); &#125; box.clear(); &#125; k *= 10; max /= 10; &#125; return A;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"计数排序","slug":"计数排序","date":"2018-02-13T16:22:10.000Z","updated":"2018-08-23T14:49:33.015Z","comments":true,"path":"2018/02/14/计数排序/","link":"","permalink":"https://lierabbit.cn/2018/02/14/计数排序/","excerpt":"","text":"对于一个int数组，请编写一个计数排序算法，对数组元素排序。给定一个int数组A及数组的大小n，请返回排序后的数组。测试样例： 12[1,2,3,5,2,3],6[1,2,2,3,3,5] 时间复杂度：O(n)空间复杂度：O(m) // m：桶的数量 思路：预先设置一些排好序的桶（数组），然后遍历数组将元素放入对应桶，再倒出桶里的值 12345678910111213141516171819202122232425public int[] countingSort(int[] A, int n) &#123; int min = A[0]; int max = A[0]; for (int a : A) &#123; min = Math.min(min, a); max = Math.max(max, a); &#125; int[] arr = new int[max - min + 1]; for (int a : A) &#123; arr[a - min]++; &#125; int index = 0; for (int i = 0; i &lt; arr.length; i++) &#123; while (arr[i]-- &gt; 0) &#123; A[index++] = i + min; &#125; &#125; return A;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"希尔排序","slug":"希尔排序","date":"2018-02-13T16:18:50.000Z","updated":"2018-08-23T14:49:18.623Z","comments":true,"path":"2018/02/14/希尔排序/","link":"","permalink":"https://lierabbit.cn/2018/02/14/希尔排序/","excerpt":"","text":"对于一个int数组，请编写一个希尔排序算法，对数组元素排序。给定一个int数组A及数组的大小n，请返回排序后的数组。保证元素小于等于2000。测试样例：12[1,2,3,5,2,3],6[1,2,2,3,3,5] 时间复杂度：O(nlogn)空间复杂度：O(1) 思路：动态步长的插入排序，最终步长为1 12345678910111213141516171819202122public int[] shellSort(int[] A, int n) &#123; int feet = A.length / 2; int temp; int index; while (feet &gt; 0) &#123; for (int i = feet; i &lt; A.length; i++) &#123; index = i; while (index &gt;= feet) &#123; if (A[index - feet] &gt; A[index]) &#123; temp = A[index]; A[index] = A[index - feet]; A[index - feet] = temp; index -= feet; &#125; else &#123; break; &#125; &#125; &#125; feet /= 2; &#125; return A;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"堆排序","slug":"堆排序","date":"2018-02-13T16:11:02.000Z","updated":"2018-08-23T14:44:42.579Z","comments":true,"path":"2018/02/14/堆排序/","link":"","permalink":"https://lierabbit.cn/2018/02/14/堆排序/","excerpt":"","text":"对于一个int数组，请编写一个堆排序算法，对数组元素排序。给定一个int数组A及数组的大小n，请返回排序后的数组。测试样例：12[1,2,3,5,2,3],6[1,2,2,3,3,5] 时间复杂度：O(nlogn)空间复杂度：O(1) 思路：首先建立一个大根堆。重复进行交换头尾，调整堆使其符合大根堆 123456789101112131415161718192021222324252627282930313233public int[] heapSort(int[] A, int n) &#123; //建堆 for (int i = A.length / 2 - 1; i &gt;= 0; i--) &#123; adjustHeap(A, i, A.length); &#125; int temp; //调整堆 for (int i = A.length - 1; i &gt; 0; i--) &#123; temp = A[0]; A[0] = A[i]; A[i] = temp; adjustHeap(A, 0, i); &#125; return A;&#125;public void adjustHeap(int[] arr, int i, int length) &#123; int max = arr[i]; for (int k = i * 2 + 1; k &lt; length; k = k * 2 + 1) &#123; if (k + 1 &lt; length &amp;&amp; arr[k] &lt; arr[k + 1]) &#123; k++; &#125; if (arr[k] &gt; max) &#123; arr[i] = arr[k]; i = k; &#125; else &#123; break; &#125; &#125; arr[i] = max;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"快速排序","slug":"快速排序","date":"2018-02-13T16:06:46.000Z","updated":"2018-08-23T14:41:53.705Z","comments":true,"path":"2018/02/14/快速排序/","link":"","permalink":"https://lierabbit.cn/2018/02/14/快速排序/","excerpt":"","text":"对于一个int数组，请编写一个快速排序算法，对数组元素排序。给定一个int数组A及数组的大小n，请返回排序后的数组。测试样例：12[1,2,3,5,2,3],6[1,2,2,3,3,5] 时间复杂度：O(nlogn)空间复杂度：O(logn) ~ O(n) 思路：随机获取数组内一个值，将其作为中间值，小于它的放左边，大于它的放右边。然后再对它的左边部分、右边部分分别也进行同样的操作 12345678910111213141516171819202122232425262728293031public int[] quickSort(int[] A, int n) &#123; // write code here if (A == null || A.length &lt; 2) return null; quickSort(A, 0, n - 1); return A;&#125;public void quickSort(int[] arr, int left, int right) &#123; if (left &lt; right) &#123; int mid = partition(arr, left, right); quickSort(arr, left, mid - 1); quickSort(arr, mid + 1, right); &#125;&#125;public int partition(int[] arr, int left, int right) &#123; int random = left + (int) (Math.random() * (right - left + 1)); swap(arr, random, right); int leftIndex = left - 1; int index = left; while (index &lt;= right) &#123; if (arr[index] &lt;= arr[right]) &#123; swap(arr, ++leftIndex, index); &#125; index++; &#125; return leftIndex;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"归并排序","slug":"归并排序","date":"2018-02-13T16:03:06.000Z","updated":"2018-08-23T14:39:28.169Z","comments":true,"path":"2018/02/14/归并排序/","link":"","permalink":"https://lierabbit.cn/2018/02/14/归并排序/","excerpt":"","text":"对于一个int数组，请编写一个归并排序算法，对数组元素排序。给定一个int数组A及数组的大小n，请返回排序后的数组。测试样例： 12[1,2,3,5,2,3],6[1,2,2,3,3,5] 时间复杂度：O(nlogn)空间复杂度：O(n) 思路：将数组分割成一个个独立单元，然后按序合并 1234567891011121314151617181920212223242526272829303132333435363738394041public int[] mergeSort(int[] A, int n) &#123; // write code here if (A == null || A.length &lt; 2) return null; mergeSort(A, 0, n - 1); return A;&#125;public void mergeSort(int[] array, int left, int right) &#123; if (left == right) return; int mid = (left + right) / 2; mergeSort(array, left, mid); mergeSort(array, mid + 1, right); merge(array, left, mid, right);&#125;public void merge(int[] array, int left, int mid, int right) &#123; int[] help = new int[right - left + 1]; int l = left; int r = mid + 1; int index = 0; while (l &lt;= mid &amp;&amp; r &lt;= right) &#123; if (array[l] &lt;= array[r]) help[index++] = array[l++]; else help[index++] = array[r++]; &#125; while (l &lt;= mid) &#123; help[index++] = array[l++]; &#125; while (r &lt;= right) &#123; help[index++] = array[r++]; &#125; for (int i = 0; i &lt; help.length; i++) &#123; array[left + i] = help[i]; &#125;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"插入排序","slug":"插入排序","date":"2018-02-13T15:56:24.000Z","updated":"2018-08-23T14:29:41.734Z","comments":true,"path":"2018/02/13/插入排序/","link":"","permalink":"https://lierabbit.cn/2018/02/13/插入排序/","excerpt":"","text":"对于一个int数组，请编写一个插入排序算法，对数组元素排序。给定一个int数组A及数组的大小n，请返回排序后的数组。测试样例： 12[1,2,3,5,2,3],6[1,2,2,3,3,5] 时间复杂度：O(n2)空间复杂度：O(1) 思路：在数组头构建一个已排好序的小数组，依次插入 123456789101112131415public int[] insertionSort(int[] A, int n) &#123; // write code here for (int i = 1; i &lt; n; i++) &#123; for (int j = i; j &gt; 0; j--) &#123; if (A[j] &lt; A[j - 1]) &#123; int temp = A[j]; A[j] = A[j - 1]; A[j - 1] = temp; &#125; else break; &#125; &#125; return A;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"选择排序","slug":"选择排序","date":"2018-02-13T14:56:46.000Z","updated":"2018-08-23T14:27:19.222Z","comments":true,"path":"2018/02/13/选择排序/","link":"","permalink":"https://lierabbit.cn/2018/02/13/选择排序/","excerpt":"","text":"对于一个int数组，请编写一个选择排序算法，对数组元素排序。给定一个int数组A及数组的大小n，请返回排序后的数组。测试样例：12[1,2,3,5,2,3],6[1,2,2,3,3,5] 时间复杂度：O(n2)空间复杂度：O(1) 思路：每次找出一个最大值，将其放到末尾123456789101112131415161718192021public int[] selectionSort(int[] A, int n) &#123; // write code here int maxIndex; int temp; for (int i = n - 1; i &gt; 0; i--) &#123; maxIndex = i; for (int j = 0; j &lt; i; j++) &#123; if (A[maxIndex] &lt; A[j]) &#123; maxIndex = j; &#125; &#125; if (maxIndex != i) &#123; temp = A[i]; A[i] = A[maxIndex]; A[maxIndex] = temp; &#125; &#125; return A;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"冒泡排序","slug":"冒泡排序","date":"2018-02-13T14:50:35.000Z","updated":"2018-08-23T14:27:32.967Z","comments":true,"path":"2018/02/13/冒泡排序/","link":"","permalink":"https://lierabbit.cn/2018/02/13/冒泡排序/","excerpt":"","text":"对于一个int数组，请编写一个冒泡排序算法，对数组元素排序。给定一个int数组A及数组的大小n，请返回排序后的数组。测试样例：12[1,2,3,5,2,3],6[1,2,2,3,3,5] 时间复杂度：O(n2)空间复杂度：O(1) 思路：与下一个数进行判断交换，使最大值沉底 12345678910111213141516public int[] bubbleSort(int[] A, int n) &#123; // write code here int temp; for (int i = n - 1; i &gt; 0; i--) &#123; for (int j = 0; j &lt; i; j++) &#123; if (A[j] &gt; A[j + 1]) &#123; temp = A[j]; A[j] = A[j + 1]; A[j + 1] = temp; &#125; &#125; &#125; return A; &#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"ArrayList实现原理","slug":"ArrayList实现原理","date":"2018-01-23T04:29:37.000Z","updated":"2018-08-29T13:45:00.306Z","comments":true,"path":"2018/01/23/ArrayList实现原理/","link":"","permalink":"https://lierabbit.cn/2018/01/23/ArrayList实现原理/","excerpt":"概述ArrayList可以简单的看作是动态数组，相对于普通的数组它可以动态的增加容量或者减少容量。要注意的是ArrayList并不是线程安全的，因此一般建议在单线程中使用ArrayList。","text":"概述ArrayList可以简单的看作是动态数组，相对于普通的数组它可以动态的增加容量或者减少容量。要注意的是ArrayList并不是线程安全的，因此一般建议在单线程中使用ArrayList。 实现原理继承关系1public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable ArrayList继承AbstractList实现List, RandomAccess, Cloneable, java.io.Serializable接口 关键属性12345678910111213141516/** * The array buffer into which the elements of the ArrayList are stored. * The capacity of the ArrayList is the length of this array buffer. Any * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA * will be expanded to DEFAULT_CAPACITY when the first element is added. */// 数据的数组transient Object[] elementData; // non-private to simplify nested class access/** * The size of the ArrayList (the number of elements it contains). * * @serial */// 实际数据的数量private int size; 底层使用数组保存所有元素transient 如果用transient声明一个实例变量，当对象存储时，它的值不需要维持。换句话来说就是，用transient关键字标记的成员变量不参与序列化过程 构造方法123456789101112/** * Shared empty array instance used for default sized empty instances. We * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when * first element is added. */private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;/** * Constructs an empty list with an initial capacity of ten. */public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125; 默认情况下初始化空数组（长度为0的数组） 123456789101112131415161718192021/** * Shared empty array instance used for empty instances. */private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;/** * Constructs an empty list with the specified initial capacity. * * @param initialCapacity the initial capacity of the list * @throws IllegalArgumentException if the specified initial capacity * is negative */public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException(\"Illegal Capacity: \"+ initialCapacity); &#125;&#125; 指定数组的初始容量当指定的初始容量大于0，初始化指定大小的数组当指定的初始容量等于0，初始化空数组当指定的初始容量小于0，抛出IllegalArgumentException异常12345678910111213141516171819/** * Constructs a list containing the elements of the specified * collection, in the order they are returned by the collection's * iterator. * * @param c the collection whose elements are to be placed into this list * @throws NullPointerException if the specified collection is null */public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; &#125;&#125; 初始化指定集合的数组当指定集合不为空即长度不为0，则复制该集合，否则初始化一个空数组 E get(int index) 获取index位置的元素123456789101112131415161718192021222324252627282930313233343536373839404142// Positional Access Operations// 返回index下标的元素且强制转化为E（List&lt;E&gt;中的E）类型@SuppressWarnings(\"unchecked\")E elementData(int index) &#123; return (E) elementData[index];&#125;/** * Returns the element at the specified position in this list. * * @param index index of the element to return * @return the element at the specified position in this list * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */public E get(int index) &#123; // 检查index是否越界 rangeCheck(index); // 返回index下标的元素 return elementData(index);&#125;/** * Checks if the given index is in range. If not, throws an appropriate * runtime exception. This method does *not* check if the index is * negative: It is always used immediately prior to an array access, * which throws an ArrayIndexOutOfBoundsException if index is negative. */private void rangeCheck(int index) &#123; // 检查index是否大于等于size（数组的元素数量），因为数组下标从0开始计算，所以也不能等于元素数量 // 这里没有检查index &lt; 0的情况，因为index &lt; 0时数组会自动抛出异常，所以并未检查index&lt;0的情况 if (index &gt;= size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index));&#125;/** * Constructs an IndexOutOfBoundsException detail message. * Of the many possible refactorings of the error handling code, * this \"outlining\" performs best with both server and client VMs. */private String outOfBoundsMsg(int index) &#123; return \"Index: \"+index+\", Size: \"+size;&#125; 首先判断index是否越界，这里并没有判断是否小于0，因为下标小于0时数组会抛出异常。越界则抛出IndexOutOfBoundsException异常，反之返回数组对应index位置的元素 E set(int index, E element) 设置（覆盖）index位置的元素12345678910111213141516/** * Replaces the element at the specified position in this list with * the specified element. * * @param index index of the element to replace * @param element element to be stored at the specified position * @return the element previously at the specified position * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */public E set(int index, E element) &#123; rangeCheck(index); E oldValue = elementData(index); elementData[index] = element; return oldValue;&#125; 和get一样先判断index（下标）是否越界，不越界则先获取原来index位置上的元素，接着设置（覆盖）index位置上的元素，然后返回原来的元素，反之抛出IndexOutOfBoundsException异常 boolean add(E e) 添加一个元素到列表尾123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/** * Appends the specified element to the end of this list. * * @param e element to be appended to this list * @return &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;@link Collection#add&#125;) */public boolean add(E e) &#123; // 检查当前容量是否还可以容纳一个元素，不够则扩容 ensureCapacityInternal(size + 1); // Increments modCount!! // 添加到数组末尾 // 这个语句可以分解为 // elementData[size] = e; // size += 1; elementData[size++] = e; return true;&#125;/** * Default initial capacity. */private static final int DEFAULT_CAPACITY = 10; // 默认容量为10// 如果数据等于默认数据，返回默认容量和minCapacity（所需容量最小值）的最大值，反之返回所需容量最小值private static int calculateCapacity(Object[] elementData, int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; return Math.max(DEFAULT_CAPACITY, minCapacity); &#125; return minCapacity;&#125;private void ensureCapacityInternal(int minCapacity) &#123; ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));&#125;private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // 操作数+1 // overflow-conscious code // 如果所需容量最小值大于实际数组的长度就扩大实际数组容量 if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125;/** * The maximum size of array to allocate. * Some VMs reserve some header words in an array. * Attempts to allocate larger arrays may result in * OutOfMemoryError: Requested array size exceeds VM limit */private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; // 数组最大容量为Integer最大值-8/** * Increases the capacity to ensure that it can hold at least the * number of elements specified by the minimum capacity argument. * * @param minCapacity the desired minimum capacity */private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; // 新的容量为旧的容量的1.5倍 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); // 如果扩充容量后还是不够，则新的容量等于所需容量最小值（一般就是数组实际元素个数） if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; // 如果新的容量大于数组最大容量，再调用hugeCapacity计算新的容量 if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: // 复制原来的数据到新的数组，数组容量为新的容量 elementData = Arrays.copyOf(elementData, newCapacity);&#125;private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); // 大于数组最大容量返回Integer最大值，反之返回数组最大容量 return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;&#125; 添加一个元素到列表尾，当列表容量不足时自动扩容（通常是扩容至原来的1.5倍），添加成功返回true void add(int index, E element) 在index处放置元素123456789101112131415161718192021222324252627282930/** * Inserts the specified element at the specified position in this * list. Shifts the element currently at that position (if any) and * any subsequent elements to the right (adds one to their indices). * * @param index index at which the specified element is to be inserted * @param element element to be inserted * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */public void add(int index, E element) &#123; // 检查下标是否越界 rangeCheckForAdd(index); // 检查当前容量是否还可以在容纳一个元素，不够则扩容 ensureCapacityInternal(size + 1); // Increments modCount!! // 将elementData从index开始后面的元素往后移一位 System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++;&#125;/** * A version of rangeCheck used by add and addAll. */private void rangeCheckForAdd(int index) &#123; // 当index等于size时相当于添加元素到列表尾 if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException(outOfBoundsMsg(index));&#125; 将elementData数组从index开始后面的元素往后移一位，接着在index处放置元素模拟添加数据(lierabbit)到index=4过程如下1 初始数组 0 1 2 3 4 5 6 7 8 9 a b c d e f g h i j 2 从index开始后面的元素往后移一位 0 1 2 3 4 5 6 7 8 9 a b c d e e f g h i 3 在index处放置lierabbit 0 1 2 3 4 5 6 7 8 9 a b c d lierabbit e f g h i boolean addAll(Collection&lt;? extends E&gt; c) 添加一个集合里的所有元素到列表尾123456789101112131415161718192021222324/** * Appends all of the elements in the specified collection to the end of * this list, in the order that they are returned by the * specified collection's Iterator. The behavior of this operation is * undefined if the specified collection is modified while the operation * is in progress. (This implies that the behavior of this call is * undefined if the specified collection is this list, and this * list is nonempty.) * * @param c collection containing elements to be added to this list * @return &lt;tt&gt;true&lt;/tt&gt; if this list changed as a result of the call * @throws NullPointerException if the specified collection is null */public boolean addAll(Collection&lt;? extends E&gt; c) &#123; Object[] a = c.toArray(); int numNew = a.length; // 检查当前容量是否还可以在容纳a数组的元素，不够则扩容 ensureCapacityInternal(size + numNew); // Increments modCount // 将a数组里的元素添加到elementData末尾 System.arraycopy(a, 0, elementData, size, numNew); size += numNew; // a数组不为空（长度不为0）时返回true，反之false return numNew != 0;&#125; 将要添加的集合变为数组，然后将其复制到elementData数组末尾 boolean addAll(int index, Collection&lt;? extends E&gt; c) 添加一个集合里的所有元素到index位置123456789101112131415161718192021222324252627282930313233343536/** * Inserts all of the elements in the specified collection into this * list, starting at the specified position. Shifts the element * currently at that position (if any) and any subsequent elements to * the right (increases their indices). The new elements will appear * in the list in the order that they are returned by the * specified collection's iterator. * * @param index index at which to insert the first element from the * specified collection * @param c collection containing elements to be added to this list * @return &lt;tt&gt;true&lt;/tt&gt; if this list changed as a result of the call * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; * @throws NullPointerException if the specified collection is null */public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; // 检查下标是否越界 rangeCheckForAdd(index); Object[] a = c.toArray(); int numNew = a.length; // 检查当前容量是否还可以在容纳a数组的元素，不够则扩容 ensureCapacityInternal(size + numNew); // Increments modCount // 需要往后移动几个位置 int numMoved = size - index; if (numMoved &gt; 0) // 从index开始，往后的元素向后移动numMoved个位置 System.arraycopy(elementData, index, elementData, index + numNew, numMoved); // 将a数组里的所有元素复制到elementData从index到index + numNew -1的位置上 System.arraycopy(a, 0, elementData, index, numNew); size += numNew; // a数组不为空（长度不为0）时返回true，反之false return numNew != 0;&#125; 将要添加的集合变为数组，然后把elementData数组从index开始，往后的元素向后移动numMoved个位置，接着将要添加的数组里的所有元素复制到elementData从index到index + numNew -1的位置上 void trimToSize() 改变列表内部数组容量至列表实际元素数量123456789101112131415/** * Trims the capacity of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance to be the * list's current size. An application can use this operation to minimize * the storage of an &lt;tt&gt;ArrayList&lt;/tt&gt; instance. */public void trimToSize() &#123; modCount++; // 操作数+1 // 如果数组实际元素数量小于数组长度 if (size &lt; elementData.length) &#123; // 如果数组实际元素数量等于0则数组被赋值为空数组，反之创建一个新的元素数量等于数组长度的数组 elementData = (size == 0) ? EMPTY_ELEMENTDATA : Arrays.copyOf(elementData, size); &#125;&#125; 当数据稳定了之后可以使用这个方法来减少内存的使用 int indexOf(Object o) 查找o元素在列表第一次出现的位置123456789101112131415161718192021/** * Returns the index of the first occurrence of the specified element * in this list, or -1 if this list does not contain the element. * More formally, returns the lowest index &lt;tt&gt;i&lt;/tt&gt; such that * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt;, * or -1 if there is no such index. */public int indexOf(Object o) &#123; //元素可以为null，如果为null返回null的下标 if (o == null) &#123; for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; &#125; else &#123; for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; &#125; // 没有找到对应的元素返回-1 return -1;&#125; ArrayList中可以存放null元素，indexof是返回elementData数组中值相同的首个元素的下标，indexof中比较方法是equals而equals是比较元素的值，因此必须对null单独查找。如果未找到该元素则返回-1 E remove(int index) 删除index位置上的元素1234567891011121314151617181920212223242526/** * Removes the element at the specified position in this list. * Shifts any subsequent elements to the left (subtracts one from their * indices). * * @param index the index of the element to be removed * @return the element that was removed from the list * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */public E remove(int index) &#123; // 检查下标是否越界 rangeCheck(index); modCount++; // 操作数+1 E oldValue = elementData(index); // 获取index位置上的元素 int numMoved = size - index - 1; // 需要往前移动几个位置 if (numMoved &gt; 0) // 从index + 1开始，往后的元素向前移动1个位置 System.arraycopy(elementData, index+1, elementData, index, numMoved); // 将数组末尾元素置空 elementData[--size] = null; // clear to let GC do its work return oldValue;&#125; 模拟删除index=4（值为lierabbit）过程如下1 初始数组 0 1 2 3 4 5 6 7 8 9 a b c d lierabbit f g h i j 2 从index + 1（即index=5，值为f）开始，往后的元素向前移动1个位置 0 1 2 3 4 5 6 7 8 9 a b c d f g h i j j 3 将数组末尾元素置空 0 1 2 3 4 5 6 7 8 9 a b c d f g h i j null boolean remove(Object o) 删除o元素123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * Removes the first occurrence of the specified element from this list, * if it is present. If the list does not contain the element, it is * unchanged. More formally, removes the element with the lowest index * &lt;tt&gt;i&lt;/tt&gt; such that * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt; * (if such an element exists). Returns &lt;tt&gt;true&lt;/tt&gt; if this list * contained the specified element (or equivalently, if this list * changed as a result of the call). * * @param o element to be removed from this list, if present * @return &lt;tt&gt;true&lt;/tt&gt; if this list contained the specified element */public boolean remove(Object o) &#123; // 元素可以为null，分开搜索o if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; // 没有找到返回false return false;&#125;/* * Private remove method that skips bounds checking and does not * return the value removed. */// 由于已经找到元素，则元素必定存在，则index必定合理，所以不需要在检查index是否越界private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work&#125; 通过寻找o元素，可以获得其下标，再根据下标删除o元素 forEach(Consumer&lt;? super E&gt; action)遍历列表12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * The number of times this list has been &lt;i&gt;structurally modified&lt;/i&gt;. * Structural modifications are those that change the size of the * list, or otherwise perturb it in such a fashion that iterations in * progress may yield incorrect results. * * &lt;p&gt;This field is used by the iterator and list iterator implementation * returned by the &#123;@code iterator&#125; and &#123;@code listIterator&#125; methods. * If the value of this field changes unexpectedly, the iterator (or list * iterator) will throw a &#123;@code ConcurrentModificationException&#125; in * response to the &#123;@code next&#125;, &#123;@code remove&#125;, &#123;@code previous&#125;, * &#123;@code set&#125; or &#123;@code add&#125; operations. This provides * &lt;i&gt;fail-fast&lt;/i&gt; behavior, rather than non-deterministic behavior in * the face of concurrent modification during iteration. * * &lt;p&gt;&lt;b&gt;Use of this field by subclasses is optional.&lt;/b&gt; If a subclass * wishes to provide fail-fast iterators (and list iterators), then it * merely has to increment this field in its &#123;@code add(int, E)&#125; and * &#123;@code remove(int)&#125; methods (and any other methods that it overrides * that result in structural modifications to the list). A single call to * &#123;@code add(int, E)&#125; or &#123;@code remove(int)&#125; must add no more than * one to this field, or the iterators (and list iterators) will throw * bogus &#123;@code ConcurrentModificationExceptions&#125;. If an implementation * does not wish to provide fail-fast iterators, this field may be * ignored. */protected transient int modCount = 0;//操作数@Overridepublic void forEach(Consumer&lt;? super E&gt; action) &#123; // 确保不为空 Objects.requireNonNull(action); final int expectedModCount = modCount; @SuppressWarnings(\"unchecked\") final E[] elementData = (E[]) this.elementData; final int size = this.size; for (int i=0; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123; action.accept(elementData[i]); &#125; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125;&#125;/** * Checks that the specified object reference is not &#123;@code null&#125;. This * method is designed primarily for doing parameter validation in methods * and constructors, as demonstrated below: * &lt;blockquote&gt;&lt;pre&gt; * public Foo(Bar bar) &#123; * this.bar = Objects.requireNonNull(bar); * &#125; * &lt;/pre&gt;&lt;/blockquote&gt; * * @param obj the object reference to check for nullity * @param &lt;T&gt; the type of the reference * @return &#123;@code obj&#125; if not &#123;@code null&#125; * @throws NullPointerException if &#123;@code obj&#125; is &#123;@code null&#125; */public static &lt;T&gt; T requireNonNull(T obj) &#123; if (obj == null) throw new NullPointerException(); return obj;&#125; 这里可以看到modCount的用处，当modCount发生改变后，立刻抛出ConcurrentModificationException异常。通过之前的分析可以知道当列表内容被修改时modCount会增加。也就是说如果在遍历ArrayList的过程中有其他线程修改了ArrayList，那么将抛出ConcurrentModificationException异常 ArrayList小结 ArrayList是List接口的一个可变大小的数组的实现 ArrayList的内部是使用一个Object对象数组来存储元素的 初始化ArrayList的时候，可以指定初始化容量的大小，如果不指定，就会使用默认大小，为10 当添加一个新元素的时候，首先会检查容量是否足够添加这个元素，如果够就直接添加，如果不够就进行扩容，扩容为原数组容量的1.5倍 当在index处放置一个元素的时候，会将数组index处右边的元素全部右移 当在index处删除一个元素的时候，会将数组index处右边的元素全部左移","categories":[{"name":"Java从深入到放弃","slug":"Java从深入到放弃","permalink":"https://lierabbit.cn/categories/Java从深入到放弃/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://lierabbit.cn/tags/Java/"}]},{"title":"SpringBoot快速入门6-thymeleaf","slug":"SpringBoot快速入门6-thymeleaf","date":"2018-01-21T13:48:52.000Z","updated":"2018-08-29T14:15:10.693Z","comments":true,"path":"2018/01/21/SpringBoot快速入门6-thymeleaf/","link":"","permalink":"https://lierabbit.cn/2018/01/21/SpringBoot快速入门6-thymeleaf/","excerpt":"静态资源在我们开发Web应用的时候，需要引用大量的js、css、图片等静态资源。Spring Boot的默认位置是resources/static","text":"静态资源在我们开发Web应用的时候，需要引用大量的js、css、图片等静态资源。Spring Boot的默认位置是resources/static 模版页面各种模版的页面，这次我们选用ThymeleafSpring Boot的默认位置是resources/templates 渲染页面在之前的示例中，我们都是通过@RestController来处理请求，所以返回的内容为json对象。当我们需要页面的时候使用@Controller，使其寻找模版页面 添加依赖对于已存在的项目可以在bulid.gradle加入12compile(&apos;org.springframework.boot:spring-boot-starter-thymeleaf&apos;)compile(&apos;org.springframework.boot:spring-boot-starter-web&apos;) 至此Thymeleaf已经引入 创建控制器新建一个ThymeleafCtrl类1234567891011121314import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;@Controller//这是一个控制器public class ThymeleafCtrl&#123; @RequestMapping(\"/\") public String hello(Model model) &#123; model.addAttribute(\"hello\",\"hello thymeleaf\");//添加一个值为\"hello thymeleaf\"的hello变量到视图 return \"hello\";//在templates下寻找hello.html &#125;&#125; 创建模版页面在resources/templates创建一个hello.html页面1234567891011&lt;!DOCTYPE html&gt;&lt;html xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;!-- xmlns:th=\"http://www.thymeleaf.org\" 减少ide报错，可以没有 --&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"/&gt; &lt;title&gt;Hello&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 th:text=\"$&#123;hello&#125;\"&gt;LieRabbit&lt;/h1&gt;&lt;!-- 使用hello变量 --&gt;&lt;img src=\"lierabbit.jpg\"/&gt;&lt;/body&gt;&lt;/html&gt; 添加图片资源在resources/static添加lierabbit.jpg 运行结果更多的Thymeleaf的语法请前往官网查看文档（http://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html）源码地址：https://github.com/LieRabbit/SpringBoot-thymeleaf","categories":[{"name":"SpringBoot快速入门","slug":"SpringBoot快速入门","permalink":"https://lierabbit.cn/categories/SpringBoot快速入门/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://lierabbit.cn/tags/SpringBoot/"}]},{"title":"SpringBoot快速入门5-使用MyBatis（注解形式）进行数据库操作","slug":"SpringBoot快速入门5-使用MyBatis（注解形式）进行数据库操作","date":"2018-01-17T01:31:07.000Z","updated":"2018-08-29T14:14:52.455Z","comments":true,"path":"2018/01/17/SpringBoot快速入门5-使用MyBatis（注解形式）进行数据库操作/","link":"","permalink":"https://lierabbit.cn/2018/01/17/SpringBoot快速入门5-使用MyBatis（注解形式）进行数据库操作/","excerpt":"添加依赖新建项目选择web,MyBatis,MySQL三个依赖","text":"添加依赖新建项目选择web,MyBatis,MySQL三个依赖 对于已存在的项目可以在bulid.gradle加入，spring boot将会帮你自动配置好1234compile(&apos;org.springframework.boot:spring-boot-starter-data-jpa&apos;)compile(&apos;org.springframework.boot:spring-boot-starter-web&apos;)runtime(&apos;mysql:mysql-connector-java&apos;)testCompile(&apos;org.springframework.boot:spring-boot-starter-test&apos;) 配置基本信息然后在src/main/resources/application.properties下添加基本配置12345678#数据库连接地址spring.datasource.url=jdbc:mysql://localhost:3306/mybaits?useSSL=false#数据库账号spring.datasource.username=root#数据库密码spring.datasource.password=123456zxc#数据库驱动spring.datasource.driver-class-name=com.mysql.jdbc.Driver 创建实体创建一个User实体，包含id、name（姓名）、age（年龄）属性12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class User&#123; private Long id; private String name; private Integer age; public User() &#123; &#125; public User(String name, Integer age) &#123; this.name = name; this.age = age; &#125; public Long getId() &#123; return id; &#125; public void setId(Long id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125;&#125; 创建数据访问接口创建一个userMapper接口，进行数据库操作，添加@Mapper注解12345678910111213141516171819202122232425import org.apache.ibatis.annotations.*;import java.util.List;@Mapper//这是一个MyBatis的数据库操作接口public interface UserMapper&#123; @Select(\"SELECT * FROM user WHERE name = #&#123;name&#125;\") User findByName(@Param(\"name\") String name); @Select(\"SELECT * FROM user WHERE name LIKE #&#123;name&#125;\") List&lt;User&gt; findByNameLike(@Param(\"name\") String name); @Insert(\"INSERT INTO user(name, age) VALUES(#&#123;name&#125;, #&#123;age&#125;)\") int insert(@Param(\"name\") String name, @Param(\"age\") Integer age); @Update(\"UPDATE user SET age = #&#123;age&#125; WHERE name = #&#123;name&#125;\") int update(@Param(\"name\") String name, @Param(\"age\") Integer age); @Delete(\"DELETE FROM user WHERE name = #&#123;name&#125;\") int delete(@Param(\"name\") String name); @Select(\"SELECT COUNT(*) FROM user\") int countAll();&#125; 单元测试在src/test/java/你的包名/你的项目名ApplicationTests编写对应的单元测试来验证编写的内容是否正确12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import org.junit.Assert;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.annotation.Rollback;import org.springframework.test.context.junit4.SpringRunner;import org.springframework.transaction.annotation.Transactional;@RunWith(SpringRunner.class)@SpringBootTest@Transactional//声明事务，配合Rollbackpublic class MybatisApplicationTests&#123; @Autowired private UserMapper userMapper; @Test @Rollback//测试结束回滚数据，保证测试单元每次运行的数据环境独立 public void testUser() &#123; userMapper.insert(\"QQQ\",1); userMapper.insert(\"WWW\",2); userMapper.insert(\"EEE\",3); userMapper.insert(\"AAA\",4); userMapper.insert(\"SSS\",5); userMapper.insert(\"DDD\",6); userMapper.insert(\"ZZZ\",7); userMapper.insert(\"XXX\",8); userMapper.insert(\"CCC\",9); userMapper.insert(\"SSS213\",10); // 测试findAll, 查询所有记录 Assert.assertEquals(10, userMapper.countAll()); // 测试findByName, 查询姓名为AAA的User Assert.assertEquals(4, userMapper.findByName(\"AAA\").getAge().longValue()); // 更新CCC用户的年龄为15 userMapper.update(\"CCC\",15); // 测试findByName, 查询姓名为CCC的User的年龄是否为15 Assert.assertEquals(15, userMapper.findByName(\"CCC\").getAge().longValue()); // 测试删除姓名为AAA的User userMapper.delete(\"AAA\"); // 测试findAll, 查询所有记录, 验证上面的删除是否成功 Assert.assertEquals(9, userMapper.countAll()); // 测试findAll, 查询名字有S的有几个 Assert.assertEquals(2,userMapper.findByNameLike(\"%S%\").size()); &#125;&#125; 测试结果 源码地址：https://github.com/LieRabbit/SpringBoot-mybatis","categories":[{"name":"SpringBoot快速入门","slug":"SpringBoot快速入门","permalink":"https://lierabbit.cn/categories/SpringBoot快速入门/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://lierabbit.cn/tags/SpringBoot/"}]},{"title":"SpringBoot快速入门4-使用jpa进行数据库操作","slug":"SpringBoot快速入门4-使用jpa进行数据库操作","date":"2018-01-15T15:49:41.000Z","updated":"2018-08-29T14:14:46.129Z","comments":true,"path":"2018/01/15/SpringBoot快速入门4-使用jpa进行数据库操作/","link":"","permalink":"https://lierabbit.cn/2018/01/15/SpringBoot快速入门4-使用jpa进行数据库操作/","excerpt":"添加依赖新建项目选择web,JPA,MySQL三个依赖","text":"添加依赖新建项目选择web,JPA,MySQL三个依赖 对于已存在的项目可以在bulid.gradle加入，spring boot将会帮你自动配置好 123compile(&apos;org.springframework.boot:spring-boot-starter-data-jpa&apos;)compile(&apos;org.springframework.boot:spring-boot-starter-web&apos;)runtime(&apos;mysql:mysql-connector-java&apos;) 配置基本信息然后在src/main/resources/application.properties下添加基本配置123456789101112#数据库连接地址spring.datasource.url=jdbc:mysql://localhost:3306/jpa?useSSL=false#数据库账号spring.datasource.username=root#数据库密码spring.datasource.password=123456zxc#数据库驱动spring.datasource.driver-class-name=com.mysql.jdbc.Driver#jpa设置spring.jpa.hibernate.ddl-auto=create#是否在控制台显示数据库语句spring.jpa.show-sql=true spring.jpa.properties.hibernate.hbm2ddl.auto 其作用是：自动创建、更新、验证数据库表结构。该参数的几种配置如下： create：每次加载hibernate时都会删除上一次的生成的表，然后根据你的model类再重新来生成新表，哪怕两次没有任何改变也要这样执行，这就是导致数据库表数据丢失的一个重要原因。 create-drop：每次加载hibernate时根据model类生成表，但是sessionFactory一关闭,表就自动删除。 update：最常用的属性，第一次加载hibernate时根据model类会自动建立起表的结构（前提是先建立好数据库），以后加载hibernate时根据model类自动更新表结构，即使表结构改变了但表中的行仍然存在不会删除以前的行。要注意的是当部署到服务器后，表结构是不会被马上建立起来的，是要等应用第一次运行起来后才会。 validate：每次加载hibernate时，验证创建数据库表结构，只会和数据库中的表进行比较，不会创建新表，但是会插入新值。 none：什么都不做至此基本配置完成 创建实体创建一个User实体，包含id（主键）、name（姓名）、age（年龄）属性，通过ORM框架其会被映射到数据库表中，由于配置了hibernate.hbm2ddl.auto，在应用启动的时候框架会自动去数据库中创建对应的表。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import javax.persistence.Column;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.Id;@Entity//这是一个和数据库表相关联的类public class User&#123; @Id//主键 @GeneratedValue//自增长 private Long id;//id @Column(length = 30)//长度30 private String name;//名称 @Column(nullable = false)//不可空 private Integer age;//年龄 public User() &#123; &#125; public User(String name, Integer age) &#123; this.name = name; this.age = age; &#125; public Long getId() &#123; return id; &#125; public void setId(Long id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125;&#125; 创建数据访问接口创建一个userRepository接口，进行数据库操作 12345678910111213141516171819202122232425import org.springframework.data.jpa.repository.JpaRepository;import org.springframework.data.jpa.repository.Query;import org.springframework.data.repository.query.Param;import java.util.List;public interface UserRepository extends JpaRepository&lt;User, Long&gt;//JpaRepository&lt;实体类型，主键类型&gt;&#123; // 通过名称找到用户 User findByName(String name); // 通过名称和年龄找到用户 User findByNameAndAge(String name, Integer age); // 通过名称模糊查询 List&lt;User&gt; findByNameLike(String name); // 使用hql查询 @Query(\"from User u where u.name=:name\")//:name对应@Param里的name User findByHQL(@Param(\"name\") String name); // 使用sql查询 @Query(value = \"select * from user where name = ?1 and age = ?2\", nativeQuery = true)//?1表示第一个参数，?2表示第二个参数 User findBySQL(String name, Integer age);&#125; 单元测试在src/test/java/你的包名/你的项目名ApplicationTests编写对应的单元测试来验证编写的内容是否正确 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import org.junit.Assert;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;@RunWith(SpringRunner.class)@SpringBootTestpublic class JpaLearnApplicationTests&#123; // 注入userRepository @Autowired private UserRepository userRepository; @Test public void contextLoads() &#123; // 添加10个测试用例 userRepository.save(new User(\"QQQ\",1)); userRepository.save(new User(\"WWW\",2)); userRepository.save(new User(\"EEE\",3)); userRepository.save(new User(\"AAA\",4)); userRepository.save(new User(\"SSS\",5)); userRepository.save(new User(\"DDD\",6)); userRepository.save(new User(\"ZZZ\",7)); userRepository.save(new User(\"XXX\",8)); userRepository.save(new User(\"CCC\",9)); userRepository.save(new User(\"QQQ2\",10)); // 测试findAll, 查询所有记录 Assert.assertEquals(10, userRepository.findAll().size()); // 测试findByName, 查询姓名为AAA的User Assert.assertEquals(4, userRepository.findByName(\"AAA\").getAge().longValue()); // 测试findByHQL, 查询姓名为AAA的User Assert.assertEquals(4, userRepository.findByHQL(\"AAA\").getAge().longValue()); // 测试findByNameAndAge, 查询姓名为SSS并且年龄为5的User Assert.assertEquals(\"SSS\", userRepository.findByNameAndAge(\"SSS\", 5).getName()); // 测试findBySQL, 查询姓名为SSS并且年龄为5的User Assert.assertEquals(\"SSS\", userRepository.findBySQL(\"SSS\", 5).getName()); // 测试删除姓名为AAA的User userRepository.delete(userRepository.findByName(\"AAA\")); // 测试findAll, 查询所有记录, 验证上面的删除是否成功 Assert.assertEquals(9, userRepository.findAll().size()); // 测试findAll, 查询名字有Q的有几个 Assert.assertEquals(2,userRepository.findByNameLike(\"%Q%\").size()); &#125;&#125; 点击运行测试用例 源码地址：https://github.com/LieRabbit/SpringBoot-jpa-learn","categories":[{"name":"SpringBoot快速入门","slug":"SpringBoot快速入门","permalink":"https://lierabbit.cn/categories/SpringBoot快速入门/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://lierabbit.cn/tags/SpringBoot/"}]},{"title":"SpringBoot快速入门3-依赖注入","slug":"SpringBoot快速入门3-依赖注入","date":"2018-01-15T14:48:05.000Z","updated":"2018-08-29T14:12:56.881Z","comments":true,"path":"2018/01/15/SpringBoot快速入门3-依赖注入/","link":"","permalink":"https://lierabbit.cn/2018/01/15/SpringBoot快速入门3-依赖注入/","excerpt":"spring boot使用依赖注入的方式很简单，只需要给添加相应的注解即可 @Service用于标注业务层组件 @Controller用于标注控制层组件 @Repository用于标注数据访问组件，即DAO组件 @Component泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。然后在使用的地方使用@Autowired即可","text":"spring boot使用依赖注入的方式很简单，只需要给添加相应的注解即可 @Service用于标注业务层组件 @Controller用于标注控制层组件 @Repository用于标注数据访问组件，即DAO组件 @Component泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。然后在使用的地方使用@Autowired即可 创建MyComponent，使用@Component12345678910import org.springframework.stereotype.Component;@Component//泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。public class MyComponent&#123; public void hi(String name) &#123; System.out.println(\"hi \" + name + \",I am MyComponent\"); &#125;&#125; 创建MyController，使用@Controller12345678910import org.springframework.stereotype.Controller;@Controller//用于标注控制层组件public class MyController&#123; public void hi(String name) &#123; System.out.println(\"hi \" + name + \",I am MyController\"); &#125;&#125; 创建MyRepository，使用@Repository12345678@Repository//用于标注数据访问组件，即DAO组件public class MyRepository&#123; public void hi(String name) &#123; System.out.println(\"hi \" + name + \",I am MyRepository\"); &#125;&#125; 创建MyService，MyServiceImpl，使用@Service1234public interface MyService&#123; void doSomeThing();&#125; 123456789101112import org.springframework.stereotype.Service;@Service//用于标注业务层组件public class MyServiceImpl implements MyService&#123; @Override public void doSomeThing() &#123; System.out.println(\"i am MyServiceImpl\"); &#125;&#125; 单元测试在src/test/java/你的包名/你的项目名ApplicationTests编写对应的单元测试来验证是否可以成功注入 1234567891011121314151617181920212223242526272829import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;@RunWith(SpringRunner.class)@SpringBootTestpublic class DiApplicationTests&#123; @Autowired//自动注入 private MyController myController; @Autowired//自动注入 private MyRepository myRepository; @Autowired//自动注入 private MyComponent myComponent; @Autowired//自动注入实现了该接口的bean private MyService myService; @Test public void contextLoads() &#123; myController.hi(\"lierabbit\"); myRepository.hi(\"lierabbit\"); myComponent.hi(\"lierabbit\"); myService.doSomeThing(); &#125;&#125; 运行测试用例显示红圈的4句话证明成功注入 源码地址：https://github.com/LieRabbit/SpringBoot-DI","categories":[{"name":"SpringBoot快速入门","slug":"SpringBoot快速入门","permalink":"https://lierabbit.cn/categories/SpringBoot快速入门/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://lierabbit.cn/tags/SpringBoot/"}]},{"title":"SpringBoot快速入门2-Http请求","slug":"SpringBoot快速入门2-Http请求","date":"2018-01-14T12:05:08.000Z","updated":"2018-08-29T14:11:16.341Z","comments":true,"path":"2018/01/14/SpringBoot快速入门2-Http请求/","link":"","permalink":"https://lierabbit.cn/2018/01/14/SpringBoot快速入门2-Http请求/","excerpt":"准备postman：一个接口测试工具创建一个新工程","text":"准备postman：一个接口测试工具创建一个新工程 选择web不会的请看Spring Boot快速入门（一）：Hello Spring Boot 开始新建java类RequestCtrl 添加一个all方法，使用@RequestMapping注解，可以处理所有的http请求 123456789@RestController//这是一个控制器并只返回数据不寻找视图public class RequestCtrl&#123; @RequestMapping(\"/\")//将本方法映射到/ public String all(String name, Integer age)//接受2个参数,name和age &#123; return \"这里是all\\n\" + \"name: \" + name + \"\\n\" + \"age: \" + age; &#125;&#125; requestMapping的作用可以简单理解为给方法加个地址，让别人能访问 通过源码可以看出@RestController是@Controller和ResponseBody的结合注解@Controller 表明这是一个控制器，将会返回数据或者页面@ResponseBody 表明只会返回数据，Spring Boot默认将数据使用jaskson序列化为json返回JSON(JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式，常见表现形式为键值对{key:value}，例如{name:”lierabbit”,age:20}，字符串和数字直接返回启动程序，打开postman对http://localhost:8080发起get请求 发起带参数的请求 使用post请求 添加一个get方法，使用@GetMapping注解，只可以处理get类型的http请求12345@GetMapping(\"/get\")//将本方法映射到/get，且只能用get方式访问public String get(String name, int age)//接受2个参数,name和age&#123; return \"这里是get\\n\" + \"name: \" + name + \"\\n\" + \"age: \" + age;&#125; 使用get方式访问http://localhost:8080/get?name=lierabbit&amp;age=20 尝试使用post访问，将得到405异常 添加一个post方法，使用@PostMapping注解，只可以处理post类型的http请求12345@PostMapping(\"/post\")//将本方法映射到/post，且只能用post方式访问public String post(String name, int age)//接受2个参数,name和age&#123; return \"这里是post\\n\" + \"name: \" + name + \"\\n\" + \"age: \" + age;&#125; 使用post方式访问 尝试使用get访问，得到405异常 添加一个put方法，使用@PutMapping注解，只可以处理put类型的http请求12345678@PutMapping(\"/put\")//将本方法映射到/put，且只能用put方式访问public User put(@RequestBody User user)//接受一个user实体&#123; user.setName(\"名字已经被修改：\" + user.getName()); user.setAge(user.getAge() + 1); return user;&#125;@RequestBody 表示接受一个user实体（user json） 返回User，会被spring boot自动序列化为json 添加一个delete方法，使用@DeleteMapping注解，只可以处理delete类型的http请求1234567@DeleteMapping(\"/delete\")//将本方法映射到/delete，且只能用delete方式访问public User delete(@RequestBody User user)//接受一个user实体&#123; user.setName(\"这个用户将会被删除：\" + user.getName()); user.setAge(user.getAge() + 1); return user;&#125; 添加一个patch方法，使用@PatchMapping注解，只可以处理patch类型的http请求123456@PatchMapping(\"/patch\")//将本方法映射到/patch，且只能用patch方式访问public User pathch(@RequestBody User user)//接受一个user实体&#123; user.setName(\"只改名称：\" + user.getName()); return user;&#125; 源码地址：https://github.com/LieRabbit/SpringBoot-request","categories":[{"name":"SpringBoot快速入门","slug":"SpringBoot快速入门","permalink":"https://lierabbit.cn/categories/SpringBoot快速入门/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://lierabbit.cn/tags/SpringBoot/"}]},{"title":"升级node与npm","slug":"升级node与npm","date":"2018-01-14T09:48:54.000Z","updated":"2018-08-25T10:18:45.594Z","comments":true,"path":"2018/01/14/升级node与npm/","link":"","permalink":"https://lierabbit.cn/2018/01/14/升级node与npm/","excerpt":"","text":"升级node安装 n 工具，这个工具的名称很短，方便输入npm install -g n 升级node至长期版或者最新版上图为node中文官网的截图123n lts //升级到LTS版本，即上图的8.9.4n stable //升级到最新稳定版，即上图的9.4.0 n工具其它的一些命令123456789101112n 输出已安装的node版本n latest 安装最新的node版本n stable 安装最新稳定的node版本n lts 安装最新LTS的node版本n &lt;version&gt; 安装指定的node版本n bin &lt;version&gt; 输出指定的node的位置n rm &lt;version ...&gt; 删除指定的node版本n prune 删除除了当前node版本之外的所有版本n --latest 输出最新的node版本n --stable 输出最新稳定的node版本n --lts 输出最新LTS的node版本n ls 输出所有node版本 升级npm1npm install -g npm 一句话解决","categories":[],"tags":[{"name":"NodeJs","slug":"NodeJs","permalink":"https://lierabbit.cn/tags/NodeJs/"}]},{"title":"SpringBoot快速入门1-HelloSpringBoot","slug":"SpringBoot快速入门1-HelloSpringBoot","date":"2018-01-12T09:07:21.000Z","updated":"2018-08-29T14:10:30.356Z","comments":true,"path":"2018/01/12/SpringBoot快速入门1-HelloSpringBoot/","link":"","permalink":"https://lierabbit.cn/2018/01/12/SpringBoot快速入门1-HelloSpringBoot/","excerpt":"一、准备工作java环境：jdk 1.8开发工具：idea 二、创建项目打开idea 点击Create New Project","text":"一、准备工作java环境：jdk 1.8开发工具：idea 二、创建项目打开idea 点击Create New Project 选择Spring Initializr，Next Group.Artifact = 你的包名type：个人喜欢选择gradle，默认的maven也可以Next 选择webNext 选择工程目录Finish 如果目录不存在，Idea将帮你创建，点击ok就行 如果没有下载过gradle，默认选择就行，点ok如果想使用已存在的gradle选择Use local gradle distribution 等待右下角（红圈部分）下载完成 添加HelloCtrl类添加如下代码1234567891011121314import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;@Controller//这是一个控制器public class HelloCtrl&#123; @RequestMapping(\"/\")//将地址映射到 / 即访问http://localhost:8080 就可以进入这个方法 @ResponseBody//返回数据,如果不添加该注解将在resources/templates下寻找与之对应的html模版 public String hello() &#123; return \"hello spring boot\"; &#125;&#125; 三、运行 点击右上角启动如果没有启动可点点击HelloSpringBootApplication左边的启动箭头即可启动 启动成功控制的打印如下图所示内容 打开浏览器，http://localhost:8080 出现hello spring boot字样则成功源码地址：https://github.com/LieRabbit/hello-spring-boot","categories":[{"name":"SpringBoot快速入门","slug":"SpringBoot快速入门","permalink":"https://lierabbit.cn/categories/SpringBoot快速入门/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://lierabbit.cn/tags/SpringBoot/"}]}]}