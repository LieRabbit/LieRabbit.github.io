{"meta":{"title":"谎话兔博客","subtitle":"LieRabbit","description":"生命不息，奋斗不止","author":"谎话兔","url":"https://lierabbit.cn"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2018-08-20T12:11:23.000Z","updated":"2018-08-23T09:49:56.657Z","comments":false,"path":"/404.html","permalink":"https://lierabbit.cn//404.html","excerpt":"","text":""},{"title":"关于谎话兔","date":"2018-08-20T12:11:42.000Z","updated":"2018-08-22T09:26:10.692Z","comments":false,"path":"about/index.html","permalink":"https://lierabbit.cn/about/index.html","excerpt":"","text":"123456789101112131415161718192021222324252627&#123; name: &apos;谎话兔&apos; age: 23, gender: &apos;男&apos;, profession: &apos;业余开发者&apos;, experience: &apos;0年&apos;, address: &apos;广东省广州市&apos;, education: &apos;本科&apos;, github: &apos;https://github.com/LieRabbit&apos;, blog: &apos;http://lierabbit.cn&apos;, email: &apos;lierabbit@qq.com&apos;, description: &apos;走别人的路让别人无路可走&apos;, skills: [ [&apos;Java&apos;, &apos;Spring Cloud&apos;, &apos;Spring Boot&apos;, &apos;Spring&apos;] [&apos;Angular&apos;, &apos;TypeScript&apos;], [&apos;Html&apos;, &apos;JavaScript&apos;, &apos;JQuery&apos;, &apos;CSS&apos;, &apos;ES6&apos;, &apos;Node&apos;, &apos;Sass&apos;], [&apos;Python&apos;, &apos;Django&apos;] [&apos;Git&apos;, &apos;SVN&apos;] ], devTools: [ [&apos;Idea&apos;, &apos;WebStorm&apos;, &apos;PyCharm&apos;, &apos;Visual Studio Code&apos;], [&apos;Chrome DevTools&apos;], [&apos;Navicat&apos;], ]&#125;"},{"title":"书单","date":"2018-08-22T09:00:18.676Z","updated":"2018-08-22T09:00:18.676Z","comments":false,"path":"books/index.html","permalink":"https://lierabbit.cn/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2018-08-20T12:12:46.000Z","updated":"2018-08-20T12:32:32.265Z","comments":false,"path":"categories/index.html","permalink":"https://lierabbit.cn/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2018-08-20T12:12:13.000Z","updated":"2018-08-20T12:21:05.858Z","comments":true,"path":"links/index.html","permalink":"https://lierabbit.cn/links/index.html","excerpt":"","text":""},{"title":"项目","date":"2018-08-20T12:12:23.000Z","updated":"2018-08-20T12:29:34.573Z","comments":false,"path":"repository/index.html","permalink":"https://lierabbit.cn/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-08-18T09:59:10.592Z","updated":"2018-08-18T09:59:10.592Z","comments":false,"path":"tags/index.html","permalink":"https://lierabbit.cn/tags/index.html","excerpt":"","text":"啦啦啦"}],"posts":[{"title":"ArrayList实现原理","slug":"ArrayList实现原理","date":"2018-01-23T04:29:37.000Z","updated":"2018-08-23T11:45:28.275Z","comments":true,"path":"2018/01/23/ArrayList实现原理/","link":"","permalink":"https://lierabbit.cn/2018/01/23/ArrayList实现原理/","excerpt":"","text":"概述ArrayList可以简单的看作是动态数组，相对于普通的数组它可以动态的增加容量或者减少容量。要注意的是ArrayList并不是线程安全的，因此一般建议在单线程中使用ArrayList。 实现原理继承关系1public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable ArrayList继承AbstractList实现List, RandomAccess, Cloneable, java.io.Serializable接口 关键属性12345678910111213141516/** * The array buffer into which the elements of the ArrayList are stored. * The capacity of the ArrayList is the length of this array buffer. Any * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA * will be expanded to DEFAULT_CAPACITY when the first element is added. */// 数据的数组transient Object[] elementData; // non-private to simplify nested class access/** * The size of the ArrayList (the number of elements it contains). * * @serial */// 实际数据的数量private int size; 底层使用数组保存所有元素transient 如果用transient声明一个实例变量，当对象存储时，它的值不需要维持。换句话来说就是，用transient关键字标记的成员变量不参与序列化过程 构造方法123456789101112/** * Shared empty array instance used for default sized empty instances. We * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when * first element is added. */private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;/** * Constructs an empty list with an initial capacity of ten. */public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125; 默认情况下初始化空数组（长度为0的数组） 123456789101112131415161718192021/** * Shared empty array instance used for empty instances. */private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;/** * Constructs an empty list with the specified initial capacity. * * @param initialCapacity the initial capacity of the list * @throws IllegalArgumentException if the specified initial capacity * is negative */public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException(\"Illegal Capacity: \"+ initialCapacity); &#125;&#125; 指定数组的初始容量当指定的初始容量大于0，初始化指定大小的数组当指定的初始容量等于0，初始化空数组当指定的初始容量小于0，抛出IllegalArgumentException异常12345678910111213141516171819/** * Constructs a list containing the elements of the specified * collection, in the order they are returned by the collection's * iterator. * * @param c the collection whose elements are to be placed into this list * @throws NullPointerException if the specified collection is null */public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; &#125;&#125; 初始化指定集合的数组当指定集合不为空即长度不为0，则复制该集合，否则初始化一个空数组 E get(int index) 获取index位置的元素123456789101112131415161718192021222324252627282930313233343536373839404142// Positional Access Operations// 返回index下标的元素且强制转化为E（List&lt;E&gt;中的E）类型@SuppressWarnings(\"unchecked\")E elementData(int index) &#123; return (E) elementData[index];&#125;/** * Returns the element at the specified position in this list. * * @param index index of the element to return * @return the element at the specified position in this list * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */public E get(int index) &#123; // 检查index是否越界 rangeCheck(index); // 返回index下标的元素 return elementData(index);&#125;/** * Checks if the given index is in range. If not, throws an appropriate * runtime exception. This method does *not* check if the index is * negative: It is always used immediately prior to an array access, * which throws an ArrayIndexOutOfBoundsException if index is negative. */private void rangeCheck(int index) &#123; // 检查index是否大于等于size（数组的元素数量），因为数组下标从0开始计算，所以也不能等于元素数量 // 这里没有检查index &lt; 0的情况，因为index &lt; 0时数组会自动抛出异常，所以并未检查index&lt;0的情况 if (index &gt;= size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index));&#125;/** * Constructs an IndexOutOfBoundsException detail message. * Of the many possible refactorings of the error handling code, * this \"outlining\" performs best with both server and client VMs. */private String outOfBoundsMsg(int index) &#123; return \"Index: \"+index+\", Size: \"+size;&#125; 首先判断index是否越界，这里并没有判断是否小于0，因为下标小于0时数组会抛出异常。越界则抛出IndexOutOfBoundsException异常，反之返回数组对应index位置的元素 E set(int index, E element) 设置（覆盖）index位置的元素12345678910111213141516/** * Replaces the element at the specified position in this list with * the specified element. * * @param index index of the element to replace * @param element element to be stored at the specified position * @return the element previously at the specified position * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */public E set(int index, E element) &#123; rangeCheck(index); E oldValue = elementData(index); elementData[index] = element; return oldValue;&#125; 和get一样先判断index（下标）是否越界，不越界则先获取原来index位置上的元素，接着设置（覆盖）index位置上的元素，然后返回原来的元素，反之抛出IndexOutOfBoundsException异常 boolean add(E e) 添加一个元素到列表尾123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/** * Appends the specified element to the end of this list. * * @param e element to be appended to this list * @return &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;@link Collection#add&#125;) */public boolean add(E e) &#123; // 检查当前容量是否还可以容纳一个元素，不够则扩容 ensureCapacityInternal(size + 1); // Increments modCount!! // 添加到数组末尾 // 这个语句可以分解为 // elementData[size] = e; // size += 1; elementData[size++] = e; return true;&#125;/** * Default initial capacity. */private static final int DEFAULT_CAPACITY = 10; // 默认容量为10// 如果数据等于默认数据，返回默认容量和minCapacity（所需容量最小值）的最大值，反之返回所需容量最小值private static int calculateCapacity(Object[] elementData, int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; return Math.max(DEFAULT_CAPACITY, minCapacity); &#125; return minCapacity;&#125;private void ensureCapacityInternal(int minCapacity) &#123; ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));&#125;private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // 操作数+1 // overflow-conscious code // 如果所需容量最小值大于实际数组的长度就扩大实际数组容量 if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125;/** * The maximum size of array to allocate. * Some VMs reserve some header words in an array. * Attempts to allocate larger arrays may result in * OutOfMemoryError: Requested array size exceeds VM limit */private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; // 数组最大容量为Integer最大值-8/** * Increases the capacity to ensure that it can hold at least the * number of elements specified by the minimum capacity argument. * * @param minCapacity the desired minimum capacity */private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; // 新的容量为旧的容量的1.5倍 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); // 如果扩充容量后还是不够，则新的容量等于所需容量最小值（一般就是数组实际元素个数） if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; // 如果新的容量大于数组最大容量，再调用hugeCapacity计算新的容量 if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: // 复制原来的数据到新的数组，数组容量为新的容量 elementData = Arrays.copyOf(elementData, newCapacity);&#125;private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); // 大于数组最大容量返回Integer最大值，反之返回数组最大容量 return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;&#125; 添加一个元素到列表尾，当列表容量不足时自动扩容（通常是扩容至原来的1.5倍），添加成功返回true void add(int index, E element) 在index处放置元素123456789101112131415161718192021222324252627282930/** * Inserts the specified element at the specified position in this * list. Shifts the element currently at that position (if any) and * any subsequent elements to the right (adds one to their indices). * * @param index index at which the specified element is to be inserted * @param element element to be inserted * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */public void add(int index, E element) &#123; // 检查下标是否越界 rangeCheckForAdd(index); // 检查当前容量是否还可以在容纳一个元素，不够则扩容 ensureCapacityInternal(size + 1); // Increments modCount!! // 将elementData从index开始后面的元素往后移一位 System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++;&#125;/** * A version of rangeCheck used by add and addAll. */private void rangeCheckForAdd(int index) &#123; // 当index等于size时相当于添加元素到列表尾 if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException(outOfBoundsMsg(index));&#125; 将elementData数组从index开始后面的元素往后移一位，接着在index处放置元素模拟添加数据(lierabbit)到index=4过程如下1 初始数组 0 1 2 3 4 5 6 7 8 9 a b c d e f g h i j 2 从index开始后面的元素往后移一位 0 1 2 3 4 5 6 7 8 9 a b c d e e f g h i 3 在index处放置lierabbit 0 1 2 3 4 5 6 7 8 9 a b c d lierabbit e f g h i boolean addAll(Collection&lt;? extends E&gt; c) 添加一个集合里的所有元素到列表尾123456789101112131415161718192021222324/** * Appends all of the elements in the specified collection to the end of * this list, in the order that they are returned by the * specified collection's Iterator. The behavior of this operation is * undefined if the specified collection is modified while the operation * is in progress. (This implies that the behavior of this call is * undefined if the specified collection is this list, and this * list is nonempty.) * * @param c collection containing elements to be added to this list * @return &lt;tt&gt;true&lt;/tt&gt; if this list changed as a result of the call * @throws NullPointerException if the specified collection is null */public boolean addAll(Collection&lt;? extends E&gt; c) &#123; Object[] a = c.toArray(); int numNew = a.length; // 检查当前容量是否还可以在容纳a数组的元素，不够则扩容 ensureCapacityInternal(size + numNew); // Increments modCount // 将a数组里的元素添加到elementData末尾 System.arraycopy(a, 0, elementData, size, numNew); size += numNew; // a数组不为空（长度不为0）时返回true，反之false return numNew != 0;&#125; 将要添加的集合变为数组，然后将其复制到elementData数组末尾 boolean addAll(int index, Collection&lt;? extends E&gt; c) 添加一个集合里的所有元素到index位置123456789101112131415161718192021222324252627282930313233343536/** * Inserts all of the elements in the specified collection into this * list, starting at the specified position. Shifts the element * currently at that position (if any) and any subsequent elements to * the right (increases their indices). The new elements will appear * in the list in the order that they are returned by the * specified collection's iterator. * * @param index index at which to insert the first element from the * specified collection * @param c collection containing elements to be added to this list * @return &lt;tt&gt;true&lt;/tt&gt; if this list changed as a result of the call * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; * @throws NullPointerException if the specified collection is null */public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; // 检查下标是否越界 rangeCheckForAdd(index); Object[] a = c.toArray(); int numNew = a.length; // 检查当前容量是否还可以在容纳a数组的元素，不够则扩容 ensureCapacityInternal(size + numNew); // Increments modCount // 需要往后移动几个位置 int numMoved = size - index; if (numMoved &gt; 0) // 从index开始，往后的元素向后移动numMoved个位置 System.arraycopy(elementData, index, elementData, index + numNew, numMoved); // 将a数组里的所有元素复制到elementData从index到index + numNew -1的位置上 System.arraycopy(a, 0, elementData, index, numNew); size += numNew; // a数组不为空（长度不为0）时返回true，反之false return numNew != 0;&#125; 将要添加的集合变为数组，然后把elementData数组从index开始，往后的元素向后移动numMoved个位置，接着将要添加的数组里的所有元素复制到elementData从index到index + numNew -1的位置上 void trimToSize() 改变列表内部数组容量至列表实际元素数量123456789101112131415/** * Trims the capacity of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance to be the * list's current size. An application can use this operation to minimize * the storage of an &lt;tt&gt;ArrayList&lt;/tt&gt; instance. */public void trimToSize() &#123; modCount++; // 操作数+1 // 如果数组实际元素数量小于数组长度 if (size &lt; elementData.length) &#123; // 如果数组实际元素数量等于0则数组被赋值为空数组，反之创建一个新的元素数量等于数组长度的数组 elementData = (size == 0) ? EMPTY_ELEMENTDATA : Arrays.copyOf(elementData, size); &#125;&#125; 当数据稳定了之后可以使用这个方法来减少内存的使用 int indexOf(Object o) 查找o元素在列表第一次出现的位置123456789101112131415161718192021/** * Returns the index of the first occurrence of the specified element * in this list, or -1 if this list does not contain the element. * More formally, returns the lowest index &lt;tt&gt;i&lt;/tt&gt; such that * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt;, * or -1 if there is no such index. */public int indexOf(Object o) &#123; //元素可以为null，如果为null返回null的下标 if (o == null) &#123; for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; &#125; else &#123; for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; &#125; // 没有找到对应的元素返回-1 return -1;&#125; ArrayList中可以存放null元素，indexof是返回elementData数组中值相同的首个元素的下标，indexof中比较方法是equals而equals是比较元素的值，因此必须对null单独查找。如果未找到该元素则返回-1 E remove(int index) 删除index位置上的元素1234567891011121314151617181920212223242526/** * Removes the element at the specified position in this list. * Shifts any subsequent elements to the left (subtracts one from their * indices). * * @param index the index of the element to be removed * @return the element that was removed from the list * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */public E remove(int index) &#123; // 检查下标是否越界 rangeCheck(index); modCount++; // 操作数+1 E oldValue = elementData(index); // 获取index位置上的元素 int numMoved = size - index - 1; // 需要往前移动几个位置 if (numMoved &gt; 0) // 从index + 1开始，往后的元素向前移动1个位置 System.arraycopy(elementData, index+1, elementData, index, numMoved); // 将数组末尾元素置空 elementData[--size] = null; // clear to let GC do its work return oldValue;&#125; 模拟删除index=4（值为lierabbit）过程如下1 初始数组 0 1 2 3 4 5 6 7 8 9 a b c d lierabbit f g h i j 2 从index + 1（即index=5，值为f）开始，往后的元素向前移动1个位置 0 1 2 3 4 5 6 7 8 9 a b c d f g h i j j 3 将数组末尾元素置空 0 1 2 3 4 5 6 7 8 9 a b c d f g h i j null boolean remove(Object o) 删除o元素123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * Removes the first occurrence of the specified element from this list, * if it is present. If the list does not contain the element, it is * unchanged. More formally, removes the element with the lowest index * &lt;tt&gt;i&lt;/tt&gt; such that * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt; * (if such an element exists). Returns &lt;tt&gt;true&lt;/tt&gt; if this list * contained the specified element (or equivalently, if this list * changed as a result of the call). * * @param o element to be removed from this list, if present * @return &lt;tt&gt;true&lt;/tt&gt; if this list contained the specified element */public boolean remove(Object o) &#123; // 元素可以为null，分开搜索o if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; // 没有找到返回false return false;&#125;/* * Private remove method that skips bounds checking and does not * return the value removed. */// 由于已经找到元素，则元素必定存在，则index必定合理，所以不需要在检查index是否越界private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work&#125; 通过寻找o元素，可以获得其下标，再根据下标删除o元素 forEach(Consumer&lt;? super E&gt; action)遍历列表12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * The number of times this list has been &lt;i&gt;structurally modified&lt;/i&gt;. * Structural modifications are those that change the size of the * list, or otherwise perturb it in such a fashion that iterations in * progress may yield incorrect results. * * &lt;p&gt;This field is used by the iterator and list iterator implementation * returned by the &#123;@code iterator&#125; and &#123;@code listIterator&#125; methods. * If the value of this field changes unexpectedly, the iterator (or list * iterator) will throw a &#123;@code ConcurrentModificationException&#125; in * response to the &#123;@code next&#125;, &#123;@code remove&#125;, &#123;@code previous&#125;, * &#123;@code set&#125; or &#123;@code add&#125; operations. This provides * &lt;i&gt;fail-fast&lt;/i&gt; behavior, rather than non-deterministic behavior in * the face of concurrent modification during iteration. * * &lt;p&gt;&lt;b&gt;Use of this field by subclasses is optional.&lt;/b&gt; If a subclass * wishes to provide fail-fast iterators (and list iterators), then it * merely has to increment this field in its &#123;@code add(int, E)&#125; and * &#123;@code remove(int)&#125; methods (and any other methods that it overrides * that result in structural modifications to the list). A single call to * &#123;@code add(int, E)&#125; or &#123;@code remove(int)&#125; must add no more than * one to this field, or the iterators (and list iterators) will throw * bogus &#123;@code ConcurrentModificationExceptions&#125;. If an implementation * does not wish to provide fail-fast iterators, this field may be * ignored. */protected transient int modCount = 0;//操作数@Overridepublic void forEach(Consumer&lt;? super E&gt; action) &#123; // 确保不为空 Objects.requireNonNull(action); final int expectedModCount = modCount; @SuppressWarnings(\"unchecked\") final E[] elementData = (E[]) this.elementData; final int size = this.size; for (int i=0; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123; action.accept(elementData[i]); &#125; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125;&#125;/** * Checks that the specified object reference is not &#123;@code null&#125;. This * method is designed primarily for doing parameter validation in methods * and constructors, as demonstrated below: * &lt;blockquote&gt;&lt;pre&gt; * public Foo(Bar bar) &#123; * this.bar = Objects.requireNonNull(bar); * &#125; * &lt;/pre&gt;&lt;/blockquote&gt; * * @param obj the object reference to check for nullity * @param &lt;T&gt; the type of the reference * @return &#123;@code obj&#125; if not &#123;@code null&#125; * @throws NullPointerException if &#123;@code obj&#125; is &#123;@code null&#125; */public static &lt;T&gt; T requireNonNull(T obj) &#123; if (obj == null) throw new NullPointerException(); return obj;&#125; 这里可以看到modCount的用处，当modCount发生改变后，立刻抛出ConcurrentModificationException异常。通过之前的分析可以知道当列表内容被修改时modCount会增加。也就是说如果在遍历ArrayList的过程中有其他线程修改了ArrayList，那么将抛出ConcurrentModificationException异常 ArrayList小结 ArrayList是List接口的一个可变大小的数组的实现 ArrayList的内部是使用一个Object对象数组来存储元素的 初始化ArrayList的时候，可以指定初始化容量的大小，如果不指定，就会使用默认大小，为10 当添加一个新元素的时候，首先会检查容量是否足够添加这个元素，如果够就直接添加，如果不够就进行扩容，扩容为原数组容量的1.5倍 当在index处放置一个元素的时候，会将数组index处右边的元素全部右移 当在index处删除一个元素的时候，会将数组index处右边的元素全部左移","categories":[{"name":"Java从深入到放弃","slug":"Java从深入到放弃","permalink":"https://lierabbit.cn/categories/Java从深入到放弃/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://lierabbit.cn/tags/Java/"}]},{"title":"SpringBoot快速入门6-thymeleaf","slug":"SpringBoot快速入门6-thymeleaf","date":"2018-01-21T13:48:52.000Z","updated":"2018-08-23T13:42:57.927Z","comments":true,"path":"2018/01/21/SpringBoot快速入门6-thymeleaf/","link":"","permalink":"https://lierabbit.cn/2018/01/21/SpringBoot快速入门6-thymeleaf/","excerpt":"","text":"静态资源在我们开发Web应用的时候，需要引用大量的js、css、图片等静态资源。Spring Boot的默认位置是resources/static 模版页面各种模版的页面，这次我们选用ThymeleafSpring Boot的默认位置是resources/templates 渲染页面在之前的示例中，我们都是通过@RestController来处理请求，所以返回的内容为json对象。当我们需要页面的时候使用@Controller，使其寻找模版页面 添加依赖对于已存在的项目可以在bulid.gradle加入12compile(&apos;org.springframework.boot:spring-boot-starter-thymeleaf&apos;)compile(&apos;org.springframework.boot:spring-boot-starter-web&apos;) 至此Thymeleaf已经引入 创建控制器新建一个ThymeleafCtrl类1234567891011121314import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;@Controller//这是一个控制器public class ThymeleafCtrl&#123; @RequestMapping(\"/\") public String hello(Model model) &#123; model.addAttribute(\"hello\",\"hello thymeleaf\");//添加一个值为\"hello thymeleaf\"的hello变量到视图 return \"hello\";//在templates下寻找hello.html &#125;&#125; 创建模版页面在resources/templates创建一个hello.html页面1234567891011&lt;!DOCTYPE html&gt;&lt;html xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;!-- xmlns:th=\"http://www.thymeleaf.org\" 减少ide报错，可以没有 --&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"/&gt; &lt;title&gt;Hello&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 th:text=\"$&#123;hello&#125;\"&gt;LieRabbit&lt;/h1&gt;&lt;!-- 使用hello变量 --&gt;&lt;img src=\"lierabbit.jpg\"/&gt;&lt;/body&gt;&lt;/html&gt; 添加图片资源在resources/static添加lierabbit.jpg 运行结果更多的Thymeleaf的语法请前往官网查看文档（http://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html）源码地址：https://github.com/LieRabbit/SpringBoot-thymeleaf","categories":[{"name":"Spring Boot快速入门","slug":"Spring-Boot快速入门","permalink":"https://lierabbit.cn/categories/Spring-Boot快速入门/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://lierabbit.cn/tags/Spring-Boot/"}]},{"title":"SpringBoot快速入门5-使用MyBatis（注解形式）进行数据库操作","slug":"SpringBoot快速入门5-使用MyBatis（注解形式）进行数据库操作","date":"2018-01-17T01:31:07.000Z","updated":"2018-08-23T13:35:33.566Z","comments":true,"path":"2018/01/17/SpringBoot快速入门5-使用MyBatis（注解形式）进行数据库操作/","link":"","permalink":"https://lierabbit.cn/2018/01/17/SpringBoot快速入门5-使用MyBatis（注解形式）进行数据库操作/","excerpt":"","text":"添加依赖新建项目选择web,MyBatis,MySQL三个依赖 对于已存在的项目可以在bulid.gradle加入，spring boot将会帮你自动配置好1234compile(&apos;org.springframework.boot:spring-boot-starter-data-jpa&apos;)compile(&apos;org.springframework.boot:spring-boot-starter-web&apos;)runtime(&apos;mysql:mysql-connector-java&apos;)testCompile(&apos;org.springframework.boot:spring-boot-starter-test&apos;) 配置基本信息然后在src/main/resources/application.properties下添加基本配置12345678#数据库连接地址spring.datasource.url=jdbc:mysql://localhost:3306/mybaits?useSSL=false#数据库账号spring.datasource.username=root#数据库密码spring.datasource.password=123456zxc#数据库驱动spring.datasource.driver-class-name=com.mysql.jdbc.Driver 创建实体创建一个User实体，包含id、name（姓名）、age（年龄）属性12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class User&#123; private Long id; private String name; private Integer age; public User() &#123; &#125; public User(String name, Integer age) &#123; this.name = name; this.age = age; &#125; public Long getId() &#123; return id; &#125; public void setId(Long id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125;&#125; 创建数据访问接口创建一个userMapper接口，进行数据库操作，添加@Mapper注解12345678910111213141516171819202122232425import org.apache.ibatis.annotations.*;import java.util.List;@Mapper//这是一个MyBatis的数据库操作接口public interface UserMapper&#123; @Select(\"SELECT * FROM user WHERE name = #&#123;name&#125;\") User findByName(@Param(\"name\") String name); @Select(\"SELECT * FROM user WHERE name LIKE #&#123;name&#125;\") List&lt;User&gt; findByNameLike(@Param(\"name\") String name); @Insert(\"INSERT INTO user(name, age) VALUES(#&#123;name&#125;, #&#123;age&#125;)\") int insert(@Param(\"name\") String name, @Param(\"age\") Integer age); @Update(\"UPDATE user SET age = #&#123;age&#125; WHERE name = #&#123;name&#125;\") int update(@Param(\"name\") String name, @Param(\"age\") Integer age); @Delete(\"DELETE FROM user WHERE name = #&#123;name&#125;\") int delete(@Param(\"name\") String name); @Select(\"SELECT COUNT(*) FROM user\") int countAll();&#125; 单元测试在src/test/java/你的包名/你的项目名ApplicationTests编写对应的单元测试来验证编写的内容是否正确12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import org.junit.Assert;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.annotation.Rollback;import org.springframework.test.context.junit4.SpringRunner;import org.springframework.transaction.annotation.Transactional;@RunWith(SpringRunner.class)@SpringBootTest@Transactional//声明事务，配合Rollbackpublic class MybatisApplicationTests&#123; @Autowired private UserMapper userMapper; @Test @Rollback//测试结束回滚数据，保证测试单元每次运行的数据环境独立 public void testUser() &#123; userMapper.insert(\"QQQ\",1); userMapper.insert(\"WWW\",2); userMapper.insert(\"EEE\",3); userMapper.insert(\"AAA\",4); userMapper.insert(\"SSS\",5); userMapper.insert(\"DDD\",6); userMapper.insert(\"ZZZ\",7); userMapper.insert(\"XXX\",8); userMapper.insert(\"CCC\",9); userMapper.insert(\"SSS213\",10); // 测试findAll, 查询所有记录 Assert.assertEquals(10, userMapper.countAll()); // 测试findByName, 查询姓名为AAA的User Assert.assertEquals(4, userMapper.findByName(\"AAA\").getAge().longValue()); // 更新CCC用户的年龄为15 userMapper.update(\"CCC\",15); // 测试findByName, 查询姓名为CCC的User的年龄是否为15 Assert.assertEquals(15, userMapper.findByName(\"CCC\").getAge().longValue()); // 测试删除姓名为AAA的User userMapper.delete(\"AAA\"); // 测试findAll, 查询所有记录, 验证上面的删除是否成功 Assert.assertEquals(9, userMapper.countAll()); // 测试findAll, 查询名字有S的有几个 Assert.assertEquals(2,userMapper.findByNameLike(\"%S%\").size()); &#125;&#125; 测试结果 源码地址：https://github.com/LieRabbit/SpringBoot-mybatis","categories":[{"name":"Spring Boot快速入门","slug":"Spring-Boot快速入门","permalink":"https://lierabbit.cn/categories/Spring-Boot快速入门/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://lierabbit.cn/tags/Spring-Boot/"}]},{"title":"SpringBoot快速入门4-使用jpa进行数据库操作","slug":"SpringBoot快速入门4-使用jpa进行数据库操作","date":"2018-01-15T15:49:41.000Z","updated":"2018-08-23T13:34:32.648Z","comments":true,"path":"2018/01/15/SpringBoot快速入门4-使用jpa进行数据库操作/","link":"","permalink":"https://lierabbit.cn/2018/01/15/SpringBoot快速入门4-使用jpa进行数据库操作/","excerpt":"","text":"添加依赖新建项目选择web,JPA,MySQL三个依赖 对于已存在的项目可以在bulid.gradle加入，spring boot将会帮你自动配置好 123compile(&apos;org.springframework.boot:spring-boot-starter-data-jpa&apos;)compile(&apos;org.springframework.boot:spring-boot-starter-web&apos;)runtime(&apos;mysql:mysql-connector-java&apos;) 配置基本信息然后在src/main/resources/application.properties下添加基本配置123456789101112#数据库连接地址spring.datasource.url=jdbc:mysql://localhost:3306/jpa?useSSL=false#数据库账号spring.datasource.username=root#数据库密码spring.datasource.password=123456zxc#数据库驱动spring.datasource.driver-class-name=com.mysql.jdbc.Driver#jpa设置spring.jpa.hibernate.ddl-auto=create#是否在控制台显示数据库语句spring.jpa.show-sql=true spring.jpa.properties.hibernate.hbm2ddl.auto 其作用是：自动创建、更新、验证数据库表结构。该参数的几种配置如下： create：每次加载hibernate时都会删除上一次的生成的表，然后根据你的model类再重新来生成新表，哪怕两次没有任何改变也要这样执行，这就是导致数据库表数据丢失的一个重要原因。 create-drop：每次加载hibernate时根据model类生成表，但是sessionFactory一关闭,表就自动删除。 update：最常用的属性，第一次加载hibernate时根据model类会自动建立起表的结构（前提是先建立好数据库），以后加载hibernate时根据model类自动更新表结构，即使表结构改变了但表中的行仍然存在不会删除以前的行。要注意的是当部署到服务器后，表结构是不会被马上建立起来的，是要等应用第一次运行起来后才会。 validate：每次加载hibernate时，验证创建数据库表结构，只会和数据库中的表进行比较，不会创建新表，但是会插入新值。 none：什么都不做至此基本配置完成 创建实体创建一个User实体，包含id（主键）、name（姓名）、age（年龄）属性，通过ORM框架其会被映射到数据库表中，由于配置了hibernate.hbm2ddl.auto，在应用启动的时候框架会自动去数据库中创建对应的表。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import javax.persistence.Column;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.Id;@Entity//这是一个和数据库表相关联的类public class User&#123; @Id//主键 @GeneratedValue//自增长 private Long id;//id @Column(length = 30)//长度30 private String name;//名称 @Column(nullable = false)//不可空 private Integer age;//年龄 public User() &#123; &#125; public User(String name, Integer age) &#123; this.name = name; this.age = age; &#125; public Long getId() &#123; return id; &#125; public void setId(Long id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125;&#125; 创建数据访问接口创建一个userRepository接口，进行数据库操作 12345678910111213141516171819202122232425import org.springframework.data.jpa.repository.JpaRepository;import org.springframework.data.jpa.repository.Query;import org.springframework.data.repository.query.Param;import java.util.List;public interface UserRepository extends JpaRepository&lt;User, Long&gt;//JpaRepository&lt;实体类型，主键类型&gt;&#123; // 通过名称找到用户 User findByName(String name); // 通过名称和年龄找到用户 User findByNameAndAge(String name, Integer age); // 通过名称模糊查询 List&lt;User&gt; findByNameLike(String name); // 使用hql查询 @Query(\"from User u where u.name=:name\")//:name对应@Param里的name User findByHQL(@Param(\"name\") String name); // 使用sql查询 @Query(value = \"select * from user where name = ?1 and age = ?2\", nativeQuery = true)//?1表示第一个参数，?2表示第二个参数 User findBySQL(String name, Integer age);&#125; 单元测试在src/test/java/你的包名/你的项目名ApplicationTests编写对应的单元测试来验证编写的内容是否正确 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import org.junit.Assert;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;@RunWith(SpringRunner.class)@SpringBootTestpublic class JpaLearnApplicationTests&#123; // 注入userRepository @Autowired private UserRepository userRepository; @Test public void contextLoads() &#123; // 添加10个测试用例 userRepository.save(new User(\"QQQ\",1)); userRepository.save(new User(\"WWW\",2)); userRepository.save(new User(\"EEE\",3)); userRepository.save(new User(\"AAA\",4)); userRepository.save(new User(\"SSS\",5)); userRepository.save(new User(\"DDD\",6)); userRepository.save(new User(\"ZZZ\",7)); userRepository.save(new User(\"XXX\",8)); userRepository.save(new User(\"CCC\",9)); userRepository.save(new User(\"QQQ2\",10)); // 测试findAll, 查询所有记录 Assert.assertEquals(10, userRepository.findAll().size()); // 测试findByName, 查询姓名为AAA的User Assert.assertEquals(4, userRepository.findByName(\"AAA\").getAge().longValue()); // 测试findByHQL, 查询姓名为AAA的User Assert.assertEquals(4, userRepository.findByHQL(\"AAA\").getAge().longValue()); // 测试findByNameAndAge, 查询姓名为SSS并且年龄为5的User Assert.assertEquals(\"SSS\", userRepository.findByNameAndAge(\"SSS\", 5).getName()); // 测试findBySQL, 查询姓名为SSS并且年龄为5的User Assert.assertEquals(\"SSS\", userRepository.findBySQL(\"SSS\", 5).getName()); // 测试删除姓名为AAA的User userRepository.delete(userRepository.findByName(\"AAA\")); // 测试findAll, 查询所有记录, 验证上面的删除是否成功 Assert.assertEquals(9, userRepository.findAll().size()); // 测试findAll, 查询名字有Q的有几个 Assert.assertEquals(2,userRepository.findByNameLike(\"%Q%\").size()); &#125;&#125; 点击运行测试用例 源码地址：https://github.com/LieRabbit/SpringBoot-jpa-learn","categories":[{"name":"Spring Boot快速入门","slug":"Spring-Boot快速入门","permalink":"https://lierabbit.cn/categories/Spring-Boot快速入门/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://lierabbit.cn/tags/Spring-Boot/"}]},{"title":"SpringBoot快速入门3-依赖注入","slug":"SpringBoot快速入门3-依赖注入","date":"2018-01-15T14:48:05.000Z","updated":"2018-08-23T13:33:44.285Z","comments":true,"path":"2018/01/15/SpringBoot快速入门3-依赖注入/","link":"","permalink":"https://lierabbit.cn/2018/01/15/SpringBoot快速入门3-依赖注入/","excerpt":"","text":"spring boot使用依赖注入的方式很简单，只需要给添加相应的注解即可 @Service用于标注业务层组件 @Controller用于标注控制层组件 @Repository用于标注数据访问组件，即DAO组件 @Component泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。然后在使用的地方使用@Autowired即可 创建MyComponent，使用@Component12345678910import org.springframework.stereotype.Component;@Component//泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。public class MyComponent&#123; public void hi(String name) &#123; System.out.println(\"hi \" + name + \",I am MyComponent\"); &#125;&#125; 创建MyController，使用@Controller12345678910import org.springframework.stereotype.Controller;@Controller//用于标注控制层组件public class MyController&#123; public void hi(String name) &#123; System.out.println(\"hi \" + name + \",I am MyController\"); &#125;&#125; 创建MyRepository，使用@Repository12345678@Repository//用于标注数据访问组件，即DAO组件public class MyRepository&#123; public void hi(String name) &#123; System.out.println(\"hi \" + name + \",I am MyRepository\"); &#125;&#125; 创建MyService，MyServiceImpl，使用@Service1234public interface MyService&#123; void doSomeThing();&#125; 123456789101112import org.springframework.stereotype.Service;@Service//用于标注业务层组件public class MyServiceImpl implements MyService&#123; @Override public void doSomeThing() &#123; System.out.println(\"i am MyServiceImpl\"); &#125;&#125; 单元测试在src/test/java/你的包名/你的项目名ApplicationTests编写对应的单元测试来验证是否可以成功注入 1234567891011121314151617181920212223242526272829import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;@RunWith(SpringRunner.class)@SpringBootTestpublic class DiApplicationTests&#123; @Autowired//自动注入 private MyController myController; @Autowired//自动注入 private MyRepository myRepository; @Autowired//自动注入 private MyComponent myComponent; @Autowired//自动注入实现了该接口的bean private MyService myService; @Test public void contextLoads() &#123; myController.hi(\"lierabbit\"); myRepository.hi(\"lierabbit\"); myComponent.hi(\"lierabbit\"); myService.doSomeThing(); &#125;&#125; 运行测试用例显示红圈的4句话证明成功注入 源码地址：https://github.com/LieRabbit/SpringBoot-DI","categories":[{"name":"Spring Boot快速入门","slug":"Spring-Boot快速入门","permalink":"https://lierabbit.cn/categories/Spring-Boot快速入门/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://lierabbit.cn/tags/Spring-Boot/"}]},{"title":"SpringBoot快速入门2-Http请求","slug":"SpringBoot快速入门2-Http请求","date":"2018-01-14T12:05:08.000Z","updated":"2018-08-23T13:32:36.598Z","comments":true,"path":"2018/01/14/SpringBoot快速入门2-Http请求/","link":"","permalink":"https://lierabbit.cn/2018/01/14/SpringBoot快速入门2-Http请求/","excerpt":"","text":"准备postman：一个接口测试工具创建一个新工程 选择web不会的请看Spring Boot快速入门（一）：Hello Spring Boot 开始新建java类RequestCtrl 添加一个all方法，使用@RequestMapping注解，可以处理所有的http请求 123456789@RestController//这是一个控制器并只返回数据不寻找视图public class RequestCtrl&#123; @RequestMapping(\"/\")//将本方法映射到/ public String all(String name, Integer age)//接受2个参数,name和age &#123; return \"这里是all\\n\" + \"name: \" + name + \"\\n\" + \"age: \" + age; &#125;&#125; requestMapping的作用可以简单理解为给方法加个地址，让别人能访问 通过源码可以看出@RestController是@Controller和ResponseBody的结合注解@Controller 表明这是一个控制器，将会返回数据或者页面@ResponseBody 表明只会返回数据，Spring Boot默认将数据使用jaskson序列化为json返回JSON(JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式，常见表现形式为键值对{key:value}，例如{name:”lierabbit”,age:20}，字符串和数字直接返回启动程序，打开postman对http://localhost:8080发起get请求 发起带参数的请求 使用post请求 添加一个get方法，使用@GetMapping注解，只可以处理get类型的http请求12345@GetMapping(\"/get\")//将本方法映射到/get，且只能用get方式访问public String get(String name, int age)//接受2个参数,name和age&#123; return \"这里是get\\n\" + \"name: \" + name + \"\\n\" + \"age: \" + age;&#125; 使用get方式访问http://localhost:8080/get?name=lierabbit&amp;age=20 尝试使用post访问，将得到405异常 添加一个post方法，使用@PostMapping注解，只可以处理post类型的http请求12345@PostMapping(\"/post\")//将本方法映射到/post，且只能用post方式访问public String post(String name, int age)//接受2个参数,name和age&#123; return \"这里是post\\n\" + \"name: \" + name + \"\\n\" + \"age: \" + age;&#125; 使用post方式访问 尝试使用get访问，得到405异常 添加一个put方法，使用@PutMapping注解，只可以处理put类型的http请求12345678@PutMapping(\"/put\")//将本方法映射到/put，且只能用put方式访问public User put(@RequestBody User user)//接受一个user实体&#123; user.setName(\"名字已经被修改：\" + user.getName()); user.setAge(user.getAge() + 1); return user;&#125;@RequestBody 表示接受一个user实体（user json） 返回User，会被spring boot自动序列化为json 添加一个delete方法，使用@DeleteMapping注解，只可以处理delete类型的http请求1234567@DeleteMapping(\"/delete\")//将本方法映射到/delete，且只能用delete方式访问public User delete(@RequestBody User user)//接受一个user实体&#123; user.setName(\"这个用户将会被删除：\" + user.getName()); user.setAge(user.getAge() + 1); return user;&#125; 添加一个patch方法，使用@PatchMapping注解，只可以处理patch类型的http请求123456@PatchMapping(\"/patch\")//将本方法映射到/patch，且只能用patch方式访问public User pathch(@RequestBody User user)//接受一个user实体&#123; user.setName(\"只改名称：\" + user.getName()); return user;&#125; 源码地址：https://github.com/LieRabbit/SpringBoot-request","categories":[{"name":"Spring Boot快速入门","slug":"Spring-Boot快速入门","permalink":"https://lierabbit.cn/categories/Spring-Boot快速入门/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://lierabbit.cn/tags/Spring-Boot/"}]},{"title":"升级node与npm","slug":"升级node与npm","date":"2018-01-14T09:48:54.000Z","updated":"2018-08-23T14:06:46.208Z","comments":true,"path":"2018/01/14/升级node与npm/","link":"","permalink":"https://lierabbit.cn/2018/01/14/升级node与npm/","excerpt":"","text":"升级node一、安装 n 工具，这个工具的名称很短，方便输入npm install -g n 二、升级node至长期版或者最新版上图为node中文官网的截图123n lts //升级到LTS版本，即上图的8.9.4n stable //升级到最新稳定版，即上图的9.4.0 三、n工具其它的一些命令123456789101112n 输出已安装的node版本n latest 安装最新的node版本n stable 安装最新稳定的node版本n lts 安装最新LTS的node版本n &lt;version&gt; 安装指定的node版本n bin &lt;version&gt; 输出指定的node的位置n rm &lt;version ...&gt; 删除指定的node版本n prune 删除除了当前node版本之外的所有版本n --latest 输出最新的node版本n --stable 输出最新稳定的node版本n --lts 输出最新LTS的node版本n ls 输出所有node版本 升级npm1npm install -g npm 一句话解决","categories":[],"tags":[{"name":"node.js","slug":"node-js","permalink":"https://lierabbit.cn/tags/node-js/"}]},{"title":"SpringBoot快速入门1-HelloSpringBoot","slug":"SpringBoot快速入门1-HelloSpringBoot","date":"2018-01-12T09:07:21.000Z","updated":"2018-08-23T13:30:48.533Z","comments":true,"path":"2018/01/12/SpringBoot快速入门1-HelloSpringBoot/","link":"","permalink":"https://lierabbit.cn/2018/01/12/SpringBoot快速入门1-HelloSpringBoot/","excerpt":"","text":"一、准备工作java环境：jdk 1.8开发工具：idea 二、创建项目打开idea 点击Create New Project 选择Spring Initializr，Next Group.Artifact = 你的包名type：个人喜欢选择gradle，默认的maven也可以Next 选择webNext 选择工程目录Finish 如果目录不存在，Idea将帮你创建，点击ok就行 如果没有下载过gradle，默认选择就行，点ok如果想使用已存在的gradle选择Use local gradle distribution 等待右下角（红圈部分）下载完成 添加HelloCtrl类添加如下代码1234567891011121314import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;@Controller//这是一个控制器public class HelloCtrl&#123; @RequestMapping(\"/\")//将地址映射到 / 即访问http://localhost:8080 就可以进入这个方法 @ResponseBody//返回数据,如果不添加该注解将在resources/templates下寻找与之对应的html模版 public String hello() &#123; return \"hello spring boot\"; &#125;&#125; 三、运行 点击右上角启动如果没有启动可点点击HelloSpringBootApplication左边的启动箭头即可启动 启动成功控制的打印如下图所示内容 打开浏览器，http://localhost:8080 出现hello spring boot字样则成功源码地址：https://github.com/LieRabbit/hello-spring-boot","categories":[{"name":"Spring Boot快速入门","slug":"Spring-Boot快速入门","permalink":"https://lierabbit.cn/categories/Spring-Boot快速入门/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://lierabbit.cn/tags/Spring-Boot/"}]}]}