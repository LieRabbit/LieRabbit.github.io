{"meta":{"title":"谎话兔博客","subtitle":"LieRabbit","description":"生命不息，奋斗不止","author":"谎话兔","url":"https://lierabbit.cn"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2018-08-20T12:11:23.000Z","updated":"2018-08-23T09:49:56.657Z","comments":false,"path":"/404.html","permalink":"https://lierabbit.cn//404.html","excerpt":"","text":""},{"title":"关于谎话兔","date":"2018-08-20T12:11:42.000Z","updated":"2018-08-22T09:26:10.692Z","comments":false,"path":"about/index.html","permalink":"https://lierabbit.cn/about/index.html","excerpt":"","text":"123456789101112131415161718192021222324252627&#123; name: &apos;谎话兔&apos; age: 23, gender: &apos;男&apos;, profession: &apos;业余开发者&apos;, experience: &apos;0年&apos;, address: &apos;广东省广州市&apos;, education: &apos;本科&apos;, github: &apos;https://github.com/LieRabbit&apos;, blog: &apos;http://lierabbit.cn&apos;, email: &apos;lierabbit@qq.com&apos;, description: &apos;走别人的路让别人无路可走&apos;, skills: [ [&apos;Java&apos;, &apos;Spring Cloud&apos;, &apos;Spring Boot&apos;, &apos;Spring&apos;] [&apos;Angular&apos;, &apos;TypeScript&apos;], [&apos;Html&apos;, &apos;JavaScript&apos;, &apos;JQuery&apos;, &apos;CSS&apos;, &apos;ES6&apos;, &apos;Node&apos;, &apos;Sass&apos;], [&apos;Python&apos;, &apos;Django&apos;] [&apos;Git&apos;, &apos;SVN&apos;] ], devTools: [ [&apos;Idea&apos;, &apos;WebStorm&apos;, &apos;PyCharm&apos;, &apos;Visual Studio Code&apos;], [&apos;Chrome DevTools&apos;], [&apos;Navicat&apos;], ]&#125;"},{"title":"分类","date":"2018-08-20T12:12:46.000Z","updated":"2018-08-20T12:32:32.265Z","comments":false,"path":"categories/index.html","permalink":"https://lierabbit.cn/categories/index.html","excerpt":"","text":""},{"title":"书单","date":"2018-08-22T09:00:18.676Z","updated":"2018-08-22T09:00:18.676Z","comments":false,"path":"books/index.html","permalink":"https://lierabbit.cn/books/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2018-08-20T12:12:13.000Z","updated":"2018-08-20T12:21:05.858Z","comments":true,"path":"links/index.html","permalink":"https://lierabbit.cn/links/index.html","excerpt":"","text":""},{"title":"项目","date":"2018-08-20T12:12:23.000Z","updated":"2018-08-20T12:29:34.573Z","comments":false,"path":"repository/index.html","permalink":"https://lierabbit.cn/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-08-18T09:59:10.592Z","updated":"2018-08-18T09:59:10.592Z","comments":false,"path":"tags/index.html","permalink":"https://lierabbit.cn/tags/index.html","excerpt":"","text":"啦啦啦"}],"posts":[{"title":"树上最远距离","slug":"树上最远距离","date":"2018-02-22T15:04:52.000Z","updated":"2018-08-24T14:30:34.072Z","comments":true,"path":"2018/02/22/树上最远距离/","link":"","permalink":"https://lierabbit.cn/2018/02/22/树上最远距离/","excerpt":"","text":"从二叉树的节点A出发，可以向上或者向下走，但沿途的节点只能经过一次，当到达节点B时，路径上的节点数叫作A到B的距离。对于给定的一棵二叉树，求整棵树上节点间的最大距离。给定一个二叉树的头结点root，请返回最大距离。保证点数大于等于2小于等于500. 思路：一个以h为头的树上,最大距离只可能来自以下三种情况:1.h的左子树上的最大距离2.h的右子树上的最大距离3.h左子树上离h左孩子最远的距离，加上h自身这个节点，再加h右子树上离h右孩子的最远距离，也就是两个节点分别来自h两侧子树的情况三个值中最大的那个就是以h为头的整棵树上最远的距离。 123456789101112131415161718192021public int findLongest(TreeNode root) &#123; int[] temp = new int[1]; return find(root, temp);&#125;public int find(TreeNode node, int[] temp) &#123; if (node == null) &#123; temp[0] = 0; return 0; &#125; int lMax = find(node.left, temp); int maxFormLeft = temp[0]; int rMax = find(node.right, temp); int maxFormRight = temp[0]; int cMax = maxFormLeft + maxFormRight + 1; temp[0] = Math.max(maxFormLeft, maxFormRight) + 1; return Math.max(Math.max(lMax, rMax), cMax);&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"寻找错误节点","slug":"寻找错误节点","date":"2018-02-22T15:01:03.000Z","updated":"2018-08-24T14:23:50.260Z","comments":true,"path":"2018/02/22/寻找错误节点/","link":"","permalink":"https://lierabbit.cn/2018/02/22/寻找错误节点/","excerpt":"","text":"一棵二叉树原本是搜索二叉树，但是其中有两个节点调换了位置，使得这棵二叉树不再是搜索二叉树，请找到这两个错误节点并返回他们的值。保证二叉树中结点的值各不相同。给定一棵树的根结点，请返回两个调换了位置的值，其中小的值在前。 思路： 对二叉树进行中序遍历，依次出现的节点值会一直升序，如果两个节点值错了，会出现降序。 如果在中序遍历时节点值出现了两次降序，第一个错误的节点为第一次降序时较大的节点，第二个错误的节点为第二次降序时较小的节点。 如果在中序遍历时节点值只出现了一次降序，第一个错误的节点为这次降序时较大的节点，第二个错误的节点为这次降序时较小的节点。 12345678910111213141516171819202122232425262728293031323334public int[] findError(TreeNode root) &#123; // write code here int[] result = new int[2]; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode cur = root; TreeNode preNode = null; // 上一个打印节点 TreeNode curNode; // 当前打印节点 int count = 0; while (cur != null || !stack.empty()) &#123; if (cur == null) &#123; curNode = stack.pop(); if (preNode != null) &#123; if (preNode.val &gt; curNode.val) &#123; count++; if (count == 1) &#123; result[0] = curNode.val; result[1] = preNode.val; &#125; else &#123; result[0] = curNode.val; &#125; &#125; &#125; preNode = curNode; cur = curNode.right; &#125; else &#123; stack.add(cur); cur = cur.left; &#125; &#125; return result;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"折纸","slug":"折纸","date":"2018-02-22T14:25:00.000Z","updated":"2018-08-24T14:21:18.670Z","comments":true,"path":"2018/02/22/折纸/","link":"","permalink":"https://lierabbit.cn/2018/02/22/折纸/","excerpt":"","text":"请把纸条竖着放在桌⼦上，然后从纸条的下边向上⽅对折，压出折痕后再展 开。此时有1条折痕，突起的⽅向指向纸条的背⾯，这条折痕叫做“下”折痕 ；突起的⽅向指向纸条正⾯的折痕叫做“上”折痕。如果每次都从下边向上⽅ 对折，对折N次。请从上到下计算出所有折痕的⽅向。给定折的次数n,请返回从上到下的折痕的数组，若为下折痕则对应元素为”down”,若为上折痕则为”up”.测试样例： 121返回：[&quot;down&quot;] 思路： 1234567891011121314151617181920212223242526272829public String[] foldPaper(int n) &#123; // write code here List&lt;String&gt; temp = new ArrayList&lt;&gt;(); fold(1, n, true, temp); int resultSize = temp.size(); String[] result = new String[resultSize]; resultSize--; while (resultSize &gt;= 0) &#123; result[resultSize] = temp.get(resultSize); resultSize--; &#125; return result;&#125;/** * 模拟右中左遍历 * @param level 层数 * @param high 高度 * @param down 是否是down * @param res 结果 */public void fold(int level, int high, boolean down, List&lt;String&gt; res) &#123; if (level &gt; high) return; fold(level + 1, high, true, res); res.add(down ? \"down\" : \"up\"); fold(level + 1, high, false, res);&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"完全二叉树判断","slug":"完全二叉树判断","date":"2018-02-22T13:35:08.000Z","updated":"2018-08-24T14:14:30.570Z","comments":true,"path":"2018/02/22/完全二叉树判断/","link":"","permalink":"https://lierabbit.cn/2018/02/22/完全二叉树判断/","excerpt":"","text":"有一棵二叉树,请设计一个算法判断它是否是完全二叉树。给定二叉树的根结点root，请返回一个bool值代表它是否为完全二叉树。树的结点个数小于等于500。 思路： 采用按层遍历二叉树的方式，从每层的左边向右边依次遍历所有的节点 如果当前节点有右孩子，但没有左孩子，直接返回false 如果当前节点并不是左右孩子全有，那之后的节点必须都为叶节点，否则返回false 遍历过程中如果不返回false，遍历结束后返回true即可 12345678910111213141516171819202122232425public boolean chk(TreeNode root) &#123; // write code here Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); TreeNode node; boolean isCheckLeaf = false; // 是否检查是叶子节点 while (!queue.isEmpty()) &#123; node = queue.poll(); if (node.left == null) &#123; // 有右孩子，必须有左孩子 if (node.right != null) return false; &#125; else &#123; if (isCheckLeaf) return false; else queue.add(node.left); &#125; if (node.right == null) &#123; // 当前节点右孩子为空则以后的节点都是叶子节点 isCheckLeaf = true; &#125; else &#123; queue.add(node.right); &#125; &#125; return true;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"平衡二叉树判断","slug":"平衡二叉树判断","date":"2018-02-22T12:25:16.000Z","updated":"2018-08-24T14:14:32.485Z","comments":true,"path":"2018/02/22/平衡二叉树判断/","link":"","permalink":"https://lierabbit.cn/2018/02/22/平衡二叉树判断/","excerpt":"","text":"有一棵二叉树,请设计一个算法判断它是否是完全二叉树。给定二叉树的根结点root，请返回一个bool值代表它是否为完全二叉树。树的结点个数小于等于500。 平衡二叉树（Self-balancing binary search tree）又被称为AVL树（有别于AVL算法），且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树 思路：递归分别获取左右子树深度，然后进行高度差判断 123456789101112131415161718192021public boolean check(TreeNode root) &#123; // write code here boolean[] result = new boolean[1]; result[0] = true; getHeight(root, 1, result); return result[0];&#125;public int getHeight(TreeNode node, int level, boolean[] res) &#123; if (node == null) return level; int lh = getHeight(node.left, level + 1, res); if (!res[0]) return level; int rh = getHeight(node.right, level + 1, res); if (!res[0]) return level; if (Math.abs(lh - rh) &gt; 1) res[0] = false; return Math.max(lh, rh);&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"二叉树的序列化","slug":"二叉树的序列化","date":"2018-02-22T09:54:03.000Z","updated":"2018-08-24T14:06:54.733Z","comments":true,"path":"2018/02/22/二叉树的序列化/","link":"","permalink":"https://lierabbit.cn/2018/02/22/二叉树的序列化/","excerpt":"","text":"首先我们介绍二叉树先序序列化的方式，假设序列化的结果字符串为str，初始时str等于空字符串。先序遍历二叉树，如果遇到空节点，就在str的末尾加上“#!”，“#”表示这个节点为空，节点值不存在，当然你也可以用其他的特殊字符，“!”表示一个值的结束。如果遇到不为空的节点，假设节点值为3，就在str的末尾加上“3!”。现在请你实现树的先序序列化。给定树的根结点root，请返回二叉树序列化后的字符串。 思路：用先序遍历即可 为什么要用“#!” 1234567891011121314151617public String toString(TreeNode root) &#123; // write code here StringBuilder stringBuilder = new StringBuilder(); preOrderWalk(root, stringBuilder); return stringBuilder.toString();&#125;public void preOrderWalk(TreeNode node, StringBuilder builder) &#123; if (node == null) builder.append(\"#!\"); else &#123; builder.append(node.val).append(\"!\"); preOrderWalk(node.left, builder); preOrderWalk(node.right, builder); &#125;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"二叉树的打印","slug":"二叉树的打印","date":"2018-02-22T09:38:22.000Z","updated":"2018-08-24T14:00:01.365Z","comments":true,"path":"2018/02/22/二叉树的打印/","link":"","permalink":"https://lierabbit.cn/2018/02/22/二叉树的打印/","excerpt":"","text":"有一棵二叉树，请设计一个算法，按照层次打印这棵二叉树。给定二叉树的根结点root，请返回打印结果，结果按照每一层一个数组进行储存，所有数组的顺序按照层数从上往下，且每一层的数组内元素按照从左往右排列。保证结点数小于等于500。 思路：使用队列保存按行从左往右的节点，使用last记录当前行的最右节点，使用nLast表示下一行的最右节点，当队列弹出的节点等于last表示当前行以打印完毕，进行换行 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public int[][] printTree(TreeNode root) &#123; // write code here Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); List&lt;List&lt;Integer&gt;&gt; datas = new ArrayList&lt;&gt;(); List&lt;Integer&gt; rowData = new ArrayList&lt;&gt;(); queue.add(root); TreeNode last = root; TreeNode nLast = null; TreeNode node; TreeNode left; TreeNode right; while (!queue.isEmpty()) &#123; node = queue.poll(); left = node.left; if (left != null) &#123; queue.add(left); nLast = left; &#125; right = node.right; if (right != null) &#123; queue.add(right); nLast = right; &#125; rowData.add(node.val); if (last == node) &#123; datas.add(rowData); rowData = new ArrayList&lt;&gt;(); last = nLast; &#125; &#125; int row = datas.size(); int[][] result = new int[row][]; for (int i = 0; i &lt; row; i++) &#123; List&lt;Integer&gt; colDatas = datas.get(i); int col = colDatas.size(); int[] colResult = new int[col]; for (int j = 0; j &lt; col; j++) &#123; colResult[j] = colDatas.get(j); &#125; result[i] = colResult; &#125; return result;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"非递归二叉树的序列打印","slug":"非递归二叉树的序列打印","date":"2018-02-22T08:31:40.000Z","updated":"2018-08-24T13:55:51.966Z","comments":true,"path":"2018/02/22/非递归二叉树的序列打印/","link":"","permalink":"https://lierabbit.cn/2018/02/22/非递归二叉树的序列打印/","excerpt":"","text":"非递归方式实现先序遍历1.首先申请一个新的栈，记为stack。2.然后将头节点head压入stack中。3.每次从stack中弹出栈顶节点，记为cur,然后打印cur节点的值。如果cur右孩子不为空的话，将cur的右孩子先压入stack中。最后如果cur的左孩子不为空的话，将cur的左孩子压入stack中。4.不断重复步骤3 ,直到stack为空，全部过程结束。 非递归方法实现中序遍历1.申请一个新的栈，记为stack,申请一个变量cur,初始时令cur等于头节点。2.先把cur节点压入栈中，对以cur节点为头的整棵子树来说，依次把整棵树的左边界压入栈中，即不断令cur=cur.left,然后重复步骤2。3.不断重复步骤2,直到发现cur为空，此时从stack中弹出一个节点，记为node。打印node的值，并让cur=node.right,然后继续重复步骤2。4.当stack为空并且cur为空时，整个过程结束。 非递归方法实现后序遍历使用两个栈实现1.申请一个栈，记为Si,然后将头节点压入si中。2.从si中弹出的节点记为cur,然后先把cur的左孩子压入si中，然后把curl的右孩子压入si中。3.在整个过程中，每一个从si中弹出的节点都放进第二个栈s2中。4.不断重复步骤2和步骤3,直到si为空，过程停止。5.从s2中依次弹出节点并打印，打印的顺序就是后序遍历的顺序了。 使用一个栈实现1.申请一个栈,记为stack,将头节点压入stack，同时设置两个变量h和C。在整个流程中,h代表最近一次弹出并打印的节点,c代表当前stack的栈顶节点,初始时令h为头节点,c为null.2.每次令c等于当前stack的栈顶节点,但是不从stack中弹出节点,此时分以下三种情况。 (1)如果c的左孩子不为空,并且h不等于c的左孩子，也不等于c的右孩子,则把c的左孩子压入stack中。 (2)如果情况1不成立,并且c的右孩子不为空，并且h不等于c的右孩子,则把c的右孩子压入stack中。 (3)如果情况1和情况2都不成立,那么从stack中弹出c并打印,然后令h等于C。3.一直重复步骤2 ,直到stack为空,过程停止。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990public int[][] convert(TreeNode root) &#123; // write code here int[][] result = new int[3][]; for (int i = 0; i &lt; 3; i++) &#123; List&lt;Integer&gt; tempList = new ArrayList&lt;&gt;(); if (i == 0) preOrderWalk(root, tempList); else if (i == 1) midOrderWalk(root, tempList); else backOrderWalk2(root, tempList); int dataSize = tempList.size(); int data[] = new int[dataSize]; for (int index = 0; index &lt; dataSize; index++) data[index] = tempList.get(index); result[i] = data; &#125; return result;&#125;// 先序遍历public void preOrderWalk(TreeNode root, List result) &#123; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.add(root); while (!stack.isEmpty()) &#123; TreeNode node = stack.pop(); result.add(node.val); if (node.right != null) stack.add(node.right); if (node.left != null) stack.add(node.left); &#125;&#125;// 中序遍历public void midOrderWalk(TreeNode root, List result) &#123; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode cur = root; TreeNode node; while (cur != null || !stack.isEmpty()) &#123; if (cur == null) &#123; node = stack.pop(); result.add(node.val); cur = node.right; &#125; else &#123; stack.add(cur); cur = cur.left; &#125; &#125;&#125;// 后序遍历1public void backOrderWalk1(TreeNode root, List result) &#123; Stack&lt;TreeNode&gt; s1 = new Stack&lt;&gt;(); Stack&lt;TreeNode&gt; s2 = new Stack&lt;&gt;(); s1.add(root); TreeNode cur; while (!s1.isEmpty()) &#123; cur = s1.pop(); s2.add(cur); if (cur.left != null) s1.add(cur.left); if (cur.right != null) s1.add(cur.right); &#125; while (!s2.isEmpty()) result.add(s2.pop().val);&#125;// 后序遍历2public void backOrderWalk2(TreeNode root, List result) &#123; Stack&lt;TreeNode&gt; s1 = new Stack&lt;&gt;(); s1.add(root); TreeNode h = root; TreeNode c; while (!s1.isEmpty()) &#123; c = s1.peek(); if (c.left != null &amp;&amp; h != c.left &amp;&amp; h != c.right) s1.add(c.left); else if (c.right != null &amp;&amp; h != c.right) s1.add(c.right); else &#123; h = s1.pop(); result.add(h.val); &#125; &#125;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"递归二叉树的序列打印","slug":"递归二叉树的序列打印","date":"2018-02-22T06:51:08.000Z","updated":"2018-08-24T13:39:51.036Z","comments":true,"path":"2018/02/22/递归二叉树的序列打印/","link":"","permalink":"https://lierabbit.cn/2018/02/22/递归二叉树的序列打印/","excerpt":"","text":"请用非递归方式实现二叉树的先序、中序和后序的遍历打印。给定一个二叉树的根结点root，请依次返回二叉树的先序，中序和后续遍历(二维数组的形式)。 思路： 前序遍历：先访问根节点，再访问左子树，最后访问右子树，简称中左右 中序遍历：先访问左子树，再访问根节点，最后访问右子树，简称左中右 后序遍历：先访问左子树，再访问右子树，最后访问根节点，简称左右中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public int[][] convert(TreeNode root) &#123; // write code here int[][] result = new int[3][]; for (int i = 0; i &lt; 3; i++) &#123; List&lt;Integer&gt; tempList = new ArrayList&lt;&gt;(); if (i == 0) preOrderWalk(root, tempList); else if (i == 1) midOrderWalk(root, tempList); else backOrderWalk(root, tempList); int dataSize = tempList.size(); int data[] = new int[dataSize]; for (int index = 0; index &lt; dataSize; index++) data[index] = tempList.get(index); result[i] = data; &#125; return result;&#125;// 前序遍历public void preOrderWalk(TreeNode node, List&lt;Integer&gt; result) &#123; if (node == null) return; result.add(node.val); preOrderWalk(node.left, result); preOrderWalk(node.right, result);&#125;// 中序遍历public void midOrderWalk(TreeNode node, List&lt;Integer&gt; result) &#123; if (node == null) return; midOrderWalk(node.left, result); result.add(node.val); midOrderWalk(node.right, result);&#125;// 后序遍历public void backOrderWalk(TreeNode node, List&lt;Integer&gt; result) &#123; if (node == null) return; backOrderWalk(node.left, result); backOrderWalk(node.right, result); result.add(node.val);&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"快速N次方","slug":"快速N次方","date":"2018-02-22T05:59:39.000Z","updated":"2018-08-24T13:38:15.553Z","comments":true,"path":"2018/02/22/快速N次方/","link":"","permalink":"https://lierabbit.cn/2018/02/22/快速N次方/","excerpt":"","text":"如果更快的求一个整数k的n次方。如果两个整数相乘并得到结果的时间复杂度为O(1)，得到整数k的N次方的过程请实现时间复杂度为O(logN)的方法。给定k和n，请返回k的n次方，为了防止溢出，请返回结果Mod 1000000007的值。测试样例： 122,3返回：8 思路： 12345678910111213141516public int getPower(int a, int n) &#123; BigInteger res = BigInteger.valueOf(1); BigInteger temp = BigInteger.valueOf(a); while (n != 0) &#123; if ((n &amp; 1) == 1) &#123; res = res.multiply(temp); &#125; temp = temp.multiply(temp); res = res.mod(BigInteger.valueOf(1000000007)); temp = temp.mod(BigInteger.valueOf(1000000007)); n &gt;&gt;= 1; &#125; return res.intValue();&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"完全二叉树计数","slug":"完全二叉树计数","date":"2018-02-21T06:56:40.000Z","updated":"2018-08-24T13:21:13.573Z","comments":true,"path":"2018/02/21/完全二叉树计数/","link":"","permalink":"https://lierabbit.cn/2018/02/21/完全二叉树计数/","excerpt":"","text":"给定一棵完全二叉树的根节点root，返回这棵树的节点个数。如果完全二叉树的节点数为N，请实现时间复杂度低于O(N)的解法。给定树的根结点root，请返回树的大小。 思路：与二分查找相似，如果右子树的高度等于左子树高度则表示左子树是一棵满二叉树，可用公示计算左子树大小，然后遍历右子树重复本操作。如果不相等表示右子树是一棵满二叉树且比左子树低一层，可用公式计算右子树大小，然后遍历左子树重复本操作 12345678910111213141516171819202122232425public int count(TreeNode head) &#123; if (head == null) &#123; return 0; &#125; return bs(head, 1, mostLeftLevel(head, 1));&#125;public int bs(TreeNode node, int level, int high) &#123; if (level == high) return 1; // 如果右子树的高度等于左子树高度则表示左子树是一棵满二叉树，可用公示计算左子树大小（带头节点），然后遍历右子树重复本操作 if (mostLeftLevel(node.right, level + 1) == high) return (int) (Math.pow(2, high - level) + bs(node.right, level + 1, high)); else return (int) (Math.pow(2, high - level - 1) + bs(node.left, level + 1, high));&#125;// 获取高度public int mostLeftLevel(TreeNode node, int level) &#123; while (node != null) &#123; level++; node = node.left; &#125; return level - 1;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"最左原位","slug":"最左原位","date":"2018-02-21T06:52:57.000Z","updated":"2018-08-24T13:13:41.623Z","comments":true,"path":"2018/02/21/最左原位/","link":"","permalink":"https://lierabbit.cn/2018/02/21/最左原位/","excerpt":"","text":"有一个有序数组arr，其中不含有重复元素，请找到满足arr[i]==i条件的最左的位置。如果所有位置上的数都不满足条件，返回-1。给定有序数组arr及它的大小n，请返回所求值。测试样例： 12[-1,0,2,3],4返回：2 思路：使用二分查找 当arr[mid] &gt; mid，由于数组有序，从左往右元素每次递增&gt;=1，下标每次递增1，所以右边不会出现arr[i]==i的情况 当arr[mid] &lt; mid，由于数组有序，从右往左元素每次递减&gt;=1，下标每次递减1，所以左边不会出现arr[i]==i的情况 123456789101112131415161718192021public int findPos(int[] arr, int n) &#123; // write code here if (arr == null || arr.length == 0) return -1; int left = 0; int right = n - 1; int mid; int result = -1; while (left &lt;= right) &#123; mid = left + (right - left) / 2; if (arr[mid] == mid) &#123; // 继续搜索左边 result = mid; right = mid - 1; &#125; else if (arr[mid] &gt; mid) // 由于数组有序，从左往右元素每次递增&gt;=1，下标每次递增1，所以右边不会出现arr[i]==i的情况 right = mid - 1; else // 由于数组有序，从右往左元素每次递减&gt;=1，下标每次递减1，所以左边不会出现arr[i]==i的情况 left = mid + 1; &#125; return result;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"循环有序数组最小值","slug":"循环有序数组最小值","date":"2018-02-21T06:20:34.000Z","updated":"2018-08-24T13:06:26.352Z","comments":true,"path":"2018/02/21/循环有序数组最小值/","link":"","permalink":"https://lierabbit.cn/2018/02/21/循环有序数组最小值/","excerpt":"","text":"对于一个有序循环数组arr，返回arr中的最小值。有序循环数组是指，有序数组左边任意长度的部分放到右边去，右边的部分拿到左边来。比如数组[1,2,3,3,4]，是有序循环数组，[4,1,2,3,3]也是。给定数组arr及它的大小n，请返回最小值。测试样例： 12[4,1,2,3,3],5返回：1 思路： 使用二分查找，当局部列表有序返回头元素 当局部列表有序返回头元素 当局部列表头元素小于中间元素，这里有循环，也就是有最小值，搜索左边 当局部列表中间元素小于尾元素，这里有循环，也就是有最小值，搜索右边 当局部列表头元素等于中间元素等于尾元素，遍历寻找最小值 1234567891011121314151617181920212223242526272829303132333435public int getMin(int[] arr, int n) &#123; // write code here if (arr == null || arr.length == 0) return -1; else &#123; int left = 0; int right = arr.length - 1; int mid; while (left &lt; right) &#123; mid = left + (right - left) / 2; if (left == right - 1) // 只剩2个数时直接比较其大小 break; else if (arr[left] &lt; arr[right]) // 当局部列表有序返回头 return arr[left]; else if (arr[left] &gt; arr[mid]) // 当局部列表头元素大于中间元素，这里有循环，也就是有最小值，搜索左边 right = mid; else if (arr[mid] &gt; arr[right]) // 当局部列表中间元素大于尾元素，这里有循环，也就是有最小值，搜索右边 left = mid; else &#123; // 当局部列表头元素等于中间元素等于尾元素，遍历寻找最小值 while (left &lt; right) &#123; if (arr[left] == arr[mid]) left++; else if (arr[left] &lt; arr[mid]) return arr[left]; else &#123; right = mid; break; &#125; &#125; &#125; &#125; return Math.min(arr[left], arr[right]); &#125;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"元素最左出现","slug":"元素最左出现","date":"2018-02-21T05:20:15.000Z","updated":"2018-08-24T13:03:52.902Z","comments":true,"path":"2018/02/21/元素最左出现/","link":"","permalink":"https://lierabbit.cn/2018/02/21/元素最左出现/","excerpt":"","text":"对于一个有序数组arr，再给定一个整数num，请在arr中找到num这个数出现的最左边的位置。给定一个数组arr及它的大小n，同时给定num。请返回所求位置。若该元素在数组中未出现，请返回-1。测试样例： 12[1,2,3,3,4],5,3返回：2 思路：使用折半查找，当找到num后使用result记录当前找到的num位置，接着再对其左边进行搜索，直到搜索完毕，返回的result就是最左位置 123456789101112131415161718192021222324public int findPos(int[] arr, int n, int num) &#123; // write code here if (arr == null || n == 0) return -1; int left = 0; int right = n - 1; int mid; int result = -1; while (left &lt;= right) &#123; mid = left + (right - left) / 2; // 如果找到num，则对其左边继续搜索 if (arr[mid] == num) &#123; result = mid; right = mid - 1; &#125; else if (arr[mid] &gt; num) right = mid - 1; else left = mid + 1; &#125; return result;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"局部最小值位置","slug":"局部最小值位置","date":"2018-02-21T04:44:42.000Z","updated":"2018-08-24T10:16:21.123Z","comments":true,"path":"2018/02/21/局部最小值位置/","link":"","permalink":"https://lierabbit.cn/2018/02/21/局部最小值位置/","excerpt":"","text":"定义局部最小的概念。arr长度为1时，arr[0]是局部最小。arr的长度为N(N&gt;1)时，如果arr[0]&lt;arr[1]，那么arr[0]是局部最小；如果arr[N-1]&lt;arr[N-2]，那么arr[N-1]是局部最小；如果0&lt;i&lt;N-1，既有arr[i]&lt;arr[i-1]又有arr[i]&lt;arr[i+1]，那么arr[i]是局部最小。 给定无序数组arr，已知arr中任意两个相邻的数都不相等，写一个函数，只需返回arr中任意一个局部最小出现的位置即可。 思路：由于相邻数不相等，所以必定能分出大小，先找两头，接着使用二分查找从中间开始找起。 123456789101112131415161718192021222324public int getLessIndex(int[] arr) &#123; if (arr == null || arr.length == 0) return -1; if (arr.length == 1 || arr[0] &lt; arr[1]) return 0; if (arr[arr.length - 1] &lt; arr[arr.length - 2]) return arr.length - 1; int left = 1; int right = arr.length - 2; int mid; while (left &lt; right) &#123; mid = left + (right - left) / 2; // 如果mid大于左边的值，从中间往左边看是递减的，则局部最小值就在左边 if (arr[mid] &gt; arr[mid - 1]) right = mid - 1; // 如果mid大于右边的值，从中间往右边看是递减的，则局部最小值就在右边 else if (arr[mid] &gt; arr[mid + 1]) left = mid + 1; // 小于相邻值就是局部最小值 else return mid; &#125; return left;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"单链表相交判断","slug":"单链表相交判断","date":"2018-02-19T05:09:45.000Z","updated":"2018-08-24T10:11:34.427Z","comments":true,"path":"2018/02/19/单链表相交判断/","link":"","permalink":"https://lierabbit.cn/2018/02/19/单链表相交判断/","excerpt":"","text":"给定两个单链表的头节点head1和head2，如何判断两个链表是否相交？相交的话返回true，不想交的话返回false。给定两个链表的头结点head1和head2(注意，另外两个参数adjust0和adjust1用于调整数据,与本题求解无关)。请返回一个bool值代表它们是否相交。 思路：3种情况 两链表都是无环链表，若相交则尾节点必定一致 两链表都是有环链表，转圈寻找相交点 一个链表有环一个链表无环，必定不相交 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class TreeNode &#123; public int val = 0; public TreeNode left = null; public TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125; public boolean chkInter(ListNode head1, ListNode head2, int adjust0, int adjust1) &#123; // write code here if (head1 == null || head2 == null) return false; ListNode entryNode1 = find(head1); ListNode entryNode2 = find(head2); if (entryNode1 == null &amp;&amp; entryNode2 == null) &#123; // 两个链表都是无环链表，若相交尾节点必定一致 ListNode node1 = head1; ListNode node2 = head2; while (node1.next != null) node1 = node1.next; while (node2.next != null) node2 = node2.next; return node1 == node2; &#125; else if (entryNode1 != null &amp;&amp; entryNode2 != null) &#123; // 两个链表都是有环链表，转圈寻找相交点 if (entryNode1 == entryNode2) return true; ListNode cur = entryNode1.next; while (cur != entryNode1) &#123; if (cur == entryNode2) return true; cur = cur.next; &#125; return false; &#125; else &#123; // 一个有环一个无环，必定不相交 return false; &#125; &#125; // 寻找入环点 public ListNode find(ListNode head) &#123; ListNode fast = head; ListNode normal = head; while (fast.next != null &amp;&amp; fast.next.next != null) &#123; normal = normal.next; fast = fast.next.next; if (normal == fast) break; &#125; if (normal == fast) &#123; // 有环 fast = head; while (fast != normal) &#123; fast = fast.next; normal = normal.next; &#125; return fast; &#125; return null; &#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"有环单链表相交判断","slug":"有环单链表相交判断","date":"2018-02-19T05:06:14.000Z","updated":"2018-08-24T10:11:47.446Z","comments":true,"path":"2018/02/19/有环单链表相交判断/","link":"","permalink":"https://lierabbit.cn/2018/02/19/有环单链表相交判断/","excerpt":"","text":"如何判断两个有环单链表是否相交？相交的话返回第一个相交的节点，不想交的话返回空。如果两个链表长度分别为N和M，请做到时间复杂度O(N+M)，额外空间复杂度O(1)。给定两个链表的头结点head1和head2(注意，另外两个参数adjust0和adjust1用于调整数据,与本题求解无关)。请返回一个bool值代表它们是否相交。 思路： 在入环前相交，则入环点一致 在环里相交，则绕环转一圈寻找一致点 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class TreeNode &#123; public int val = 0; public TreeNode left = null; public TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125; public boolean chkInter(ListNode head1, ListNode head2, int adjust0, int adjust1) &#123; // write code here ListNode node1 = find(head1); ListNode node2 = find(head2); if(node1 == node2) return true; ListNode cur = node1.next; // 在环里寻找 while (node1 != cur)&#123; if(cur == node2) return true; cur = cur.next; &#125; return false; &#125; public ListNode find(ListNode head) &#123; // 找到入环点 ListNode fast = head; ListNode normal = head; while (fast.next != null &amp;&amp; fast.next.next != null) &#123; normal = normal.next; fast = fast.next.next; if (fast == normal) break; &#125; fast = head; while (fast != normal) &#123; fast = fast.next; normal = normal.next; &#125; return fast; &#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"无环单链表判相交","slug":"无环单链表判相交","date":"2018-02-19T05:02:04.000Z","updated":"2018-08-24T09:57:08.603Z","comments":true,"path":"2018/02/19/无环单链表判相交/","link":"","permalink":"https://lierabbit.cn/2018/02/19/无环单链表判相交/","excerpt":"","text":"现在有两个无环单链表，若两个链表的长度分别为m和n，请设计一个时间复杂度为O(n + m)，额外空间复杂度为O(1)的算法，判断这两个链表是否相交。给定两个链表的头结点headA和headB，请返回一个bool值，代表这两个链表是否相交。保证两个链表长度小于等于500。 思路：如果无环单链表相交则尾节点必定一致 1234567891011121314151617181920212223public class TreeNode &#123; public int val = 0; public TreeNode left = null; public TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125; public boolean chkIntersect(ListNode headA, ListNode headB) &#123; if (headA == null || headB == null) return false; ListNode nodeA = headA; ListNode nodeB = headB; while (nodeA.next != null) nodeA = nodeA.next; while (nodeB.next != null) nodeB = nodeB.next; return nodeA == nodeB; &#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"链表判环","slug":"链表判环","date":"2018-02-19T04:57:32.000Z","updated":"2018-08-24T09:53:47.025Z","comments":true,"path":"2018/02/19/链表判环/","link":"","permalink":"https://lierabbit.cn/2018/02/19/链表判环/","excerpt":"","text":"如何判断一个单链表是否有环？有环的话返回进入环的第一个节点的值，无环的话返回-1。如果链表的长度为N，请做到时间复杂度O(N)，额外空间复杂度O(1)。给定一个单链表的头结点head（注意另一个参数adjust为加密后的数据调整参数，方便数据设置，与本题求解无关)，请返回所求值。 思路：使用快慢指针，一个每次走一步，一个每次走两步，如果快慢指针相遇则有环，令快指针等于头节点，这次快指针和慢指针同步走，当他们再次相遇时就是入环点 1234567891011121314151617181920212223242526272829303132333435363738public class TreeNode &#123; public int val = 0; public TreeNode left = null; public TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125; public int chkLoop(ListNode head, int adjust) &#123; // write code here if (head == null) return -1; ListNode fast = head; ListNode normal = head; while (fast.next != null &amp;&amp; fast.next.next != null) &#123; normal = normal.next; fast = fast.next.next; if (fast == normal) break; &#125; if(fast == normal)&#123; fast = head; while (true)&#123; if(fast == normal) return fast.val; fast = fast.next; normal = normal.next; &#125; &#125; return -1; &#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"复杂链表的复制","slug":"复杂链表的复制","date":"2018-02-19T04:44:30.000Z","updated":"2018-08-24T09:51:18.438Z","comments":true,"path":"2018/02/19/复杂链表的复制/","link":"","permalink":"https://lierabbit.cn/2018/02/19/复杂链表的复制/","excerpt":"","text":"输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点） 思路：使用在原始元素后面插入克隆元素解决难以设置随机指针问题，第一次遍历在每个元素后面添加一个克隆元素，第二次遍历设置克隆元素的随机指针即原随机指针的下一个，第三次遍历分割出克隆链表 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class RandomListNode &#123; int label; RandomListNode next = null; RandomListNode random = null; RandomListNode(int label) &#123; this.label = label; &#125;&#125; public RandomListNode Clone(RandomListNode head) &#123; if (head == null) return null; RandomListNode cur = head; while (cur != null) &#123; // 在链表每个元素后面添加一个克隆元素 RandomListNode newNode = new RandomListNode(cur.label); newNode.next = cur.next; cur.next = newNode; cur = newNode.next; &#125; cur = head; RandomListNode newNode; while (cur != null) &#123; // 给每个克隆元素设置随机指针 newNode = cur.next; newNode.random = cur.random == null ? null : cur.random.next; cur = cur.next.next; &#125; cur = head; RandomListNode newHead = cur.next; RandomListNode next; while (cur != null) &#123; // 分割出克隆链表，还原原链表 next = cur.next.next; newNode = cur.next; newNode.next = next == null ? null : next.next; cur.next = next; cur = next; &#125; return newHead; &#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"链表的回文结构","slug":"链表的回文结构","date":"2018-02-19T04:36:55.000Z","updated":"2018-08-24T09:41:13.063Z","comments":true,"path":"2018/02/19/链表的回文结构/","link":"","permalink":"https://lierabbit.cn/2018/02/19/链表的回文结构/","excerpt":"","text":"请编写一个函数，检查链表是否为回文。给定一个链表ListNode* pHead，请返回一个bool，代表链表是否为回文。测试样例： 1234&#123;1,2,3,2,1&#125;返回：true&#123;1,2,3,2,3&#125;返回：false 思路：反转链表中间节点之后的节点，然后再进行对比，最后还原链表。注意：可以用快慢指针，一个每次走一步，一个每次都两步，直到快指针到尾结束，此时慢指针就是中间节点 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class TreeNode &#123; public int val = 0; public TreeNode left = null; public TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125; public boolean isPalindrome(ListNode head) &#123; // write code here if (head == null || head.next == null) return true; ListNode leftNode = head; ListNode rightNode = head; while (rightNode.next != null &amp;&amp; rightNode.next.next != null) &#123;// 找到中间节点 leftNode = leftNode.next; // 中间节点 rightNode = rightNode.next.next; &#125; ListNode node = reserve(leftNode.next); // 反转右边部分，并获得原链表最后一个节点即反转后的第一个节点 rightNode = node; leftNode = head; boolean result = true; while (rightNode != null) &#123; if (leftNode.val != rightNode.val) &#123; result = false; break; &#125; leftNode = leftNode.next; rightNode = rightNode.next; &#125; reserve(node); // 还原右边部分 return result; &#125; public ListNode reserve(ListNode head) &#123; ListNode pre = head; ListNode cur = pre.next; pre.next = null; ListNode next; while (cur != null) &#123; next = cur.next; cur.next = pre; pre = cur; cur = next; &#125; return pre; &#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"链表指定值清除","slug":"链表指定值清除","date":"2018-02-19T04:33:42.000Z","updated":"2018-08-24T09:36:20.766Z","comments":true,"path":"2018/02/19/链表指定值清除/","link":"","permalink":"https://lierabbit.cn/2018/02/19/链表指定值清除/","excerpt":"","text":"现在有一个单链表。链表中每个节点保存一个整数，再给定一个值val，把所有等于val的节点删掉。给定一个单链表的头结点head，同时给定一个值val，请返回清除后的链表的头结点，保证链表中有不等于该值的其它值。请保证其他元素的相对顺序。测试样例： 12&#123;1,2,3,4,3,2,1&#125;,2&#123;1,3,4,3,1&#125; 思路：遍历删除指定值 1234567891011121314151617181920212223242526272829public class TreeNode &#123; public int val = 0; public TreeNode left = null; public TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125; public ListNode clear(ListNode head, int num) &#123; // 删除头节点直到头节点不为num while (head != null) &#123; if (head.val != num) break; head = head.next; &#125; ListNode pre = head; ListNode cur = head; while (cur != null) &#123; if (cur.val == num) pre.next = cur.next; else pre = cur; cur = cur.next; &#125; return head; &#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"链表的K逆序","slug":"链表的K逆序","date":"2018-02-19T04:07:11.000Z","updated":"2018-08-24T09:30:00.423Z","comments":true,"path":"2018/02/19/链表的K逆序/","link":"","permalink":"https://lierabbit.cn/2018/02/19/链表的K逆序/","excerpt":"","text":"有一个单链表，请设计一个算法，使得每K个节点之间逆序，如果最后不够K个节点一组，则不调整最后几个节点。例如链表1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;8-&gt;null，K=3这个例子。调整后为，3-&gt;2-&gt;1-&gt;6-&gt;5-&gt;4-&gt;7-&gt;8-&gt;null。因为K==3，所以每三个节点之间逆序，但其中的7，8不调整，因为只有两个节点不够一组。给定一个单链表的头指针head,同时给定K值，返回逆序后的链表的头指针。 思路：使用count计数当等于k时反转刚才遍历过的局部链表注意：反转的时候注意首尾连接 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class TreeNode &#123; public int val = 0; public TreeNode left = null; public TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125; public ListNode inverse(ListNode head, int k) &#123; // write code here if (k &lt; 2) return head; ListNode cur = head; ListNode start; ListNode pre = null; ListNode next; int count = 1; while (cur != null) &#123; next = cur.next; if (count == k) &#123; start = pre == null ? head : pre.next; head = pre == null ? cur : head; reverse(pre, start, cur, next); pre = start; count = 0; &#125; count++; cur = next; &#125; return head; &#125; /** * 反转局部链表 * @param left 局部链表头节点的前一个节点 * @param start 局部链表的头节点 * @param end 局部链表的尾节点 * @param right 局部链表尾节点的后一个节点 */ public void reverse(ListNode left, ListNode start, ListNode end, ListNode right) &#123; ListNode pre = start; ListNode cur = pre.next; ListNode next; while (cur != right) &#123; next = cur.next; cur.next = pre; pre = cur; cur = next; &#125; if (left != null) left.next = end; start.next = right; &#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"打印两个链表的公共值","slug":"打印两个链表的公共值","date":"2018-02-19T04:02:20.000Z","updated":"2018-08-24T09:22:20.954Z","comments":true,"path":"2018/02/19/打印两个链表的公共值/","link":"","permalink":"https://lierabbit.cn/2018/02/19/打印两个链表的公共值/","excerpt":"","text":"现有两个升序链表，且链表中均无重复元素。请设计一个高效的算法，打印两个链表的公共值部分。给定两个链表的头指针headA和headB，请返回一个vector，元素为两个链表的公共部分。请保证返回数组的升序。两个链表的元素个数均小于等于500。保证一定有公共值测试样例： 12&#123;1,2,3,4,5,6,7&#125;,&#123;2,4,6,8,10&#125;返回：[2.4.6] 思路：遍历2个链表进行对比，若相等则同时进一步，若A&lt;B则A进一步，直到其中一个链表遍历完成 12345678910111213141516171819202122232425262728293031323334353637383940public class TreeNode &#123; public int val = 0; public TreeNode left = null; public TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125; public int[] findCommonParts(ListNode headA, ListNode headB) &#123; // write code here if (headA == null || headB == null) return null; List&lt;Integer&gt; resultList = new ArrayList&lt;&gt;(); ListNode nodeA = headA; ListNode nodeB = headB; while (nodeA != null &amp;&amp; nodeB != null) &#123; if (nodeA.val == nodeB.val) &#123; resultList.add(nodeA.val); nodeA = nodeA.next; nodeB = nodeB.next; &#125; else if (nodeA.val &lt; nodeB.val) nodeA = nodeA.next; else nodeB = nodeB.next; &#125; int resultSize = resultList.size(); int[] result = new int[resultSize]; for (int i = 0; i &lt; resultSize; i++) &#123; result[i] = resultList.get(i); &#125; return result; &#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"链表的分化","slug":"链表的分化","date":"2018-02-19T03:42:18.000Z","updated":"2018-08-24T09:13:31.273Z","comments":true,"path":"2018/02/19/链表的分化/","link":"","permalink":"https://lierabbit.cn/2018/02/19/链表的分化/","excerpt":"","text":"对于一个链表，我们需要用一个特定阈值完成对它的分化，使得小于等于这个值的结点移到前面，大于该值的结点在后面，同时保证两类结点内部的位置关系不变。给定一个链表的头结点head，同时给定阈值val，请返回一个链表，使小于等于它的结点在前，大于等于它的在后，保证结点值不重复。测试样例： 12&#123;1,4,2,5&#125;,3&#123;1,2,4,5&#125; 思路：使用2个链表，一个放小于等于阈值的节点，一个放大于阈值的节点，最后连接2个链表注意：阈(yu)值(zhi)不是阀(fa)值(zhi) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class TreeNode &#123; public int val = 0; public TreeNode left = null; public TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125; public ListNode listDivide(ListNode head, int val) &#123; // write code here if (head == null) return head; ListNode leftHead = null; ListNode leftNode = null; ListNode rightHead = null; ListNode rightNode = null; ListNode node = head; while (node != null) &#123; if (node.val &lt;= val) &#123; if (leftHead == null) &#123; leftHead = node; leftNode = leftHead; &#125; else &#123; leftNode.next = node; leftNode = node; &#125; &#125; else &#123; if (rightHead == null) &#123; rightHead = node; rightNode = rightHead; &#125; else &#123; rightNode.next = node; rightNode = node; &#125; &#125; node = node.next; &#125; // 如果没有小于等于阈值，则只有大于阀值的部分，令头节点等于右边起始节点 if (leftHead == null) head = rightHead; else &#123; // 否则就是要连接左右部分 head = leftHead; leftNode.next = rightHead; &#125; if (rightHead != null) // 如果有右部分，则把尾节点的next置空 rightNode.next = null; return head; &#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"访问单个节点的删除","slug":"访问单个节点的删除","date":"2018-02-19T03:27:02.000Z","updated":"2018-08-24T09:10:44.470Z","comments":true,"path":"2018/02/19/访问单个节点的删除/","link":"","permalink":"https://lierabbit.cn/2018/02/19/访问单个节点的删除/","excerpt":"","text":"实现一个算法，删除单向链表中间的某个结点，假定你只能访问该结点。给定带删除的头节点和要删除的数字，请执行删除操作，返回删除后的头结点。链表中没有重复数字 思路：复制后一个节点即可，不可删除最后一个节点 1234567891011121314151617181920212223public class TreeNode &#123; public int val = 0; public TreeNode left = null; public TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125; public boolean removeNode(ListNode pNode) &#123; if (pNode == null) &#123; return false; &#125; ListNode next = pNode.next; if (next == null) &#123; return false; &#125; pNode.val = next.val; pNode.next = next.next; return true; &#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"环形链表插值","slug":"环形链表插值","date":"2018-02-19T03:21:27.000Z","updated":"2018-08-24T09:01:07.494Z","comments":true,"path":"2018/02/19/环形链表插值/","link":"","permalink":"https://lierabbit.cn/2018/02/19/环形链表插值/","excerpt":"","text":"有一个整数val，如何在节点值有序的环形链表中插入一个节点值为val的节点，并且保证这个环形单链表依然有序。给定链表的信息，及元素的值A及对应的nxt指向的元素编号同时给定val，请构造出这个环形链表，并插入该值。测试样例： 12[1,3,4,5,7],[1,2,3,4,0],2返回：&#123;1,2,3,4,5,7&#125; 思路：构建环形链表，首尾相连。插值的时候注意如果插入值小于链表中所有元素则返回该节点作为头节点 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class TreeNode &#123; public int val = 0; public TreeNode left = null; public TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125; public ListNode insert(int[] A, int[] nxt, int val) &#123; // write code here ListNode head; if (A == null || A.length == 0) &#123; head = new ListNode(val); head.next = head; &#125; else &#123; head = new ListNode(A[0]); ListNode pre = head;// 前一个节点 ListNode cur;// 当前节点 for (int next : nxt) &#123; if (next == 0) cur = head; else cur = new ListNode(A[next]); pre.next = cur; pre = cur; &#125; head = insertValue(head, val); &#125; return head; &#125; public ListNode insertValue(ListNode head, int val) &#123; ListNode pre = head; ListNode cur = head.next; while (cur != head) &#123; if (pre.val &lt;= val &amp;&amp; val &lt;= cur.val) break; pre = cur; cur = cur.next; &#125; ListNode realHead;// 插入后的头节点 // 没有在中间找到插入点，则要么val大于或者小于链表里所有数 ListNode node = new ListNode(val); pre.next = node; node.next = cur; if (cur == head) &#123; if (val &lt; head.val) realHead = node; else realHead = head; &#125; else &#123; realHead = head; &#125; return realHead; &#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"数组变树","slug":"数组变树","date":"2018-02-18T15:43:34.000Z","updated":"2018-08-24T08:51:28.356Z","comments":true,"path":"2018/02/18/数组变树/","link":"","permalink":"https://lierabbit.cn/2018/02/18/数组变树/","excerpt":"","text":"对于一个没有重复元素的整数数组，请用其中元素构造一棵MaxTree，MaxTree定义为一棵二叉树，其中的节点与数组元素一一对应，同时对于MaxTree的每棵子树，它的根的元素值为子树的最大值。现有一建树方法，对于数组中的每个元素，其在树中的父亲为数组中它左边比它大的第一个数和右边比它大的第一个数中更小的一个。若两边都不存在比它大的数，那么它就是树根。请设计O(n)的算法实现这个方法。给定一个无重复元素的数组A和它的大小n，请返回一个数组，其中每个元素为原数组中对应位置元素在树中的父亲节点的编号，若为根则值为-1。测试样例： 12[3,1,4,2],4返回：[2,0,-1,2] 思路：第一次遍历数组找到左边第一个比当前数大的下标，第二次遍历数组找到右边第一个比当前数大的下标，并和左边第一个比当前数大的数比较，取较小的 1234567891011121314151617181920212223242526272829303132333435public int[] buildMaxTree(int[] arr, int n) &#123; // write code here Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); int[] res = new int[n]; // 找到左边第一个比当前数大的下标 for (int i = 0; i &lt; n; i++) &#123; while (!stack.empty() &amp;&amp; arr[stack.peek()] &lt; arr[i]) stack.pop(); if (stack.empty()) res[i] = -1; else res[i] = stack.peek(); stack.push(i); &#125; stack.clear(); // 找到右边第一个比当前数大的下标，并和左边第一个比当前数大的数比较，取较小的 for (int i = n - 1; i &gt;= 0; i--) &#123; while (!stack.empty() &amp;&amp; arr[stack.peek()] &lt; arr[i]) stack.pop(); if (!stack.empty())&#123; if(res[i] == -1) res[i] = stack.peek(); else &#123; res[i] = arr[stack.peek()] &lt; arr[res[i]] ? stack.peek() : res[i]; &#125; &#125; stack.push(i); &#125; return res;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"滑动窗口","slug":"滑动窗口","date":"2018-02-18T15:04:52.000Z","updated":"2018-08-24T08:47:41.250Z","comments":true,"path":"2018/02/18/滑动窗口/","link":"","permalink":"https://lierabbit.cn/2018/02/18/滑动窗口/","excerpt":"","text":"有一个整型数组 arr 和一个大小为 w 的窗口从数组的最左边滑到最右边,窗口每次向右边滑一个位置。 返回一个长度为n-w+1的数组res，res[i]表示每一种窗口状态下的最大值。 以数组为[4,3,5,4,3,3,6,7]，w=3为例。因为第一个窗口[4,3,5]的最大值为5，第二个窗口[3,5,4]的最大值为5，第三个窗口[5,4,3]的最大值为5。第四个窗口[4,3,3]的最大值为4。第五个窗口[3,3,6]的最大值为6。第六个窗口[3,6,7]的最大值为7。所以最终返回[5,5,5,4,6,7]。给定整形数组arr及它的大小n，同时给定w，请返回res数组。保证w小于等于n，同时保证数组大小小于等于500。测试样例： 12[4,3,5,4,3,3,6,7],8,3返回：[5,5,5,4,6,7] 思路：使用双端队列记录访问到的最大值，判断该值是否还在窗口内 123456789101112131415161718192021public int[] slide(int[] arr, int n, int w) &#123; // write code here int result[] = new int[n - w + 1]; int resultSize = 0; // 从大到小的队列 Deque&lt;Integer&gt; qMax = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; n; i++) &#123; while (!qMax.isEmpty() &amp;&amp; arr[i] &gt;= arr[qMax.peekLast()]) qMax.pollLast(); qMax.add(i); if (i &gt;= w - 1) &#123; // 判断最大值是否在窗口内 if (qMax.peekFirst() == i - w) qMax.pollFirst(); result[resultSize++] = arr[qMax.peekFirst()]; &#125; &#125; return result;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"双栈排序","slug":"双栈排序","date":"2018-02-18T13:42:41.000Z","updated":"2018-08-24T08:42:39.080Z","comments":true,"path":"2018/02/18/双栈排序/","link":"","permalink":"https://lierabbit.cn/2018/02/18/双栈排序/","excerpt":"","text":"请编写一个程序，按升序对栈进行排序（即最大元素位于栈顶），要求最多只能使用一个额外的栈存放临时数据，但不得将元素复制到别的数据结构中。给定一个int[] numbers(C++中为vector&amp;ltint&gt;)，其中第一个元素为栈顶，请返回排序后的栈。请注意这是一个栈，意味着排序过程中你只能访问到第一个元素。测试样例： 12[1,2,3,4,5]返回：[5,4,3,2,1] 思路：用一个排序栈help，大于等于help栈顶则压入，小于则help弹出栈顶，继续比较，直到找到插入的位置 123456789101112131415161718192021222324252627282930313233343536373839404142434445public ArrayList&lt;Integer&gt; twoStacksSort(int[] numbers) &#123; // write code here Stack&lt;Integer&gt; data = new Stack&lt;&gt;(); Stack&lt;Integer&gt; help = new Stack&lt;&gt;(); for (int i = numbers.length - 1; i &gt;= 0; i--) data.push(numbers[i]); while (!data.empty()) &#123; Integer value = data.pop(); if (help.empty()) help.push(value); else &#123; if (value &lt;= help.peek()) help.push(value); else &#123; int popNumber = 0; while (!help.empty()) &#123; if (value &gt; help.peek()) &#123; data.push(help.pop()); popNumber++; &#125; else break; &#125; help.push(value); while (popNumber != 0) &#123; help.push(data.pop()); popNumber--; &#125; &#125; &#125; &#125; while (!help.empty()) &#123; data.push(help.pop()); &#125; ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); while (!data.empty()) &#123; list.add(data.pop()); &#125; return list;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"栈的反转","slug":"栈的反转","date":"2018-02-18T11:32:33.000Z","updated":"2018-08-24T08:37:53.261Z","comments":true,"path":"2018/02/18/栈的反转/","link":"","permalink":"https://lierabbit.cn/2018/02/18/栈的反转/","excerpt":"","text":"实现一个栈的逆序，但是只能用递归函数和这个栈本身的pop操作来实现，而不能自己申请另外的数据结构。给定一个整数数组A即为给定的栈，同时给定它的大小n，请返回逆序后的栈。测试样例： 12[4,3,2,1],4返回：[1,2,3,4] 思路：利用递归获取栈底，弹出-&gt;弹出-&gt;弹出（栈底）-&gt;返回栈底-&gt;返回栈底-&gt;返回栈底，栈底-&gt;栈底-&gt;栈底（最后一个）-&gt;压入栈底-&gt;压入栈底-&gt;压入栈底 1234567891011121314151617181920212223242526272829303132333435363738public class StackReverse &#123; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); public int[] reverseStack(int[] A, int n) &#123; // write code here for (int i = n - 1; i &gt;= 0; i--) stack.add(A[i]); reverse(); int index = 0; while (!stack.empty()) A[index++] = stack.pop(); return A; &#125; // 反转栈 public void reverse() &#123; if (stack.empty()) return; int i = getBottom(); reverse(); stack.push(i); &#125; // 得到栈底元素 public int getBottom() &#123; int result = stack.pop(); if (stack.empty()) return result; else &#123; int last = getBottom(); stack.push(result); return last; &#125; &#125;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"双栈队列","slug":"双栈队列","date":"2018-02-18T11:24:16.000Z","updated":"2018-08-24T08:33:04.299Z","comments":true,"path":"2018/02/18/双栈队列/","link":"","permalink":"https://lierabbit.cn/2018/02/18/双栈队列/","excerpt":"","text":"编写一个类,只能用两个栈结构实现队列,支持队列的基本操作(push，pop)。给定一个操作序列ope及它的长度n，其中元素为正数代表push操作，为0代表pop操作，保证操作序列合法且一定含pop操作，请返回pop的结果序列。测试样例： 12[1,2,3,0,4,0],6返回：[1,2] 思路：一个栈用来压入，一个栈用来弹出，先压入到压入栈，然后再全部弹出压入弹出栈即可模拟队列，注意：当弹出栈不空时不能压入弹出栈必须一次性将压入栈倒出到弹出栈 123456789101112131415161718192021222324252627282930313233343536373839public class TwoStack &#123; private Stack&lt;Integer&gt; pushStack = new Stack&lt;&gt;(); private Stack&lt;Integer&gt; popStack = new Stack&lt;&gt;(); public int[] twoStack(int[] ope, int n) &#123; // write code here List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int a : ope) &#123; if (a != 0) add(a); else &#123; list.add(pop()); &#125; &#125; int[] result = new int[list.size()]; int resultLen = 0; for(int a:list) result[resultLen++] = a; return result; &#125; private void add(int value) &#123; while (!popStack.empty()) &#123; pushStack.add(popStack.pop()); &#125; pushStack.add(value); &#125; private int pop() &#123; while (!pushStack.empty()) &#123; popStack.add(pushStack.pop()); &#125; return popStack.pop(); &#125;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"可查询最值的栈","slug":"可查询最值的栈","date":"2018-02-18T11:13:06.000Z","updated":"2018-08-24T08:30:49.577Z","comments":true,"path":"2018/02/18/可查询最值的栈/","link":"","permalink":"https://lierabbit.cn/2018/02/18/可查询最值的栈/","excerpt":"","text":"定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的min函数。 思路：使用2个栈stack和minStack，stack压入所有元素，minStack只压入最小值，弹出元素的时候，stack正常弹出，minStack只有栈顶元素==stack弹出的元素才弹出 12345678910111213141516171819202122232425262728293031public class Solution &#123; private Stack&lt;Integer&gt; stack; private Stack&lt;Integer&gt; minStack; public Solution() &#123; stack = new Stack&lt;&gt;(); minStack = new Stack&lt;&gt;(); &#125; public void push(int value) &#123; stack.add(value); if (minStack.empty()) minStack.push(value); else if (minStack.peek() &gt;= value) minStack.push(value); &#125; public void pop() &#123; Integer value = stack.pop(); if (value == minStack.peek()) minStack.pop(); &#125; public int top() &#123; return stack.peek(); &#125; public int min() &#123; return minStack.peek(); &#125;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"最长无重复字符字串","slug":"最长无重复字符字串","date":"2018-02-18T10:55:23.000Z","updated":"2018-08-24T08:19:54.321Z","comments":true,"path":"2018/02/18/最长无重复字符字串/","link":"","permalink":"https://lierabbit.cn/2018/02/18/最长无重复字符字串/","excerpt":"","text":"对于一个字符串,请设计一个高效算法，找到字符串的最长无重复字符的子串长度。给定一个字符串A及它的长度n，请返回它的最长无重复字符子串长度。保证A中字符全部为小写英文字符，且长度小于等于500。测试样例： 12&quot;aabcb&quot;,5返回：3 思路：使用数组模拟HashMap记录字符上次出现的位置，用pre记录最近重复字符出现最近的位置，则i(当前位置)-pre就是当前字符最长无重复字符的长度，取最大的就是字符串的最长无重复字符的长度 1234567891011121314151617181920212223public int longestSubstring(String A, int n) &#123; if (A == null || n == 0) &#123; return 0; &#125; int[] map = new int[256]; for (int i = 0; i &lt; 256; i++) map[i] = -1; char[] chars = A.toCharArray(); int len = 0; int pre = -1;//之前出现的地方 int cur;//当前最长无重复字符子串长度 for (int i = 0; i &lt; chars.length; i++) &#123; pre = Math.max(pre, map[chars[i]]); cur = i - pre; len = Math.max(len, cur); map[chars[i]] = i; &#125; return len;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"合法括号序列判断","slug":"合法括号序列判断","date":"2018-02-18T10:37:20.000Z","updated":"2018-08-24T08:17:16.089Z","comments":true,"path":"2018/02/18/合法括号序列判断/","link":"","permalink":"https://lierabbit.cn/2018/02/18/合法括号序列判断/","excerpt":"","text":"对于一个字符串，请设计一个算法，判断其是否为一个合法的括号串。给定一个字符串A和它的长度n，请返回一个bool值代表它是否为一个合法的括号串。测试样例： 12345678910&quot;(()())&quot;,6返回：true测试样例：&quot;()a()()&quot;,7返回：false测试样例：&quot;()(()()&quot;,7返回：false 思路：用num记录括号出现次数，出现’(‘则+1，出现’)’则-1，若num&lt;0说明’)’出现过多，若遍历完整个数组num不为0说明’(‘过多 12345678910111213141516public boolean chkParenthesis(String A, int n) &#123; // write code here int num = 0; char[] chars = A.toCharArray(); for (char ch : chars) &#123; if (ch == '(') num++; if (ch == ')') num--; if (num &lt; 0) return false; &#125; return num == 0;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"空格替换","slug":"空格替换","date":"2018-02-18T10:28:12.000Z","updated":"2018-08-24T08:14:45.950Z","comments":true,"path":"2018/02/18/空格替换/","link":"","permalink":"https://lierabbit.cn/2018/02/18/空格替换/","excerpt":"","text":"请编写一个方法，将字符串中的空格全部替换为“%20”。假定该字符串有足够的空间存放新增的字符，并且知道字符串的真实长度(小于等于1000)，同时保证字符串由大小写的英文字母组成。给定一个string iniString 为原始的串，以及串的长度 int len, 返回替换后的string。测试样例： 1234&quot;Mr John Smith”,13返回：&quot;Mr%20John%20Smith&quot;”Hello World”,12返回：”Hello%20%20World” 使用replaceAlliniString.replaceAll(“ “,”%20”) 手动实现思路：记录空格出现次数，新数组长度等于原数组长度+空格数*2，遍历原数组按规则放入新数组即可 123456789101112131415161718192021222324public String replaceSpace(String iniString, int length) &#123; // write code here if (iniString == null || iniString.length() == 0) return iniString; char[] chars = iniString.toCharArray(); int space = 0; for (char ch : chars) if (ch == ' ') space++; int resultLen = length + space * 2; char[] result = new char[resultLen]; for (int i = length - 1; i &gt;= 0; i--) &#123; if (chars[i] == ' ') &#123; result[--resultLen] = '0'; result[--resultLen] = '2'; result[--resultLen] = '%'; &#125; else result[--resultLen] = chars[i]; &#125; return String.valueOf(result);&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"拼接最小字典序","slug":"拼接最小字典序","date":"2018-02-18T10:15:44.000Z","updated":"2018-08-24T08:11:27.769Z","comments":true,"path":"2018/02/18/拼接最小字典序/","link":"","permalink":"https://lierabbit.cn/2018/02/18/拼接最小字典序/","excerpt":"","text":"对于一个给定的字符串数组，请找到一种拼接顺序，使所有小字符串拼接成的大字符串是所有可能的拼接中字典序最小的。给定一个字符串数组strs，同时给定它的大小，请返回拼接成的串。测试样例： 12[&quot;abc&quot;,&quot;de&quot;],2&quot;abcde&quot; 思路：将字符串数组排序，然后按序拼接。有字符串a和b，若a+b&lt;b+a，则a在前b在后。 123456789101112131415public String findSmallest(String[] strs, int n) &#123; // write code here if (strs == null) return null; if (strs.length == 1) return strs[0]; Arrays.sort(strs, (a, b) -&gt; (a + b).compareTo(b + a)); StringBuilder result = new StringBuilder(); for (String str : strs) result.append(str); return result.toString();&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"字符串位移","slug":"字符串位移","date":"2018-02-18T10:12:02.000Z","updated":"2018-08-24T08:00:41.927Z","comments":true,"path":"2018/02/18/字符串位移/","link":"","permalink":"https://lierabbit.cn/2018/02/18/字符串位移/","excerpt":"","text":"对于一个字符串，请设计一个算法，将字符串的长度为len的前缀平移到字符串的最后。给定一个字符串A和它的长度，同时给定len，请返回平移后的字符串。测试样例： 12&quot;ABCDE&quot;,5,3返回：&quot;DEABC&quot; 思路：首先将长度为len的字符逆序，再把len之后的字符逆序，最后把整个字符串逆序即可 123456789101112131415161718192021222324public String stringTranslation(String A, int n, int len) &#123; // write code here char[] chars = A.toCharArray(); reverse(chars, 0, len - 1); reverse(chars, len, n - 1); reverse(chars, 0, n - 1); return String.valueOf(chars);&#125;public void reverse(char[] chars, int start, int end) &#123; while (start &lt; end) &#123; swap(chars, start, end); start++; end--; &#125;&#125;public void swap(char[] chars, int i, int j) &#123; char temp = chars[i]; chars[i] = chars[j]; chars[j] = temp;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"句子的逆序","slug":"句子的逆序","date":"2018-02-18T10:04:17.000Z","updated":"2018-08-24T07:56:00.011Z","comments":true,"path":"2018/02/18/句子的逆序/","link":"","permalink":"https://lierabbit.cn/2018/02/18/句子的逆序/","excerpt":"","text":"对于一个字符串，请设计一个算法，只在字符串的单词间做逆序调整，也就是说，字符串由一些由空格分隔的部分组成，你需要将这些部分逆序。给定一个原字符串A和他的长度，请返回逆序后的字符串。测试样例： 12&quot;dog loves pig&quot;,13返回：&quot;pig loves dog&quot; 思路：首先反转整个字符串，接着一个一个的反转局部单词即可 12345678910111213141516171819202122232425262728293031323334353637383940public String reverseSentence(String A, int n) &#123; // write code here char[] chars = A.toCharArray(); // 反转整个字符串 reverse(chars, 0, chars.length - 1); int l = -1; int r = -1; for (int i = 0; i &lt; chars.length; i++) &#123; if (chars[i] != ' ') &#123; if (i == 0 || chars[i - 1] == ' ') // 寻找需要局部反转的单词的起始下标 l = i; if (i == chars.length - 1 || chars[i + 1] == ' ') // 寻找需要局部反转的单词的末尾下标 r = i; &#125; if (l != -1 &amp;&amp; r != -1) &#123; reverse(chars, l, r); l = -1; r = -1; &#125; &#125; return String.valueOf(chars);&#125;// 反转字符串public void reverse(char[] chars, int start, int end) &#123; while (start &lt; end) &#123; swap(chars, start, end); start++; end--; &#125;&#125;// 交换public void swap(char[] chars, int i, int j) &#123; char temp = chars[i]; chars[i] = chars[j]; chars[j] = temp;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"两串旋转","slug":"两串旋转","date":"2018-02-18T09:53:37.000Z","updated":"2018-08-24T07:54:19.640Z","comments":true,"path":"2018/02/18/两串旋转/","link":"","permalink":"https://lierabbit.cn/2018/02/18/两串旋转/","excerpt":"","text":"如果对于一个字符串A，将A的前面任意一部分挪到后边去形成的字符串称为A的旋转词。比如A=”12345”,A的旋转词有”12345”,”23451”,”34512”,”45123”和”51234”。对于两个字符串A和B，请判断A和B是否互为旋转词。给定两个字符串A和B及他们的长度lena，lenb，请返回一个bool值，代表他们是否互为旋转词。测试样例：12&quot;cdab&quot;,4,&quot;abcd&quot;,4返回：true 思路：如果A，B互为旋转词，则A+A必定包含B例如A=”abcd”，B=”cdab”，则A+A=”abcdabcd”，里面有”abcd”，”bcda”，”cdab”，”dabc”枚举了所有的旋转词 12345678public boolean chkRotation(String A, int lena, String B, int lenb) &#123; // write code here if (lena == lenb) &#123; String C = A + A; return C.contains(B); &#125; else return false;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"词语变形","slug":"词语变形","date":"2018-02-18T09:48:13.000Z","updated":"2018-08-24T07:46:11.079Z","comments":true,"path":"2018/02/18/词语变形/","link":"","permalink":"https://lierabbit.cn/2018/02/18/词语变形/","excerpt":"","text":"对于两个字符串A和B，如果A和B中出现的字符种类相同且每种字符出现的次数相同，则A和B互为变形词，请设计一个高效算法，检查两给定串是否互为变形词。给定两个字符串A和B及他们的长度，请返回一个bool值，代表他们是否互为变形词。测试样例： 12&quot;abc&quot;,3,&quot;bca&quot;,3返回：true 思路：使用数组模拟hashMap计数，只要字符出现次数一致就互为变形词 12345678910111213141516171819public boolean chkTransform(String str1, int lena, String str2, int lenb) &#123; // write code here if (str1 == null || str2 == null || lena != lenb) return false; char[] chars1 = str1.toCharArray(); char[] chars2 = str2.toCharArray(); int[] map = new int[256]; for (char char1 : chars1) map[char1]++; for (char char2 : chars2) &#123; if (map[char2]-- == 0) return false; &#125; return true;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"拓扑结构相同子树","slug":"拓扑结构相同子树","date":"2018-02-18T09:33:25.000Z","updated":"2018-08-24T07:41:54.834Z","comments":true,"path":"2018/02/18/拓扑结构相同子树/","link":"","permalink":"https://lierabbit.cn/2018/02/18/拓扑结构相同子树/","excerpt":"","text":"对于两棵彼此独立的二叉树A和B，请编写一个高效算法，检查A中是否存在一棵子树与B树的拓扑结构完全相同。给定两棵二叉树的头结点A和B，请返回一个bool值，代表A中是否存在一棵同构于B的子树。 思路：将树序列化成字符串。如果A树中存在一棵子树与B树的拓扑结构完全相同则A序列化后的字符串必定包含B序列化后的字符串。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class TreeNode &#123; public int val = 0; public TreeNode left = null; public TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125; public boolean chkIdentical(TreeNode A, TreeNode B) &#123; // write code here String AS = treeToStringWithStack(A); String BS = treeToStringWithStack(B); return AS.contains(BS); &#125; // 先序遍历 public String treeToStringWithStack(TreeNode root) &#123; StringBuilder result = new StringBuilder(); Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.add(root); TreeNode node; while (!stack.empty()) &#123; node = stack.pop(); if (node == null) result.append(\"#!\"); else &#123; result.append(node.val).append(\"!\"); stack.add(node.right); stack.add(node.left); &#125; &#125; return result.toString(); &#125; // 递归先序遍历 public String serialByPre(TreeNode head) &#123; if (head == null) &#123; return \"#!\"; &#125; String res = head.val + \"!\"; res += serialByPre(head.left); res += serialByPre(head.right); return res; &#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"相邻两数最大差值","slug":"相邻两数最大差值","date":"2018-02-18T08:24:09.000Z","updated":"2018-08-24T07:40:49.628Z","comments":true,"path":"2018/02/18/相邻两数最大差值/","link":"","permalink":"https://lierabbit.cn/2018/02/18/相邻两数最大差值/","excerpt":"","text":"有一个整形数组A，请设计一个复杂度为O(n)的算法，算出排序后相邻两数的最大差值。给定一个int数组A和A的大小n，请返回最大的差值。保证数组元素多于1个。测试样例： 12[1,2,5,4,6],5返回：2 思路：使用2个n+1大小的桶按区间来放置最大和最小数，第n+1个桶单独放置最大值，取每个桶之间的最大差值即可 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public int maxGap(int[] nums, int n) &#123; // write code here if (nums == null || nums.length &lt; 2) return 0; int len = nums.length; int min = Integer.MAX_VALUE; int max = Integer.MIN_VALUE; // 获取数组中最大最小值用来划分桶区间 for (int num : nums) &#123; min = Math.min(min, num); max = Math.max(max, num); &#125; if (max == min) return 0; boolean[] hasNums = new boolean[len + 1]; int[] maxs = new int[len + 1]; int[] mins = new int[len + 1]; int bid; // 将数放入桶中 for (int num : nums) &#123; bid = bucket(num, len, min, max); mins[bid] = hasNums[bid] ? Math.min(mins[bid], num) : num; maxs[bid] = hasNums[bid] ? Math.max(maxs[bid], num) : num; hasNums[bid] = true; &#125; int lastMax = 0; int index = 0; // 寻找第一个不为空的桶 while (index &lt;= len) &#123; if (hasNums[index]) &#123; lastMax = maxs[index]; break; &#125; index++; &#125; int result = 0; while (index &lt;= len) &#123; if (hasNums[index]) &#123; // 当桶的最小值减去上一个不为空的桶最大值即为2个桶的最大差值 result = Math.max(result, mins[index] - lastMax); lastMax = maxs[index]; &#125; index++; &#125; return result;&#125;// 使用long类型是为了防止相乘时溢出// 根据区间获取桶号public int bucket(long num, long len, long min, long max) &#123; return (int) ((num - min) * len / (max - min));&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"最短子数组","slug":"最短子数组","date":"2018-02-18T08:05:18.000Z","updated":"2018-08-24T07:35:29.447Z","comments":true,"path":"2018/02/18/最短子数组/","link":"","permalink":"https://lierabbit.cn/2018/02/18/最短子数组/","excerpt":"","text":"对于一个数组，请设计一个高效算法计算需要排序的最短子数组的长度。给定一个int数组A和数组的大小n，请返回一个二元组，代表所求序列的长度。(原序列位置从0开始标号,若原序列有序，返回0)。保证A中元素均为正整数。测试样例： 12[1,4,6,5,9,10],6返回：2 思路：从左往右记录最大值，并记录最大值大于当前遍历数的位置，因为排序后最大值至少在当前位置或者更右的位置。从右往左记录最小值，并记录最小值小于当前遍历数的位置，因为排序后最小值至少在当前位置或者更左的位置。 12345678910111213141516171819202122232425public int shortestSubsequence(int[] A, int n) &#123; int maxIndex = 0; int max = A[maxIndex]; int minIndex = n - 1; int min = A[n - 1]; for (int i = maxIndex + 1; i &lt; n; i++) &#123; if (max &lt;= A[i]) max = A[i]; else maxIndex = i; &#125; for (int i = minIndex - 1; i &gt;= 0; i--) &#123; if (min &gt;= A[i]) min = A[i]; else minIndex = i; &#125; if (maxIndex == 0 &amp;&amp; minIndex == n - 1) return 0; else return maxIndex - minIndex + 1;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"有序矩阵查找","slug":"有序矩阵查找","date":"2018-02-18T07:57:22.000Z","updated":"2018-08-24T07:26:53.382Z","comments":true,"path":"2018/02/18/有序矩阵查找/","link":"","permalink":"https://lierabbit.cn/2018/02/18/有序矩阵查找/","excerpt":"","text":"现在有一个行和列都排好序的矩阵，请设计一个高效算法，快速查找矩阵中是否含有值x。给定一个int矩阵mat，同时给定矩阵大小nxm及待查找的数x，请返回一个bool值，代表矩阵中是否存在x。所有矩阵中数字及x均为int范围内整数。保证n和m均小于等于1000。测试样例： 12[[1,2,3],[4,5,6],[7,8,9]],3,3,10返回：false 思路：从右上角开始找 1234567891011121314151617181920public boolean findX(int[][] mat, int n, int m, int x) &#123; // write code here int row = 0; int col = m - 1; while (row &lt; n &amp;&amp; col &gt;= 0) &#123; if (mat[row][col] == x) return true; // 比它大往左走 else if (x &lt;= mat[row][col]) &#123; col--; &#125; // 比它小往下走 else if (x &gt;= mat[row][col]) &#123; row++; &#125; &#125; return false; &#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"三色排序","slug":"三色排序","date":"2018-02-17T11:38:54.000Z","updated":"2018-08-24T07:15:50.052Z","comments":true,"path":"2018/02/17/三色排序/","link":"","permalink":"https://lierabbit.cn/2018/02/17/三色排序/","excerpt":"","text":"有一个只由0，1，2三种元素构成的整数数组，请使用交换、原地排序而不是使用计数进行排序。给定一个只含0，1，2的整数数组A及它的大小，请返回排序后的数组。保证数组大小小于等于500。测试样例：12[0,1,1,0,2,2],6返回：[0,0,1,1,2,2] 思路：类似于快排，小的放左边，大的放右边 123456789101112131415161718192021public int[] sortThreeColor(int[] arr, int n) &#123; // write code here int left = -1; int right = n; int index = 0; while (index &lt; right) &#123; if (arr[index] == 0) swap(arr, ++left, index++); // 由于前面的数已经遍历过，所以交换后可以后移即(index++) else if (arr[index] == 2) swap(arr, --right, index); // 右边的数没有遍历过，所以交换后index不增 else index++; &#125; return arr;&#125;public void swap(int[] arr, int i, int j) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"有序数组合并","slug":"有序数组合并","date":"2018-02-17T10:48:59.000Z","updated":"2018-08-24T07:13:44.641Z","comments":true,"path":"2018/02/17/有序数组合并/","link":"","permalink":"https://lierabbit.cn/2018/02/17/有序数组合并/","excerpt":"","text":"有两个从小到大排序以后的数组A和B，其中A的末端有足够的缓冲空容纳B。请编写一个方法，将B合并入A并排序。给定两个有序int数组A和B，A中的缓冲空用0填充，同时给定A和B的真实大小int n和int m，请返回合并后的数组。 思路：从后往前按序填充 12345678910111213public int[] mergeAB(int[] A, int[] B, int n, int m) &#123; // write code here while (m != 0) &#123; if (n == 0) &#123; A[m - 1] = B[m - 1]; m--; &#125; else &#123; A[m + n - 1] = A[n - 1] &gt; B[m - 1] ? A[--n] : B[--m]; &#125; &#125; return A;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"重复值判断","slug":"重复值判断","date":"2018-02-17T08:21:12.000Z","updated":"2018-08-24T07:06:17.346Z","comments":true,"path":"2018/02/17/重复值判断/","link":"","permalink":"https://lierabbit.cn/2018/02/17/重复值判断/","excerpt":"","text":"请设计一个高效算法，判断数组中是否有重复值。必须保证额外空间复杂度为O(1)。给定一个int数组A及它的大小n，请返回它是否有重复值。测试样例： 12[1,2,3,4,5,5,6],7返回：true 思路：使用堆排序后判断下一个元素是否与当前元素相等 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public boolean checkDuplicate(int[] arr, int n) &#123; // write code here makeHeap(arr); for (int i = arr.length - 1; i &gt; 0; i--) &#123; swap(arr, 0, i); adjustHeap(arr, 0, i); &#125; for (int i = 0; i &lt; arr.length - 1; i++) &#123; if (arr[i] == arr[i + 1]) return true; &#125; return false;&#125;public void makeHeap(int[] arr) &#123; for (int i = arr.length / 2 - 1; i &gt;= 0; i--) &#123; adjustHeap(arr, i, arr.length); &#125;&#125;public void adjustHeap(int[] arr, int index, int size) &#123; int max = arr[index]; for (int k = index * 2 + 1; k &lt; size; k = k * 2 + 1) &#123; if (k + 1 &lt; size &amp;&amp; arr[k] &lt; arr[k + 1]) &#123; k++; &#125; if (max &lt; arr[k]) &#123; arr[index] = arr[k]; index = k; &#125; else break; &#125; arr[index] = max;&#125;public void swap(int[] arr, int i, int j) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"小范围排序","slug":"小范围排序","date":"2018-02-13T16:44:14.000Z","updated":"2018-08-24T02:18:13.523Z","comments":true,"path":"2018/02/14/小范围排序/","link":"","permalink":"https://lierabbit.cn/2018/02/14/小范围排序/","excerpt":"","text":"已知一个几乎有序的数组，几乎有序是指，如果把数组排好顺序的话，每个元素移动的距离可以不超过k，并且k相对于数组来说比较小。请选择一个合适的排序算法针对这个数据进行排序。给定一个int数组A，同时给定A的大小n和题意中的k，请返回排序后的数组。 测试样例：12[2,1,4,3,6,5,8,7,10,9],10,2返回：[1,2,3,4,5,6,7,8,9,10] 思路：特殊版的堆排序，建立大小为K的小根堆，按照堆排序排序 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public int[] sortElement(int[] A, int n, int k) &#123; // write code here if (A == null || n &lt; 2 || n &lt; k) return A; // 获取大小为k的小根堆 int[] heap = getHeap(A, k); for (int i = k; i &lt; n; i++) &#123; A[i - k] = heap[0]; heap[0] = A[i]; adjustHeap(heap, 0, k); &#125; // 把剩余堆的值一个一个弹出 int temp; for (int i = n - k; i &lt; n; i++) &#123; A[i] = heap[0]; temp = heap[0]; heap[0] = heap[k - 1]; heap[k - 1] = temp; adjustHeap(heap, 0, --k); &#125; return A;&#125;public int[] getHeap(int[] arr, int size) &#123; int[] heap = new int[size]; for (int i = 0; i &lt; size; i++) &#123; heap[i] = arr[i]; &#125; adjustHeap(heap, 0, size); for (int i = size / 2 - 1; i &gt;= 0; i--) &#123; adjustHeap(heap, i, size); &#125; return heap;&#125;// 调整堆public void adjustHeap(int[] arr, int i, int length) &#123; int min = arr[i]; for (int k = i * 2 + 1; k &lt; length; k = k * 2 + 1) &#123; if (k + 1 &lt; length &amp;&amp; arr[k] &gt; arr[k + 1]) &#123; k++; &#125; if (min &gt; arr[k]) &#123; arr[i] = arr[k]; i = k; &#125; else &#123; break; &#125; &#125; arr[i] = min;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"基数排序","slug":"基数排序","date":"2018-02-13T16:26:46.000Z","updated":"2018-08-23T14:51:30.700Z","comments":true,"path":"2018/02/14/基数排序/","link":"","permalink":"https://lierabbit.cn/2018/02/14/基数排序/","excerpt":"","text":"对于一个int数组，请编写一个基数排序算法，对数组元素排序。给定一个int数组A及数组的大小n，请返回排序后的数组。保证元素均小于等于2000。测试样例： 12[1,2,3,5,2,3],6[1,2,2,3,3,5] 时间复杂度：O(n)空间复杂度：O(m) // m：桶的数量 思路：放置顺序的0-9号桶，将所有元素先按个位放入，按桶序倒出，再按十位放入，按桶序倒出，依次重复下去 12345678910111213141516171819202122232425262728293031323334353637public int[] radixSort(int[] A, int n) &#123; int max = A[0]; for (int a : A) &#123; max = Math.max(max, a); &#125; List&lt;List&lt;Integer&gt;&gt; boxs = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 10; i++) &#123; boxs.add(new ArrayList&lt;&gt;()); &#125; int k = 1; int index; while (max &gt; 0) &#123; for (int a : A) &#123; boxs.get(a / k % 10).add(a); &#125; index = 0; for (int i = 0; i &lt; 10; i++) &#123; List&lt;Integer&gt; box = boxs.get(i); for (int j = 0; j &lt; box.size(); j++) &#123; A[index++] = box.get(j); &#125; box.clear(); &#125; k *= 10; max /= 10; &#125; return A;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"计数排序","slug":"计数排序","date":"2018-02-13T16:22:10.000Z","updated":"2018-08-23T14:49:33.015Z","comments":true,"path":"2018/02/14/计数排序/","link":"","permalink":"https://lierabbit.cn/2018/02/14/计数排序/","excerpt":"","text":"对于一个int数组，请编写一个计数排序算法，对数组元素排序。给定一个int数组A及数组的大小n，请返回排序后的数组。测试样例： 12[1,2,3,5,2,3],6[1,2,2,3,3,5] 时间复杂度：O(n)空间复杂度：O(m) // m：桶的数量 思路：预先设置一些排好序的桶（数组），然后遍历数组将元素放入对应桶，再倒出桶里的值 12345678910111213141516171819202122232425public int[] countingSort(int[] A, int n) &#123; int min = A[0]; int max = A[0]; for (int a : A) &#123; min = Math.min(min, a); max = Math.max(max, a); &#125; int[] arr = new int[max - min + 1]; for (int a : A) &#123; arr[a - min]++; &#125; int index = 0; for (int i = 0; i &lt; arr.length; i++) &#123; while (arr[i]-- &gt; 0) &#123; A[index++] = i + min; &#125; &#125; return A;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"希尔排序","slug":"希尔排序","date":"2018-02-13T16:18:50.000Z","updated":"2018-08-23T14:49:18.623Z","comments":true,"path":"2018/02/14/希尔排序/","link":"","permalink":"https://lierabbit.cn/2018/02/14/希尔排序/","excerpt":"","text":"对于一个int数组，请编写一个希尔排序算法，对数组元素排序。给定一个int数组A及数组的大小n，请返回排序后的数组。保证元素小于等于2000。测试样例：12[1,2,3,5,2,3],6[1,2,2,3,3,5] 时间复杂度：O(nlogn)空间复杂度：O(1) 思路：动态步长的插入排序，最终步长为1 12345678910111213141516171819202122public int[] shellSort(int[] A, int n) &#123; int feet = A.length / 2; int temp; int index; while (feet &gt; 0) &#123; for (int i = feet; i &lt; A.length; i++) &#123; index = i; while (index &gt;= feet) &#123; if (A[index - feet] &gt; A[index]) &#123; temp = A[index]; A[index] = A[index - feet]; A[index - feet] = temp; index -= feet; &#125; else &#123; break; &#125; &#125; &#125; feet /= 2; &#125; return A;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"堆排序","slug":"堆排序","date":"2018-02-13T16:11:02.000Z","updated":"2018-08-23T14:44:42.579Z","comments":true,"path":"2018/02/14/堆排序/","link":"","permalink":"https://lierabbit.cn/2018/02/14/堆排序/","excerpt":"","text":"对于一个int数组，请编写一个堆排序算法，对数组元素排序。给定一个int数组A及数组的大小n，请返回排序后的数组。测试样例：12[1,2,3,5,2,3],6[1,2,2,3,3,5] 时间复杂度：O(nlogn)空间复杂度：O(1) 思路：首先建立一个大根堆。重复进行交换头尾，调整堆使其符合大根堆 123456789101112131415161718192021222324252627282930313233public int[] heapSort(int[] A, int n) &#123; //建堆 for (int i = A.length / 2 - 1; i &gt;= 0; i--) &#123; adjustHeap(A, i, A.length); &#125; int temp; //调整堆 for (int i = A.length - 1; i &gt; 0; i--) &#123; temp = A[0]; A[0] = A[i]; A[i] = temp; adjustHeap(A, 0, i); &#125; return A;&#125;public void adjustHeap(int[] arr, int i, int length) &#123; int max = arr[i]; for (int k = i * 2 + 1; k &lt; length; k = k * 2 + 1) &#123; if (k + 1 &lt; length &amp;&amp; arr[k] &lt; arr[k + 1]) &#123; k++; &#125; if (arr[k] &gt; max) &#123; arr[i] = arr[k]; i = k; &#125; else &#123; break; &#125; &#125; arr[i] = max;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"快速排序","slug":"快速排序","date":"2018-02-13T16:06:46.000Z","updated":"2018-08-23T14:41:53.705Z","comments":true,"path":"2018/02/14/快速排序/","link":"","permalink":"https://lierabbit.cn/2018/02/14/快速排序/","excerpt":"","text":"对于一个int数组，请编写一个快速排序算法，对数组元素排序。给定一个int数组A及数组的大小n，请返回排序后的数组。测试样例：12[1,2,3,5,2,3],6[1,2,2,3,3,5] 时间复杂度：O(nlogn)空间复杂度：O(logn) ~ O(n) 思路：随机获取数组内一个值，将其作为中间值，小于它的放左边，大于它的放右边。然后再对它的左边部分、右边部分分别也进行同样的操作 12345678910111213141516171819202122232425262728293031public int[] quickSort(int[] A, int n) &#123; // write code here if (A == null || A.length &lt; 2) return null; quickSort(A, 0, n - 1); return A;&#125;public void quickSort(int[] arr, int left, int right) &#123; if (left &lt; right) &#123; int mid = partition(arr, left, right); quickSort(arr, left, mid - 1); quickSort(arr, mid + 1, right); &#125;&#125;public int partition(int[] arr, int left, int right) &#123; int random = left + (int) (Math.random() * (right - left + 1)); swap(arr, random, right); int leftIndex = left - 1; int index = left; while (index &lt;= right) &#123; if (arr[index] &lt;= arr[right]) &#123; swap(arr, ++leftIndex, index); &#125; index++; &#125; return leftIndex;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"归并排序","slug":"归并排序","date":"2018-02-13T16:03:06.000Z","updated":"2018-08-23T14:39:28.169Z","comments":true,"path":"2018/02/14/归并排序/","link":"","permalink":"https://lierabbit.cn/2018/02/14/归并排序/","excerpt":"","text":"对于一个int数组，请编写一个归并排序算法，对数组元素排序。给定一个int数组A及数组的大小n，请返回排序后的数组。测试样例： 12[1,2,3,5,2,3],6[1,2,2,3,3,5] 时间复杂度：O(nlogn)空间复杂度：O(n) 思路：将数组分割成一个个独立单元，然后按序合并 1234567891011121314151617181920212223242526272829303132333435363738394041public int[] mergeSort(int[] A, int n) &#123; // write code here if (A == null || A.length &lt; 2) return null; mergeSort(A, 0, n - 1); return A;&#125;public void mergeSort(int[] array, int left, int right) &#123; if (left == right) return; int mid = (left + right) / 2; mergeSort(array, left, mid); mergeSort(array, mid + 1, right); merge(array, left, mid, right);&#125;public void merge(int[] array, int left, int mid, int right) &#123; int[] help = new int[right - left + 1]; int l = left; int r = mid + 1; int index = 0; while (l &lt;= mid &amp;&amp; r &lt;= right) &#123; if (array[l] &lt;= array[r]) help[index++] = array[l++]; else help[index++] = array[r++]; &#125; while (l &lt;= mid) &#123; help[index++] = array[l++]; &#125; while (r &lt;= right) &#123; help[index++] = array[r++]; &#125; for (int i = 0; i &lt; help.length; i++) &#123; array[left + i] = help[i]; &#125;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"插入排序","slug":"插入排序","date":"2018-02-13T15:56:24.000Z","updated":"2018-08-23T14:29:41.734Z","comments":true,"path":"2018/02/13/插入排序/","link":"","permalink":"https://lierabbit.cn/2018/02/13/插入排序/","excerpt":"","text":"对于一个int数组，请编写一个插入排序算法，对数组元素排序。给定一个int数组A及数组的大小n，请返回排序后的数组。测试样例： 12[1,2,3,5,2,3],6[1,2,2,3,3,5] 时间复杂度：O(n2)空间复杂度：O(1) 思路：在数组头构建一个已排好序的小数组，依次插入 123456789101112131415public int[] insertionSort(int[] A, int n) &#123; // write code here for (int i = 1; i &lt; n; i++) &#123; for (int j = i; j &gt; 0; j--) &#123; if (A[j] &lt; A[j - 1]) &#123; int temp = A[j]; A[j] = A[j - 1]; A[j - 1] = temp; &#125; else break; &#125; &#125; return A;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"选择排序","slug":"选择排序","date":"2018-02-13T14:56:46.000Z","updated":"2018-08-23T14:27:19.222Z","comments":true,"path":"2018/02/13/选择排序/","link":"","permalink":"https://lierabbit.cn/2018/02/13/选择排序/","excerpt":"","text":"对于一个int数组，请编写一个选择排序算法，对数组元素排序。给定一个int数组A及数组的大小n，请返回排序后的数组。测试样例：12[1,2,3,5,2,3],6[1,2,2,3,3,5] 时间复杂度：O(n2)空间复杂度：O(1) 思路：每次找出一个最大值，将其放到末尾123456789101112131415161718192021public int[] selectionSort(int[] A, int n) &#123; // write code here int maxIndex; int temp; for (int i = n - 1; i &gt; 0; i--) &#123; maxIndex = i; for (int j = 0; j &lt; i; j++) &#123; if (A[maxIndex] &lt; A[j]) &#123; maxIndex = j; &#125; &#125; if (maxIndex != i) &#123; temp = A[i]; A[i] = A[maxIndex]; A[maxIndex] = temp; &#125; &#125; return A;&#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"冒泡排序","slug":"冒泡排序","date":"2018-02-13T14:50:35.000Z","updated":"2018-08-23T14:27:32.967Z","comments":true,"path":"2018/02/13/冒泡排序/","link":"","permalink":"https://lierabbit.cn/2018/02/13/冒泡排序/","excerpt":"","text":"对于一个int数组，请编写一个冒泡排序算法，对数组元素排序。给定一个int数组A及数组的大小n，请返回排序后的数组。测试样例：12[1,2,3,5,2,3],6[1,2,2,3,3,5] 时间复杂度：O(n2)空间复杂度：O(1) 思路：与下一个数进行判断交换，使最大值沉底 12345678910111213141516public int[] bubbleSort(int[] A, int n) &#123; // write code here int temp; for (int i = n - 1; i &gt; 0; i--) &#123; for (int j = 0; j &lt; i; j++) &#123; if (A[j] &gt; A[j + 1]) &#123; temp = A[j]; A[j] = A[j + 1]; A[j + 1] = temp; &#125; &#125; &#125; return A; &#125;","categories":[{"name":"直通BAT面试算法","slug":"直通BAT面试算法","permalink":"https://lierabbit.cn/categories/直通BAT面试算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lierabbit.cn/tags/算法/"}]},{"title":"ArrayList实现原理","slug":"ArrayList实现原理","date":"2018-01-23T04:29:37.000Z","updated":"2018-08-23T11:45:28.275Z","comments":true,"path":"2018/01/23/ArrayList实现原理/","link":"","permalink":"https://lierabbit.cn/2018/01/23/ArrayList实现原理/","excerpt":"","text":"概述ArrayList可以简单的看作是动态数组，相对于普通的数组它可以动态的增加容量或者减少容量。要注意的是ArrayList并不是线程安全的，因此一般建议在单线程中使用ArrayList。 实现原理继承关系1public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable ArrayList继承AbstractList实现List, RandomAccess, Cloneable, java.io.Serializable接口 关键属性12345678910111213141516/** * The array buffer into which the elements of the ArrayList are stored. * The capacity of the ArrayList is the length of this array buffer. Any * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA * will be expanded to DEFAULT_CAPACITY when the first element is added. */// 数据的数组transient Object[] elementData; // non-private to simplify nested class access/** * The size of the ArrayList (the number of elements it contains). * * @serial */// 实际数据的数量private int size; 底层使用数组保存所有元素transient 如果用transient声明一个实例变量，当对象存储时，它的值不需要维持。换句话来说就是，用transient关键字标记的成员变量不参与序列化过程 构造方法123456789101112/** * Shared empty array instance used for default sized empty instances. We * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when * first element is added. */private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;/** * Constructs an empty list with an initial capacity of ten. */public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125; 默认情况下初始化空数组（长度为0的数组） 123456789101112131415161718192021/** * Shared empty array instance used for empty instances. */private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;/** * Constructs an empty list with the specified initial capacity. * * @param initialCapacity the initial capacity of the list * @throws IllegalArgumentException if the specified initial capacity * is negative */public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException(\"Illegal Capacity: \"+ initialCapacity); &#125;&#125; 指定数组的初始容量当指定的初始容量大于0，初始化指定大小的数组当指定的初始容量等于0，初始化空数组当指定的初始容量小于0，抛出IllegalArgumentException异常12345678910111213141516171819/** * Constructs a list containing the elements of the specified * collection, in the order they are returned by the collection's * iterator. * * @param c the collection whose elements are to be placed into this list * @throws NullPointerException if the specified collection is null */public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; &#125;&#125; 初始化指定集合的数组当指定集合不为空即长度不为0，则复制该集合，否则初始化一个空数组 E get(int index) 获取index位置的元素123456789101112131415161718192021222324252627282930313233343536373839404142// Positional Access Operations// 返回index下标的元素且强制转化为E（List&lt;E&gt;中的E）类型@SuppressWarnings(\"unchecked\")E elementData(int index) &#123; return (E) elementData[index];&#125;/** * Returns the element at the specified position in this list. * * @param index index of the element to return * @return the element at the specified position in this list * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */public E get(int index) &#123; // 检查index是否越界 rangeCheck(index); // 返回index下标的元素 return elementData(index);&#125;/** * Checks if the given index is in range. If not, throws an appropriate * runtime exception. This method does *not* check if the index is * negative: It is always used immediately prior to an array access, * which throws an ArrayIndexOutOfBoundsException if index is negative. */private void rangeCheck(int index) &#123; // 检查index是否大于等于size（数组的元素数量），因为数组下标从0开始计算，所以也不能等于元素数量 // 这里没有检查index &lt; 0的情况，因为index &lt; 0时数组会自动抛出异常，所以并未检查index&lt;0的情况 if (index &gt;= size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index));&#125;/** * Constructs an IndexOutOfBoundsException detail message. * Of the many possible refactorings of the error handling code, * this \"outlining\" performs best with both server and client VMs. */private String outOfBoundsMsg(int index) &#123; return \"Index: \"+index+\", Size: \"+size;&#125; 首先判断index是否越界，这里并没有判断是否小于0，因为下标小于0时数组会抛出异常。越界则抛出IndexOutOfBoundsException异常，反之返回数组对应index位置的元素 E set(int index, E element) 设置（覆盖）index位置的元素12345678910111213141516/** * Replaces the element at the specified position in this list with * the specified element. * * @param index index of the element to replace * @param element element to be stored at the specified position * @return the element previously at the specified position * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */public E set(int index, E element) &#123; rangeCheck(index); E oldValue = elementData(index); elementData[index] = element; return oldValue;&#125; 和get一样先判断index（下标）是否越界，不越界则先获取原来index位置上的元素，接着设置（覆盖）index位置上的元素，然后返回原来的元素，反之抛出IndexOutOfBoundsException异常 boolean add(E e) 添加一个元素到列表尾123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/** * Appends the specified element to the end of this list. * * @param e element to be appended to this list * @return &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;@link Collection#add&#125;) */public boolean add(E e) &#123; // 检查当前容量是否还可以容纳一个元素，不够则扩容 ensureCapacityInternal(size + 1); // Increments modCount!! // 添加到数组末尾 // 这个语句可以分解为 // elementData[size] = e; // size += 1; elementData[size++] = e; return true;&#125;/** * Default initial capacity. */private static final int DEFAULT_CAPACITY = 10; // 默认容量为10// 如果数据等于默认数据，返回默认容量和minCapacity（所需容量最小值）的最大值，反之返回所需容量最小值private static int calculateCapacity(Object[] elementData, int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; return Math.max(DEFAULT_CAPACITY, minCapacity); &#125; return minCapacity;&#125;private void ensureCapacityInternal(int minCapacity) &#123; ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));&#125;private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // 操作数+1 // overflow-conscious code // 如果所需容量最小值大于实际数组的长度就扩大实际数组容量 if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125;/** * The maximum size of array to allocate. * Some VMs reserve some header words in an array. * Attempts to allocate larger arrays may result in * OutOfMemoryError: Requested array size exceeds VM limit */private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; // 数组最大容量为Integer最大值-8/** * Increases the capacity to ensure that it can hold at least the * number of elements specified by the minimum capacity argument. * * @param minCapacity the desired minimum capacity */private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; // 新的容量为旧的容量的1.5倍 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); // 如果扩充容量后还是不够，则新的容量等于所需容量最小值（一般就是数组实际元素个数） if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; // 如果新的容量大于数组最大容量，再调用hugeCapacity计算新的容量 if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: // 复制原来的数据到新的数组，数组容量为新的容量 elementData = Arrays.copyOf(elementData, newCapacity);&#125;private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); // 大于数组最大容量返回Integer最大值，反之返回数组最大容量 return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;&#125; 添加一个元素到列表尾，当列表容量不足时自动扩容（通常是扩容至原来的1.5倍），添加成功返回true void add(int index, E element) 在index处放置元素123456789101112131415161718192021222324252627282930/** * Inserts the specified element at the specified position in this * list. Shifts the element currently at that position (if any) and * any subsequent elements to the right (adds one to their indices). * * @param index index at which the specified element is to be inserted * @param element element to be inserted * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */public void add(int index, E element) &#123; // 检查下标是否越界 rangeCheckForAdd(index); // 检查当前容量是否还可以在容纳一个元素，不够则扩容 ensureCapacityInternal(size + 1); // Increments modCount!! // 将elementData从index开始后面的元素往后移一位 System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++;&#125;/** * A version of rangeCheck used by add and addAll. */private void rangeCheckForAdd(int index) &#123; // 当index等于size时相当于添加元素到列表尾 if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException(outOfBoundsMsg(index));&#125; 将elementData数组从index开始后面的元素往后移一位，接着在index处放置元素模拟添加数据(lierabbit)到index=4过程如下1 初始数组 0 1 2 3 4 5 6 7 8 9 a b c d e f g h i j 2 从index开始后面的元素往后移一位 0 1 2 3 4 5 6 7 8 9 a b c d e e f g h i 3 在index处放置lierabbit 0 1 2 3 4 5 6 7 8 9 a b c d lierabbit e f g h i boolean addAll(Collection&lt;? extends E&gt; c) 添加一个集合里的所有元素到列表尾123456789101112131415161718192021222324/** * Appends all of the elements in the specified collection to the end of * this list, in the order that they are returned by the * specified collection's Iterator. The behavior of this operation is * undefined if the specified collection is modified while the operation * is in progress. (This implies that the behavior of this call is * undefined if the specified collection is this list, and this * list is nonempty.) * * @param c collection containing elements to be added to this list * @return &lt;tt&gt;true&lt;/tt&gt; if this list changed as a result of the call * @throws NullPointerException if the specified collection is null */public boolean addAll(Collection&lt;? extends E&gt; c) &#123; Object[] a = c.toArray(); int numNew = a.length; // 检查当前容量是否还可以在容纳a数组的元素，不够则扩容 ensureCapacityInternal(size + numNew); // Increments modCount // 将a数组里的元素添加到elementData末尾 System.arraycopy(a, 0, elementData, size, numNew); size += numNew; // a数组不为空（长度不为0）时返回true，反之false return numNew != 0;&#125; 将要添加的集合变为数组，然后将其复制到elementData数组末尾 boolean addAll(int index, Collection&lt;? extends E&gt; c) 添加一个集合里的所有元素到index位置123456789101112131415161718192021222324252627282930313233343536/** * Inserts all of the elements in the specified collection into this * list, starting at the specified position. Shifts the element * currently at that position (if any) and any subsequent elements to * the right (increases their indices). The new elements will appear * in the list in the order that they are returned by the * specified collection's iterator. * * @param index index at which to insert the first element from the * specified collection * @param c collection containing elements to be added to this list * @return &lt;tt&gt;true&lt;/tt&gt; if this list changed as a result of the call * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; * @throws NullPointerException if the specified collection is null */public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; // 检查下标是否越界 rangeCheckForAdd(index); Object[] a = c.toArray(); int numNew = a.length; // 检查当前容量是否还可以在容纳a数组的元素，不够则扩容 ensureCapacityInternal(size + numNew); // Increments modCount // 需要往后移动几个位置 int numMoved = size - index; if (numMoved &gt; 0) // 从index开始，往后的元素向后移动numMoved个位置 System.arraycopy(elementData, index, elementData, index + numNew, numMoved); // 将a数组里的所有元素复制到elementData从index到index + numNew -1的位置上 System.arraycopy(a, 0, elementData, index, numNew); size += numNew; // a数组不为空（长度不为0）时返回true，反之false return numNew != 0;&#125; 将要添加的集合变为数组，然后把elementData数组从index开始，往后的元素向后移动numMoved个位置，接着将要添加的数组里的所有元素复制到elementData从index到index + numNew -1的位置上 void trimToSize() 改变列表内部数组容量至列表实际元素数量123456789101112131415/** * Trims the capacity of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance to be the * list's current size. An application can use this operation to minimize * the storage of an &lt;tt&gt;ArrayList&lt;/tt&gt; instance. */public void trimToSize() &#123; modCount++; // 操作数+1 // 如果数组实际元素数量小于数组长度 if (size &lt; elementData.length) &#123; // 如果数组实际元素数量等于0则数组被赋值为空数组，反之创建一个新的元素数量等于数组长度的数组 elementData = (size == 0) ? EMPTY_ELEMENTDATA : Arrays.copyOf(elementData, size); &#125;&#125; 当数据稳定了之后可以使用这个方法来减少内存的使用 int indexOf(Object o) 查找o元素在列表第一次出现的位置123456789101112131415161718192021/** * Returns the index of the first occurrence of the specified element * in this list, or -1 if this list does not contain the element. * More formally, returns the lowest index &lt;tt&gt;i&lt;/tt&gt; such that * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt;, * or -1 if there is no such index. */public int indexOf(Object o) &#123; //元素可以为null，如果为null返回null的下标 if (o == null) &#123; for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; &#125; else &#123; for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; &#125; // 没有找到对应的元素返回-1 return -1;&#125; ArrayList中可以存放null元素，indexof是返回elementData数组中值相同的首个元素的下标，indexof中比较方法是equals而equals是比较元素的值，因此必须对null单独查找。如果未找到该元素则返回-1 E remove(int index) 删除index位置上的元素1234567891011121314151617181920212223242526/** * Removes the element at the specified position in this list. * Shifts any subsequent elements to the left (subtracts one from their * indices). * * @param index the index of the element to be removed * @return the element that was removed from the list * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */public E remove(int index) &#123; // 检查下标是否越界 rangeCheck(index); modCount++; // 操作数+1 E oldValue = elementData(index); // 获取index位置上的元素 int numMoved = size - index - 1; // 需要往前移动几个位置 if (numMoved &gt; 0) // 从index + 1开始，往后的元素向前移动1个位置 System.arraycopy(elementData, index+1, elementData, index, numMoved); // 将数组末尾元素置空 elementData[--size] = null; // clear to let GC do its work return oldValue;&#125; 模拟删除index=4（值为lierabbit）过程如下1 初始数组 0 1 2 3 4 5 6 7 8 9 a b c d lierabbit f g h i j 2 从index + 1（即index=5，值为f）开始，往后的元素向前移动1个位置 0 1 2 3 4 5 6 7 8 9 a b c d f g h i j j 3 将数组末尾元素置空 0 1 2 3 4 5 6 7 8 9 a b c d f g h i j null boolean remove(Object o) 删除o元素123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * Removes the first occurrence of the specified element from this list, * if it is present. If the list does not contain the element, it is * unchanged. More formally, removes the element with the lowest index * &lt;tt&gt;i&lt;/tt&gt; such that * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt; * (if such an element exists). Returns &lt;tt&gt;true&lt;/tt&gt; if this list * contained the specified element (or equivalently, if this list * changed as a result of the call). * * @param o element to be removed from this list, if present * @return &lt;tt&gt;true&lt;/tt&gt; if this list contained the specified element */public boolean remove(Object o) &#123; // 元素可以为null，分开搜索o if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; // 没有找到返回false return false;&#125;/* * Private remove method that skips bounds checking and does not * return the value removed. */// 由于已经找到元素，则元素必定存在，则index必定合理，所以不需要在检查index是否越界private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work&#125; 通过寻找o元素，可以获得其下标，再根据下标删除o元素 forEach(Consumer&lt;? super E&gt; action)遍历列表12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * The number of times this list has been &lt;i&gt;structurally modified&lt;/i&gt;. * Structural modifications are those that change the size of the * list, or otherwise perturb it in such a fashion that iterations in * progress may yield incorrect results. * * &lt;p&gt;This field is used by the iterator and list iterator implementation * returned by the &#123;@code iterator&#125; and &#123;@code listIterator&#125; methods. * If the value of this field changes unexpectedly, the iterator (or list * iterator) will throw a &#123;@code ConcurrentModificationException&#125; in * response to the &#123;@code next&#125;, &#123;@code remove&#125;, &#123;@code previous&#125;, * &#123;@code set&#125; or &#123;@code add&#125; operations. This provides * &lt;i&gt;fail-fast&lt;/i&gt; behavior, rather than non-deterministic behavior in * the face of concurrent modification during iteration. * * &lt;p&gt;&lt;b&gt;Use of this field by subclasses is optional.&lt;/b&gt; If a subclass * wishes to provide fail-fast iterators (and list iterators), then it * merely has to increment this field in its &#123;@code add(int, E)&#125; and * &#123;@code remove(int)&#125; methods (and any other methods that it overrides * that result in structural modifications to the list). A single call to * &#123;@code add(int, E)&#125; or &#123;@code remove(int)&#125; must add no more than * one to this field, or the iterators (and list iterators) will throw * bogus &#123;@code ConcurrentModificationExceptions&#125;. If an implementation * does not wish to provide fail-fast iterators, this field may be * ignored. */protected transient int modCount = 0;//操作数@Overridepublic void forEach(Consumer&lt;? super E&gt; action) &#123; // 确保不为空 Objects.requireNonNull(action); final int expectedModCount = modCount; @SuppressWarnings(\"unchecked\") final E[] elementData = (E[]) this.elementData; final int size = this.size; for (int i=0; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123; action.accept(elementData[i]); &#125; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125;&#125;/** * Checks that the specified object reference is not &#123;@code null&#125;. This * method is designed primarily for doing parameter validation in methods * and constructors, as demonstrated below: * &lt;blockquote&gt;&lt;pre&gt; * public Foo(Bar bar) &#123; * this.bar = Objects.requireNonNull(bar); * &#125; * &lt;/pre&gt;&lt;/blockquote&gt; * * @param obj the object reference to check for nullity * @param &lt;T&gt; the type of the reference * @return &#123;@code obj&#125; if not &#123;@code null&#125; * @throws NullPointerException if &#123;@code obj&#125; is &#123;@code null&#125; */public static &lt;T&gt; T requireNonNull(T obj) &#123; if (obj == null) throw new NullPointerException(); return obj;&#125; 这里可以看到modCount的用处，当modCount发生改变后，立刻抛出ConcurrentModificationException异常。通过之前的分析可以知道当列表内容被修改时modCount会增加。也就是说如果在遍历ArrayList的过程中有其他线程修改了ArrayList，那么将抛出ConcurrentModificationException异常 ArrayList小结 ArrayList是List接口的一个可变大小的数组的实现 ArrayList的内部是使用一个Object对象数组来存储元素的 初始化ArrayList的时候，可以指定初始化容量的大小，如果不指定，就会使用默认大小，为10 当添加一个新元素的时候，首先会检查容量是否足够添加这个元素，如果够就直接添加，如果不够就进行扩容，扩容为原数组容量的1.5倍 当在index处放置一个元素的时候，会将数组index处右边的元素全部右移 当在index处删除一个元素的时候，会将数组index处右边的元素全部左移","categories":[{"name":"Java从深入到放弃","slug":"Java从深入到放弃","permalink":"https://lierabbit.cn/categories/Java从深入到放弃/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://lierabbit.cn/tags/Java/"}]},{"title":"SpringBoot快速入门6-thymeleaf","slug":"SpringBoot快速入门6-thymeleaf","date":"2018-01-21T13:48:52.000Z","updated":"2018-08-23T13:42:57.927Z","comments":true,"path":"2018/01/21/SpringBoot快速入门6-thymeleaf/","link":"","permalink":"https://lierabbit.cn/2018/01/21/SpringBoot快速入门6-thymeleaf/","excerpt":"","text":"静态资源在我们开发Web应用的时候，需要引用大量的js、css、图片等静态资源。Spring Boot的默认位置是resources/static 模版页面各种模版的页面，这次我们选用ThymeleafSpring Boot的默认位置是resources/templates 渲染页面在之前的示例中，我们都是通过@RestController来处理请求，所以返回的内容为json对象。当我们需要页面的时候使用@Controller，使其寻找模版页面 添加依赖对于已存在的项目可以在bulid.gradle加入12compile(&apos;org.springframework.boot:spring-boot-starter-thymeleaf&apos;)compile(&apos;org.springframework.boot:spring-boot-starter-web&apos;) 至此Thymeleaf已经引入 创建控制器新建一个ThymeleafCtrl类1234567891011121314import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;@Controller//这是一个控制器public class ThymeleafCtrl&#123; @RequestMapping(\"/\") public String hello(Model model) &#123; model.addAttribute(\"hello\",\"hello thymeleaf\");//添加一个值为\"hello thymeleaf\"的hello变量到视图 return \"hello\";//在templates下寻找hello.html &#125;&#125; 创建模版页面在resources/templates创建一个hello.html页面1234567891011&lt;!DOCTYPE html&gt;&lt;html xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;!-- xmlns:th=\"http://www.thymeleaf.org\" 减少ide报错，可以没有 --&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"/&gt; &lt;title&gt;Hello&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 th:text=\"$&#123;hello&#125;\"&gt;LieRabbit&lt;/h1&gt;&lt;!-- 使用hello变量 --&gt;&lt;img src=\"lierabbit.jpg\"/&gt;&lt;/body&gt;&lt;/html&gt; 添加图片资源在resources/static添加lierabbit.jpg 运行结果更多的Thymeleaf的语法请前往官网查看文档（http://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html）源码地址：https://github.com/LieRabbit/SpringBoot-thymeleaf","categories":[{"name":"Spring Boot快速入门","slug":"Spring-Boot快速入门","permalink":"https://lierabbit.cn/categories/Spring-Boot快速入门/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://lierabbit.cn/tags/Spring-Boot/"}]},{"title":"SpringBoot快速入门5-使用MyBatis（注解形式）进行数据库操作","slug":"SpringBoot快速入门5-使用MyBatis（注解形式）进行数据库操作","date":"2018-01-17T01:31:07.000Z","updated":"2018-08-23T13:35:33.566Z","comments":true,"path":"2018/01/17/SpringBoot快速入门5-使用MyBatis（注解形式）进行数据库操作/","link":"","permalink":"https://lierabbit.cn/2018/01/17/SpringBoot快速入门5-使用MyBatis（注解形式）进行数据库操作/","excerpt":"","text":"添加依赖新建项目选择web,MyBatis,MySQL三个依赖 对于已存在的项目可以在bulid.gradle加入，spring boot将会帮你自动配置好1234compile(&apos;org.springframework.boot:spring-boot-starter-data-jpa&apos;)compile(&apos;org.springframework.boot:spring-boot-starter-web&apos;)runtime(&apos;mysql:mysql-connector-java&apos;)testCompile(&apos;org.springframework.boot:spring-boot-starter-test&apos;) 配置基本信息然后在src/main/resources/application.properties下添加基本配置12345678#数据库连接地址spring.datasource.url=jdbc:mysql://localhost:3306/mybaits?useSSL=false#数据库账号spring.datasource.username=root#数据库密码spring.datasource.password=123456zxc#数据库驱动spring.datasource.driver-class-name=com.mysql.jdbc.Driver 创建实体创建一个User实体，包含id、name（姓名）、age（年龄）属性12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class User&#123; private Long id; private String name; private Integer age; public User() &#123; &#125; public User(String name, Integer age) &#123; this.name = name; this.age = age; &#125; public Long getId() &#123; return id; &#125; public void setId(Long id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125;&#125; 创建数据访问接口创建一个userMapper接口，进行数据库操作，添加@Mapper注解12345678910111213141516171819202122232425import org.apache.ibatis.annotations.*;import java.util.List;@Mapper//这是一个MyBatis的数据库操作接口public interface UserMapper&#123; @Select(\"SELECT * FROM user WHERE name = #&#123;name&#125;\") User findByName(@Param(\"name\") String name); @Select(\"SELECT * FROM user WHERE name LIKE #&#123;name&#125;\") List&lt;User&gt; findByNameLike(@Param(\"name\") String name); @Insert(\"INSERT INTO user(name, age) VALUES(#&#123;name&#125;, #&#123;age&#125;)\") int insert(@Param(\"name\") String name, @Param(\"age\") Integer age); @Update(\"UPDATE user SET age = #&#123;age&#125; WHERE name = #&#123;name&#125;\") int update(@Param(\"name\") String name, @Param(\"age\") Integer age); @Delete(\"DELETE FROM user WHERE name = #&#123;name&#125;\") int delete(@Param(\"name\") String name); @Select(\"SELECT COUNT(*) FROM user\") int countAll();&#125; 单元测试在src/test/java/你的包名/你的项目名ApplicationTests编写对应的单元测试来验证编写的内容是否正确12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import org.junit.Assert;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.annotation.Rollback;import org.springframework.test.context.junit4.SpringRunner;import org.springframework.transaction.annotation.Transactional;@RunWith(SpringRunner.class)@SpringBootTest@Transactional//声明事务，配合Rollbackpublic class MybatisApplicationTests&#123; @Autowired private UserMapper userMapper; @Test @Rollback//测试结束回滚数据，保证测试单元每次运行的数据环境独立 public void testUser() &#123; userMapper.insert(\"QQQ\",1); userMapper.insert(\"WWW\",2); userMapper.insert(\"EEE\",3); userMapper.insert(\"AAA\",4); userMapper.insert(\"SSS\",5); userMapper.insert(\"DDD\",6); userMapper.insert(\"ZZZ\",7); userMapper.insert(\"XXX\",8); userMapper.insert(\"CCC\",9); userMapper.insert(\"SSS213\",10); // 测试findAll, 查询所有记录 Assert.assertEquals(10, userMapper.countAll()); // 测试findByName, 查询姓名为AAA的User Assert.assertEquals(4, userMapper.findByName(\"AAA\").getAge().longValue()); // 更新CCC用户的年龄为15 userMapper.update(\"CCC\",15); // 测试findByName, 查询姓名为CCC的User的年龄是否为15 Assert.assertEquals(15, userMapper.findByName(\"CCC\").getAge().longValue()); // 测试删除姓名为AAA的User userMapper.delete(\"AAA\"); // 测试findAll, 查询所有记录, 验证上面的删除是否成功 Assert.assertEquals(9, userMapper.countAll()); // 测试findAll, 查询名字有S的有几个 Assert.assertEquals(2,userMapper.findByNameLike(\"%S%\").size()); &#125;&#125; 测试结果 源码地址：https://github.com/LieRabbit/SpringBoot-mybatis","categories":[{"name":"Spring Boot快速入门","slug":"Spring-Boot快速入门","permalink":"https://lierabbit.cn/categories/Spring-Boot快速入门/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://lierabbit.cn/tags/Spring-Boot/"}]},{"title":"SpringBoot快速入门4-使用jpa进行数据库操作","slug":"SpringBoot快速入门4-使用jpa进行数据库操作","date":"2018-01-15T15:49:41.000Z","updated":"2018-08-23T13:34:32.648Z","comments":true,"path":"2018/01/15/SpringBoot快速入门4-使用jpa进行数据库操作/","link":"","permalink":"https://lierabbit.cn/2018/01/15/SpringBoot快速入门4-使用jpa进行数据库操作/","excerpt":"","text":"添加依赖新建项目选择web,JPA,MySQL三个依赖 对于已存在的项目可以在bulid.gradle加入，spring boot将会帮你自动配置好 123compile(&apos;org.springframework.boot:spring-boot-starter-data-jpa&apos;)compile(&apos;org.springframework.boot:spring-boot-starter-web&apos;)runtime(&apos;mysql:mysql-connector-java&apos;) 配置基本信息然后在src/main/resources/application.properties下添加基本配置123456789101112#数据库连接地址spring.datasource.url=jdbc:mysql://localhost:3306/jpa?useSSL=false#数据库账号spring.datasource.username=root#数据库密码spring.datasource.password=123456zxc#数据库驱动spring.datasource.driver-class-name=com.mysql.jdbc.Driver#jpa设置spring.jpa.hibernate.ddl-auto=create#是否在控制台显示数据库语句spring.jpa.show-sql=true spring.jpa.properties.hibernate.hbm2ddl.auto 其作用是：自动创建、更新、验证数据库表结构。该参数的几种配置如下： create：每次加载hibernate时都会删除上一次的生成的表，然后根据你的model类再重新来生成新表，哪怕两次没有任何改变也要这样执行，这就是导致数据库表数据丢失的一个重要原因。 create-drop：每次加载hibernate时根据model类生成表，但是sessionFactory一关闭,表就自动删除。 update：最常用的属性，第一次加载hibernate时根据model类会自动建立起表的结构（前提是先建立好数据库），以后加载hibernate时根据model类自动更新表结构，即使表结构改变了但表中的行仍然存在不会删除以前的行。要注意的是当部署到服务器后，表结构是不会被马上建立起来的，是要等应用第一次运行起来后才会。 validate：每次加载hibernate时，验证创建数据库表结构，只会和数据库中的表进行比较，不会创建新表，但是会插入新值。 none：什么都不做至此基本配置完成 创建实体创建一个User实体，包含id（主键）、name（姓名）、age（年龄）属性，通过ORM框架其会被映射到数据库表中，由于配置了hibernate.hbm2ddl.auto，在应用启动的时候框架会自动去数据库中创建对应的表。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import javax.persistence.Column;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.Id;@Entity//这是一个和数据库表相关联的类public class User&#123; @Id//主键 @GeneratedValue//自增长 private Long id;//id @Column(length = 30)//长度30 private String name;//名称 @Column(nullable = false)//不可空 private Integer age;//年龄 public User() &#123; &#125; public User(String name, Integer age) &#123; this.name = name; this.age = age; &#125; public Long getId() &#123; return id; &#125; public void setId(Long id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125;&#125; 创建数据访问接口创建一个userRepository接口，进行数据库操作 12345678910111213141516171819202122232425import org.springframework.data.jpa.repository.JpaRepository;import org.springframework.data.jpa.repository.Query;import org.springframework.data.repository.query.Param;import java.util.List;public interface UserRepository extends JpaRepository&lt;User, Long&gt;//JpaRepository&lt;实体类型，主键类型&gt;&#123; // 通过名称找到用户 User findByName(String name); // 通过名称和年龄找到用户 User findByNameAndAge(String name, Integer age); // 通过名称模糊查询 List&lt;User&gt; findByNameLike(String name); // 使用hql查询 @Query(\"from User u where u.name=:name\")//:name对应@Param里的name User findByHQL(@Param(\"name\") String name); // 使用sql查询 @Query(value = \"select * from user where name = ?1 and age = ?2\", nativeQuery = true)//?1表示第一个参数，?2表示第二个参数 User findBySQL(String name, Integer age);&#125; 单元测试在src/test/java/你的包名/你的项目名ApplicationTests编写对应的单元测试来验证编写的内容是否正确 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import org.junit.Assert;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;@RunWith(SpringRunner.class)@SpringBootTestpublic class JpaLearnApplicationTests&#123; // 注入userRepository @Autowired private UserRepository userRepository; @Test public void contextLoads() &#123; // 添加10个测试用例 userRepository.save(new User(\"QQQ\",1)); userRepository.save(new User(\"WWW\",2)); userRepository.save(new User(\"EEE\",3)); userRepository.save(new User(\"AAA\",4)); userRepository.save(new User(\"SSS\",5)); userRepository.save(new User(\"DDD\",6)); userRepository.save(new User(\"ZZZ\",7)); userRepository.save(new User(\"XXX\",8)); userRepository.save(new User(\"CCC\",9)); userRepository.save(new User(\"QQQ2\",10)); // 测试findAll, 查询所有记录 Assert.assertEquals(10, userRepository.findAll().size()); // 测试findByName, 查询姓名为AAA的User Assert.assertEquals(4, userRepository.findByName(\"AAA\").getAge().longValue()); // 测试findByHQL, 查询姓名为AAA的User Assert.assertEquals(4, userRepository.findByHQL(\"AAA\").getAge().longValue()); // 测试findByNameAndAge, 查询姓名为SSS并且年龄为5的User Assert.assertEquals(\"SSS\", userRepository.findByNameAndAge(\"SSS\", 5).getName()); // 测试findBySQL, 查询姓名为SSS并且年龄为5的User Assert.assertEquals(\"SSS\", userRepository.findBySQL(\"SSS\", 5).getName()); // 测试删除姓名为AAA的User userRepository.delete(userRepository.findByName(\"AAA\")); // 测试findAll, 查询所有记录, 验证上面的删除是否成功 Assert.assertEquals(9, userRepository.findAll().size()); // 测试findAll, 查询名字有Q的有几个 Assert.assertEquals(2,userRepository.findByNameLike(\"%Q%\").size()); &#125;&#125; 点击运行测试用例 源码地址：https://github.com/LieRabbit/SpringBoot-jpa-learn","categories":[{"name":"Spring Boot快速入门","slug":"Spring-Boot快速入门","permalink":"https://lierabbit.cn/categories/Spring-Boot快速入门/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://lierabbit.cn/tags/Spring-Boot/"}]},{"title":"SpringBoot快速入门3-依赖注入","slug":"SpringBoot快速入门3-依赖注入","date":"2018-01-15T14:48:05.000Z","updated":"2018-08-23T13:33:44.285Z","comments":true,"path":"2018/01/15/SpringBoot快速入门3-依赖注入/","link":"","permalink":"https://lierabbit.cn/2018/01/15/SpringBoot快速入门3-依赖注入/","excerpt":"","text":"spring boot使用依赖注入的方式很简单，只需要给添加相应的注解即可 @Service用于标注业务层组件 @Controller用于标注控制层组件 @Repository用于标注数据访问组件，即DAO组件 @Component泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。然后在使用的地方使用@Autowired即可 创建MyComponent，使用@Component12345678910import org.springframework.stereotype.Component;@Component//泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。public class MyComponent&#123; public void hi(String name) &#123; System.out.println(\"hi \" + name + \",I am MyComponent\"); &#125;&#125; 创建MyController，使用@Controller12345678910import org.springframework.stereotype.Controller;@Controller//用于标注控制层组件public class MyController&#123; public void hi(String name) &#123; System.out.println(\"hi \" + name + \",I am MyController\"); &#125;&#125; 创建MyRepository，使用@Repository12345678@Repository//用于标注数据访问组件，即DAO组件public class MyRepository&#123; public void hi(String name) &#123; System.out.println(\"hi \" + name + \",I am MyRepository\"); &#125;&#125; 创建MyService，MyServiceImpl，使用@Service1234public interface MyService&#123; void doSomeThing();&#125; 123456789101112import org.springframework.stereotype.Service;@Service//用于标注业务层组件public class MyServiceImpl implements MyService&#123; @Override public void doSomeThing() &#123; System.out.println(\"i am MyServiceImpl\"); &#125;&#125; 单元测试在src/test/java/你的包名/你的项目名ApplicationTests编写对应的单元测试来验证是否可以成功注入 1234567891011121314151617181920212223242526272829import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;@RunWith(SpringRunner.class)@SpringBootTestpublic class DiApplicationTests&#123; @Autowired//自动注入 private MyController myController; @Autowired//自动注入 private MyRepository myRepository; @Autowired//自动注入 private MyComponent myComponent; @Autowired//自动注入实现了该接口的bean private MyService myService; @Test public void contextLoads() &#123; myController.hi(\"lierabbit\"); myRepository.hi(\"lierabbit\"); myComponent.hi(\"lierabbit\"); myService.doSomeThing(); &#125;&#125; 运行测试用例显示红圈的4句话证明成功注入 源码地址：https://github.com/LieRabbit/SpringBoot-DI","categories":[{"name":"Spring Boot快速入门","slug":"Spring-Boot快速入门","permalink":"https://lierabbit.cn/categories/Spring-Boot快速入门/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://lierabbit.cn/tags/Spring-Boot/"}]},{"title":"SpringBoot快速入门2-Http请求","slug":"SpringBoot快速入门2-Http请求","date":"2018-01-14T12:05:08.000Z","updated":"2018-08-23T13:32:36.598Z","comments":true,"path":"2018/01/14/SpringBoot快速入门2-Http请求/","link":"","permalink":"https://lierabbit.cn/2018/01/14/SpringBoot快速入门2-Http请求/","excerpt":"","text":"准备postman：一个接口测试工具创建一个新工程 选择web不会的请看Spring Boot快速入门（一）：Hello Spring Boot 开始新建java类RequestCtrl 添加一个all方法，使用@RequestMapping注解，可以处理所有的http请求 123456789@RestController//这是一个控制器并只返回数据不寻找视图public class RequestCtrl&#123; @RequestMapping(\"/\")//将本方法映射到/ public String all(String name, Integer age)//接受2个参数,name和age &#123; return \"这里是all\\n\" + \"name: \" + name + \"\\n\" + \"age: \" + age; &#125;&#125; requestMapping的作用可以简单理解为给方法加个地址，让别人能访问 通过源码可以看出@RestController是@Controller和ResponseBody的结合注解@Controller 表明这是一个控制器，将会返回数据或者页面@ResponseBody 表明只会返回数据，Spring Boot默认将数据使用jaskson序列化为json返回JSON(JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式，常见表现形式为键值对{key:value}，例如{name:”lierabbit”,age:20}，字符串和数字直接返回启动程序，打开postman对http://localhost:8080发起get请求 发起带参数的请求 使用post请求 添加一个get方法，使用@GetMapping注解，只可以处理get类型的http请求12345@GetMapping(\"/get\")//将本方法映射到/get，且只能用get方式访问public String get(String name, int age)//接受2个参数,name和age&#123; return \"这里是get\\n\" + \"name: \" + name + \"\\n\" + \"age: \" + age;&#125; 使用get方式访问http://localhost:8080/get?name=lierabbit&amp;age=20 尝试使用post访问，将得到405异常 添加一个post方法，使用@PostMapping注解，只可以处理post类型的http请求12345@PostMapping(\"/post\")//将本方法映射到/post，且只能用post方式访问public String post(String name, int age)//接受2个参数,name和age&#123; return \"这里是post\\n\" + \"name: \" + name + \"\\n\" + \"age: \" + age;&#125; 使用post方式访问 尝试使用get访问，得到405异常 添加一个put方法，使用@PutMapping注解，只可以处理put类型的http请求12345678@PutMapping(\"/put\")//将本方法映射到/put，且只能用put方式访问public User put(@RequestBody User user)//接受一个user实体&#123; user.setName(\"名字已经被修改：\" + user.getName()); user.setAge(user.getAge() + 1); return user;&#125;@RequestBody 表示接受一个user实体（user json） 返回User，会被spring boot自动序列化为json 添加一个delete方法，使用@DeleteMapping注解，只可以处理delete类型的http请求1234567@DeleteMapping(\"/delete\")//将本方法映射到/delete，且只能用delete方式访问public User delete(@RequestBody User user)//接受一个user实体&#123; user.setName(\"这个用户将会被删除：\" + user.getName()); user.setAge(user.getAge() + 1); return user;&#125; 添加一个patch方法，使用@PatchMapping注解，只可以处理patch类型的http请求123456@PatchMapping(\"/patch\")//将本方法映射到/patch，且只能用patch方式访问public User pathch(@RequestBody User user)//接受一个user实体&#123; user.setName(\"只改名称：\" + user.getName()); return user;&#125; 源码地址：https://github.com/LieRabbit/SpringBoot-request","categories":[{"name":"Spring Boot快速入门","slug":"Spring-Boot快速入门","permalink":"https://lierabbit.cn/categories/Spring-Boot快速入门/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://lierabbit.cn/tags/Spring-Boot/"}]},{"title":"升级node与npm","slug":"升级node与npm","date":"2018-01-14T09:48:54.000Z","updated":"2018-08-23T14:14:41.738Z","comments":true,"path":"2018/01/14/升级node与npm/","link":"","permalink":"https://lierabbit.cn/2018/01/14/升级node与npm/","excerpt":"","text":"升级node安装 n 工具，这个工具的名称很短，方便输入npm install -g n 升级node至长期版或者最新版上图为node中文官网的截图123n lts //升级到LTS版本，即上图的8.9.4n stable //升级到最新稳定版，即上图的9.4.0 n工具其它的一些命令123456789101112n 输出已安装的node版本n latest 安装最新的node版本n stable 安装最新稳定的node版本n lts 安装最新LTS的node版本n &lt;version&gt; 安装指定的node版本n bin &lt;version&gt; 输出指定的node的位置n rm &lt;version ...&gt; 删除指定的node版本n prune 删除除了当前node版本之外的所有版本n --latest 输出最新的node版本n --stable 输出最新稳定的node版本n --lts 输出最新LTS的node版本n ls 输出所有node版本 升级npm1npm install -g npm 一句话解决","categories":[],"tags":[{"name":"node.js","slug":"node-js","permalink":"https://lierabbit.cn/tags/node-js/"}]},{"title":"SpringBoot快速入门1-HelloSpringBoot","slug":"SpringBoot快速入门1-HelloSpringBoot","date":"2018-01-12T09:07:21.000Z","updated":"2018-08-23T13:30:48.533Z","comments":true,"path":"2018/01/12/SpringBoot快速入门1-HelloSpringBoot/","link":"","permalink":"https://lierabbit.cn/2018/01/12/SpringBoot快速入门1-HelloSpringBoot/","excerpt":"","text":"一、准备工作java环境：jdk 1.8开发工具：idea 二、创建项目打开idea 点击Create New Project 选择Spring Initializr，Next Group.Artifact = 你的包名type：个人喜欢选择gradle，默认的maven也可以Next 选择webNext 选择工程目录Finish 如果目录不存在，Idea将帮你创建，点击ok就行 如果没有下载过gradle，默认选择就行，点ok如果想使用已存在的gradle选择Use local gradle distribution 等待右下角（红圈部分）下载完成 添加HelloCtrl类添加如下代码1234567891011121314import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;@Controller//这是一个控制器public class HelloCtrl&#123; @RequestMapping(\"/\")//将地址映射到 / 即访问http://localhost:8080 就可以进入这个方法 @ResponseBody//返回数据,如果不添加该注解将在resources/templates下寻找与之对应的html模版 public String hello() &#123; return \"hello spring boot\"; &#125;&#125; 三、运行 点击右上角启动如果没有启动可点点击HelloSpringBootApplication左边的启动箭头即可启动 启动成功控制的打印如下图所示内容 打开浏览器，http://localhost:8080 出现hello spring boot字样则成功源码地址：https://github.com/LieRabbit/hello-spring-boot","categories":[{"name":"Spring Boot快速入门","slug":"Spring-Boot快速入门","permalink":"https://lierabbit.cn/categories/Spring-Boot快速入门/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://lierabbit.cn/tags/Spring-Boot/"}]}]}