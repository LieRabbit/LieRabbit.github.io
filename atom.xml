<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>谎话兔博客</title>
  
  <subtitle>LieRabbit</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://lierabbit.cn/"/>
  <updated>2018-09-18T03:36:19.451Z</updated>
  <id>https://lierabbit.cn/</id>
  
  <author>
    <name>谎话兔</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>删除排序数组中的重复项（Remove Duplicates from Sorted Array）</title>
    <link href="https://lierabbit.cn/2018/09/18/%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/"/>
    <id>https://lierabbit.cn/2018/09/18/删除排序数组中的重复项/</id>
    <published>2018-09-18T03:27:41.000Z</published>
    <updated>2018-09-18T03:36:19.451Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。<br>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p><p>示例 1:</p><blockquote><p>给定数组 nums = [1,1,2],<br>函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。<br>你不需要考虑数组中超出新长度后面的元素。</p></blockquote><p>示例 2:</p><blockquote><p>给定 nums = [0,0,1,1,1,2,2,3,3,4],<br>函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。<br>你不需要考虑数组中超出新长度后面的元素。</p></blockquote><p>说明:<br>为什么返回数值是整数，但输出的答案是数组呢?<br>请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。<br>你可以想象内部操作如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span><br><span class="line">int len = removeDuplicates(nums);</span><br><span class="line"></span><br><span class="line">// 在函数里修改输入数组对于调用者是可见的。</span><br><span class="line">// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。</span><br><span class="line">for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>由于数组已经排序我们可以使用2个索引len，i进行去重，其中len用来复制，i用来检查是否重复。当<code>nums[i-1] != nums[i]</code>时，说明这时不重复，将其复制到nums[len]。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i - <span class="number">1</span>] != nums[i])</span><br><span class="line">            nums[len++] = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。&lt;br&gt;不要使用额外的数组
      
    
    </summary>
    
      <category term="LeetCode算法之旅" scheme="https://lierabbit.cn/categories/LeetCode%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>k个一组翻转链表（Reverse Nodes in k-Group）</title>
    <link href="https://lierabbit.cn/2018/09/17/k%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <id>https://lierabbit.cn/2018/09/17/k个一组翻转链表/</id>
    <published>2018-09-17T07:09:11.000Z</published>
    <updated>2018-09-17T07:35:54.182Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给出一个链表，每 k 个节点一组进行翻转，并返回翻转后的链表。</p><p>k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么将最后剩余节点保持原有顺序。</p><p>示例 :</p><p>给定这个链表：1-&gt;2-&gt;3-&gt;4-&gt;5</p><p>当 k = 2 时，应当返回: 2-&gt;1-&gt;4-&gt;3-&gt;5</p><p>当 k = 3 时，应当返回: 3-&gt;2-&gt;1-&gt;4-&gt;5</p><p>说明 :</p><ul><li>你的算法只能使用常数的额外空间。</li><li>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</li></ul><p>ListNode结构<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line"></span><br><span class="line">    ListNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>使用4个指针反转链表</p><ul><li><code>start</code>下一次循环的开始节点</li><li><code>kStep</code>提前走k步</li><li><code>cur</code>当前要移动的节点</li><li><code>pre</code>固定的开始节点</li></ul><blockquote><p>例如:<br>list = 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5, k = 3</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">首先使用虚拟头节点简化操作</span><br><span class="line">dummy  -&gt;  1  -&gt;  2  -&gt;  3  -&gt;  4  -&gt;  5</span><br><span class="line"></span><br><span class="line">第一次反转链表过程如下</span><br><span class="line">dummy  -&gt;  1  -&gt;  2  -&gt;  3  -&gt;  4  -&gt;  5</span><br><span class="line"> pre      cur          kStep</span><br><span class="line">         start</span><br><span class="line"></span><br><span class="line">dummy  -&gt;  2  -&gt;  3  -&gt;  1  -&gt;  4  -&gt;  5</span><br><span class="line"> pre      cur   kStep  start</span><br><span class="line"></span><br><span class="line">dummy  -&gt;  3  -&gt;  2  -&gt;  1  -&gt;  4  -&gt;  5</span><br><span class="line"> pre      cur          start</span><br><span class="line">         kStep</span><br><span class="line"></span><br><span class="line">第二次反转遍历过程如下</span><br><span class="line">dummy  -&gt;  3  -&gt;  2  -&gt;  1  -&gt;  4  -&gt;  5  -&gt;  null</span><br><span class="line">                        pre   start           kStep</span><br><span class="line"></span><br><span class="line">kStep为null退出循环</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseKGroup</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    dummy.next = head;</span><br><span class="line">    ListNode start = dummy;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        ListNode kStep = start, pre = start, cur;</span><br><span class="line">        start = pre.next;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k &amp;&amp; kStep != <span class="keyword">null</span>; i++)</span><br><span class="line">            kStep = kStep.next;</span><br><span class="line">        <span class="keyword">if</span> (kStep == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            cur = pre.next;</span><br><span class="line">            pre.next = cur.next;</span><br><span class="line">            cur.next = kStep.next;</span><br><span class="line">            kStep.next = cur;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给出一个链表，每 k 个节点一组进行翻转，并返回翻转后的链表。&lt;/p&gt;
&lt;p&gt;k 是一个正整数，它的值小于或等于链表的长度。
      
    
    </summary>
    
      <category term="LeetCode算法之旅" scheme="https://lierabbit.cn/categories/LeetCode%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>两两交换链表中的节点（Swap Nodes in Pairs）</title>
    <link href="https://lierabbit.cn/2018/09/09/%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/"/>
    <id>https://lierabbit.cn/2018/09/09/两两交换链表中的节点/</id>
    <published>2018-09-09T06:27:36.000Z</published>
    <updated>2018-09-17T07:54:46.130Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p><p>示例:</p><blockquote><p>给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.</p></blockquote><p>说明:</p><ul><li>你的算法只能使用常数的额外空间。</li><li>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</li></ul><p>ListNode数据结构<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line"></span><br><span class="line">    ListNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>使用3个指针进行两两交换，分别是前指针（pre）,当前指针（cur）,后指针（next）<br>pre的作用是在cur与next交换后进行连接，防止断链<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">    ListNode tempHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    tempHead.next = head;</span><br><span class="line">    ListNode pre = tempHead;</span><br><span class="line">    ListNode cur = pre.next;</span><br><span class="line">    ListNode next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span> &amp;&amp; cur.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        next = cur.next;</span><br><span class="line">        cur.next = next.next;</span><br><span class="line">        next.next = cur;</span><br><span class="line">        pre.next = next;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = pre.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tempHead.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。&lt;/p&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给
      
    
    </summary>
    
      <category term="LeetCode算法之旅" scheme="https://lierabbit.cn/categories/LeetCode%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>合并K个排序链表（Merge k Sorted Lists）</title>
    <link href="https://lierabbit.cn/2018/09/05/%E5%90%88%E5%B9%B6K%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <id>https://lierabbit.cn/2018/09/05/合并K个排序链表/</id>
    <published>2018-09-05T14:20:30.000Z</published>
    <updated>2018-09-17T07:54:46.134Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。</p><p>示例:</p><blockquote><p>输入:<br>[<br>  1-&gt;4-&gt;5,<br>  1-&gt;3-&gt;4,<br>  2-&gt;6<br>]<br>输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</p></blockquote><p>ListNode数据结构<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line"></span><br><span class="line">    ListNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>相邻链表两两合并，两两合并详情见<a href="https://lierabbit.cn/2018/09/03/合并两个有序链表">合并两个有序链表</a><br><img src="https://blog-1252204470.cos.ap-guangzhou.myqcloud.com/2018/09/05/%E5%90%88%E5%B9%B6K%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/1.png" alt=""><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> interval = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (interval &lt; lists.length) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lists.length - interval; i += interval * <span class="number">2</span>) &#123;</span><br><span class="line">            lists[i] = merge2Lists(lists[i], lists[i + interval]);</span><br><span class="line">        &#125;</span><br><span class="line">        interval *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> lists.length &gt; <span class="number">0</span> ? lists[<span class="number">0</span>] : <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">merge2Lists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l1 == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    <span class="keyword">if</span> (l2 == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">        l1.next = merge2Lists(l1.next, l2);</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        l2.next = merge2Lists(l1, l2.next);</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>时间复杂度： O(Nlogk)，k是链表的数目</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。&lt;/p&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;blockquote
      
    
    </summary>
    
      <category term="LeetCode算法之旅" scheme="https://lierabbit.cn/categories/LeetCode%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>括号生成（Generate Parentheses）</title>
    <link href="https://lierabbit.cn/2018/09/04/%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/"/>
    <id>https://lierabbit.cn/2018/09/04/括号生成/</id>
    <published>2018-09-04T02:41:25.000Z</published>
    <updated>2018-09-17T07:54:46.136Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。</p><p>例如，给出 n = 3，生成结果为：</p><blockquote><p>[<br>  “((()))”,<br>  “(()())”,<br>  “(())()”,<br>  “()(())”,<br>  “()()()”<br>]</p></blockquote><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>合法的括号：</p><ol><li>左括号在对应右括号的左边 -&gt; 先添加左括号再添加右括号即可保证左括号在右括号的左边</li><li>相同数量的左右括号 -&gt; 右括号数量 == 左括号数量</li><li>最终形成的字符串长度为n*2，也就是左右括号各n个</li></ol><p>根据以上分析使用回溯法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    process(res, <span class="string">""</span>, <span class="number">0</span>, <span class="number">0</span>, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> res   结果</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> str   结果中的一项</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> open  左括号数量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> close 右括号数量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n     生成的括号对数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(List&lt;String&gt; res, String str, <span class="keyword">int</span> open, <span class="keyword">int</span> close, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str.length() == n * <span class="number">2</span>) &#123;</span><br><span class="line">        res.add(str);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (open &lt; n)</span><br><span class="line">            process(res, str + <span class="string">"("</span>, open + <span class="number">1</span>, close, n);</span><br><span class="line">        <span class="keyword">if</span> (close &lt; open)</span><br><span class="line">            process(res, str + <span class="string">")"</span>, open, close + <span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。&lt;/p&gt;
&lt;p&gt;例如，给出 n =
      
    
    </summary>
    
      <category term="LeetCode算法之旅" scheme="https://lierabbit.cn/categories/LeetCode%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>合并两个有序链表（Merge Two Sorted Lists）</title>
    <link href="https://lierabbit.cn/2018/09/03/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <id>https://lierabbit.cn/2018/09/03/合并两个有序链表/</id>
    <published>2018-09-03T08:46:54.000Z</published>
    <updated>2018-09-17T07:54:46.134Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><blockquote><p>示例：<br>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p></blockquote><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>先比较头节点，然后递归比较剩下的节点，最后将其连接起来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l1 == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    <span class="keyword">if</span> (l2 == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">        l1.next = mergeTwoLists(l1.next, l2);</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        l2.next = mergeTwoLists(l1, l2.next);</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 &lt;/p&gt;
&lt;blockquot
      
    
    </summary>
    
      <category term="LeetCode算法之旅" scheme="https://lierabbit.cn/categories/LeetCode%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>仿segmentfault-table横向滚动</title>
    <link href="https://lierabbit.cn/2018/09/02/%E4%BB%BFsegmentfault-table%E6%A8%AA%E5%90%91%E6%BB%9A%E5%8A%A8/"/>
    <id>https://lierabbit.cn/2018/09/02/仿segmentfault-table横向滚动/</id>
    <published>2018-09-02T08:37:47.000Z</published>
    <updated>2018-09-02T09:56:24.393Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><a href="https://lierabbit.cn">自己的博客</a>在用移动端访问时，如果table的列数足够多会显示不全，如下图红圈所示</p><p><img src="https://blog-1252204470.cos.ap-guangzhou.myqcloud.com/2018/09/02/%E4%BB%BFsf--table%E6%A8%AA%E5%90%91%E6%BB%9A%E5%8A%A8/1.png" alt=""></p><p>正常情况如图</p><p><img src="https://blog-1252204470.cos.ap-guangzhou.myqcloud.com/2018/09/02/%E4%BB%BFsf--table%E6%A8%AA%E5%90%91%E6%BB%9A%E5%8A%A8/2.png" alt=""></p><h2 id="解决过程"><a href="#解决过程" class="headerlink" title="解决过程"></a>解决过程</h2><p>使用chrome发现<a href="https://segmentfault.com" target="_blank" rel="noopener">segmentfault</a>的解决方法是在table上套一个table-wrap，如下图蓝色背景和红圈所示</p><p><img src="https://blog-1252204470.cos.ap-guangzhou.myqcloud.com/2018/09/02/%E4%BB%BFsf--table%E6%A8%AA%E5%90%91%E6%BB%9A%E5%8A%A8/3.png" alt=""></p><p>首先想到直接在table上套一个table-wrap即可<br>接着查看别的table时发现并不是每一个table都被套上一个table-wrap，如下图所示，也就是说只有显示不全的table才会套上table-wrap</p><p><img src="https://blog-1252204470.cos.ap-guangzhou.myqcloud.com/2018/09/02/%E4%BB%BFsf--table%E6%A8%AA%E5%90%91%E6%BB%9A%E5%8A%A8/4.png" alt=""></p><p>table什么情况是显示不全？<br>那就是table的宽度 &gt; 文章的宽度</p><p>通过以上分析可以得出简单的步骤：</p><ol><li>获取文章的宽度(articleWidth)</li><li>获取所有的table</li><li>找出比articleWidth宽的table</li><li>使其被.table-wrap包囊</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> articleWidth = <span class="built_in">document</span>.getElementById(<span class="string">'文章'</span>).clientWidth;</span><br><span class="line"><span class="keyword">let</span> tables = $(<span class="string">'table'</span>);</span><br><span class="line"></span><br><span class="line">tables.each(<span class="function">(<span class="params">index, table</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (table.clientWidth &gt; articleWidth) &#123;</span><br><span class="line">        table.outerHTML = <span class="string">"&lt;div class='table-wrap'&gt;"</span> + table.outerHTML + <span class="string">"&lt;/div&gt;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>别忘了补上css<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.table-wrap</span>&#123;</span><br><span class="line">  <span class="attribute">overflow-x</span>: scroll;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其实不用判断table的宽度 &gt; 文章的宽度也能实现，让每一个table都套上.table-wrap，使用如下css<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.table-wrap</span>&#123;</span><br><span class="line">  <span class="attribute">overflow-x</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样的话只是会在html上多一点<code>&lt;div class=&quot;table-wrap&quot;&gt;&lt;/div&gt;</code>而已，并且当页面大小发生变化也会根据需要是否出现滚动条</p><p>实际效果用移动端或者chrome模拟移动端看<a href="https://lierabbit.cn/2018/05/08/最长回文子串">https://lierabbit.cn/2018/05/08/最长回文子串</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://lierabbit.cn&quot;&gt;自己的博客&lt;/a&gt;在用移动端访问时，如果table的列数足够多
      
    
    </summary>
    
    
      <category term="HTML" scheme="https://lierabbit.cn/tags/HTML/"/>
    
      <category term="CSS" scheme="https://lierabbit.cn/tags/CSS/"/>
    
      <category term="JavaScript" scheme="https://lierabbit.cn/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>有效的括号（Valid Parentheses）</title>
    <link href="https://lierabbit.cn/2018/09/01/%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/"/>
    <id>https://lierabbit.cn/2018/09/01/有效的括号/</id>
    <published>2018-09-01T12:16:02.000Z</published>
    <updated>2018-09-17T07:54:46.138Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li></ol><p>注意空字符串可被认为是有效字符串。</p><blockquote><p>示例 1:<br>输入: “()”<br>输出: true</p></blockquote><blockquote><p>示例 2:<br>输入: “()[]{}”<br>输出: true</p></blockquote><blockquote><p>示例 3:<br>输入: “(]”<br>输出: false</p></blockquote><blockquote><p>示例 4:<br>输入: “([)]”<br>输出: false</p></blockquote><blockquote><p>示例 5:<br>输入: “{[]}”<br>输出: true</p></blockquote><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>合法的括号特征：<code>当右括号出现，则紧靠其左边必有对应的左括号</code><br>具体做法：</p><ol><li>利用一个栈记录遍历到的左括号对应的右括号</li><li>当右括号出现，若栈顶与右括号一致则合法，反之不合法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, len = s.length(); i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> ch = s.charAt(i);</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">'('</span>)</span><br><span class="line">            stack.add(<span class="string">')'</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">'&#123;'</span>)</span><br><span class="line">            stack.add(<span class="string">'&#125;'</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">'['</span>)</span><br><span class="line">            stack.add(<span class="string">']'</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (stack.isEmpty() || stack.pop() != ch)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。&lt;/p&gt;
&lt;p&gt;有效字符串需满
      
    
    </summary>
    
      <category term="LeetCode算法之旅" scheme="https://lierabbit.cn/categories/LeetCode%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>删除链表的倒数第N个节点（Remove Nth Node From End of List）</title>
    <link href="https://lierabbit.cn/2018/08/31/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
    <id>https://lierabbit.cn/2018/08/31/删除链表的倒数第N个节点/</id>
    <published>2018-08-31T02:37:17.000Z</published>
    <updated>2018-09-17T07:54:46.133Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</p><p>示例：</p><blockquote><p>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.<br>当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.<br>说明：<br>给定的 n 保证是有效的。</p></blockquote><p>进阶：<br>你能尝试使用一趟扫描实现吗</p><p>ListNode数据结构<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line"></span><br><span class="line">    ListNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>如何一趟遍历获取倒数第n个节点？<br>使用2个指针first,second，first在前，second在后，保持间隔n走到链尾，这样second就是倒数第n个节点</p><p>如何删除当前节点操作？<br>前一个节点.next = 前一个节点.next.next</p><p>由于头节点没有前一个节点了，如何删除头节点？<br>在头节点前面加入临时头节点，这样原头节点就和普通节点一致</p><p>解决了上述3个问题可得出以下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 为了方便操作建立临时头节点</span></span><br><span class="line">    ListNode tempHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    tempHead.next = head;</span><br><span class="line">    ListNode first = tempHead;</span><br><span class="line">    ListNode second = tempHead;</span><br><span class="line">    <span class="comment">// 让first先走n+1步</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        first = first.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 两个指针一起走，当first走到链尾，second就走到倒数第n+1个节点</span></span><br><span class="line">    <span class="keyword">while</span> (first != <span class="keyword">null</span>) &#123;</span><br><span class="line">        first = first.next;</span><br><span class="line">        second = second.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除下一个节点即删除倒数第n个节点</span></span><br><span class="line">    second.next = second.next.next;</span><br><span class="line">    <span class="keyword">return</span> tempHead.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;blockquote&gt;

      
    
    </summary>
    
      <category term="LeetCode算法之旅" scheme="https://lierabbit.cn/categories/LeetCode%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>四数之和（4Sum）</title>
    <link href="https://lierabbit.cn/2018/08/30/%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>https://lierabbit.cn/2018/08/30/四数之和/</id>
    <published>2018-08-30T06:33:15.000Z</published>
    <updated>2018-09-17T07:54:46.134Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。<br>注意：<br><strong>答案中不可以包含重复的四元组。</strong><br>示例：</p><blockquote><p>给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。<br>满足要求的四元组集合为：<br>[<br>  [-1,  0, 0, 1],<br>  [-2, -1, 1, 2],<br>  [-2,  0, 0, 2]<br>]</p></blockquote><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>通过观察之前的<a href="https://lierabbit.cn/2018/04/22/两数之和/">两数之和</a>，<a href="https://lierabbit.cn/2018/05/23/三数之和/">三数之和</a>发现所有的K数之和问题都可以转变成两数之和问题：</p><ol><li>将K数之和问题转化为K-1数之和问题</li><li>重复1直到k==2</li><li>两数之和利用夹逼算法解决</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; fourSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">return</span> kSum(nums, <span class="number">0</span>, <span class="number">4</span>, target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; kSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> k, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> left = start, right = len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = nums[left] + nums[right];</span><br><span class="line">            <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">                List&lt;Integer&gt; temp = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">                temp.add(nums[left]);</span><br><span class="line">                temp.add(nums[right]);</span><br><span class="line">                res.add(temp);</span><br><span class="line">                <span class="comment">// 跳过左边重复数字</span></span><br><span class="line">                <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>])</span><br><span class="line">                    left++;</span><br><span class="line">                <span class="comment">// 跳过右边重复数字</span></span><br><span class="line">                <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>])</span><br><span class="line">                    right--;</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target)</span><br><span class="line">                left++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start, end = len - (k - <span class="number">1</span>); i &lt; end; i++) &#123;</span><br><span class="line">            <span class="comment">// 跳过重复数字</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; start &amp;&amp; nums[i] == nums[i - <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 将K数之和转换成K-1数之和</span></span><br><span class="line">            List&lt;List&lt;Integer&gt;&gt; temp = kSum(nums, i + <span class="number">1</span>, k - <span class="number">1</span>, target - nums[i]);</span><br><span class="line">            <span class="keyword">for</span> (List&lt;Integer&gt; item : temp)</span><br><span class="line">                item.add(<span class="number">0</span>, nums[i]);</span><br><span class="line">            res.addAll(temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(N<sup>k-1</sup>)，在本题中k=4，即O(N<sup>3</sup>)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d
      
    
    </summary>
    
      <category term="LeetCode算法之旅" scheme="https://lierabbit.cn/categories/LeetCode%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>电话号码的字母组合（Letter Combinations of a Phone Number）</title>
    <link href="https://lierabbit.cn/2018/08/29/%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/"/>
    <id>https://lierabbit.cn/2018/08/29/电话号码的字母组合/</id>
    <published>2018-08-29T03:01:19.000Z</published>
    <updated>2018-09-17T07:54:46.139Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。<br>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。<br><img src="https://blog-1252204470.cos.ap-guangzhou.myqcloud.com/2018/08/29/%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/1.png" alt=""></p><p><strong>示例:</strong></p><blockquote><p>输入：”23”<br>输出：[“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”].</p></blockquote><p><strong>说明:</strong><br>尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>利用队列先进先出的性质进行横向组合。<br>例如输入“23”</p><ol><li>首先取出输入中的第一个数2，它所代表的字母为a,b,c，依次放入队列，</li><li>接着取出输入中的下一个数3，它所代表的字母为d,e,f。</li><li>队列依次出队与d,e,f进行组合</li></ol><p>过程如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot; + a = a</span><br><span class="line">&quot;&quot; + b = b</span><br><span class="line">&quot;&quot; + c = c</span><br><span class="line">a + d = ad</span><br><span class="line">a + e = ae</span><br><span class="line">a + f = af</span><br><span class="line">b + d = bd</span><br><span class="line">b + e = be</span><br><span class="line">b + f = bf</span><br><span class="line">c + d = cd</span><br><span class="line">c + e = ce</span><br><span class="line">c + f = cf</span><br></pre></td></tr></table></figure></p><p>如果输入的是“234”，重复2，3步骤即可</p><p>现在还剩2个问题：<br>何时退出这个循环？<br>通过观察可知，<code>输入字符串的长度 == 组合后子项的长度</code><br>也就是说<code>队列里的所有字符串长度 == 输入的字符串长度</code>时组合完成<br>如何取得输入中的下一个数？<br>既然<code>输入字符串的长度 == 组合后子项的长度</code>，那么通过队列里的字符长度获取输入中的下一个数即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCombinations</span><span class="params">(String digits)</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;String&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 使用数组模拟按键映射，这里可以换成HashMap</span></span><br><span class="line">    String[] map = <span class="keyword">new</span> String[]&#123;<span class="string">""</span>, <span class="string">""</span>, <span class="string">"abc"</span>, <span class="string">"def"</span>, <span class="string">"ghi"</span>, <span class="string">"jkl"</span>, <span class="string">"mno"</span>, <span class="string">"pqrs"</span>, <span class="string">"tuv"</span>, <span class="string">"wxyz"</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (digits.isEmpty())</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    res.add(<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (res.peek().length() != digits.length()) &#123;</span><br><span class="line">        String temp = res.pop();</span><br><span class="line">        String value = map[digits.charAt(temp.length()) - <span class="string">'0'</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : value.toCharArray())</span><br><span class="line">            res.add(temp + c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。&lt;br&gt;给出数字到字母的映射如下（与电话按键相同）。注意 
      
    
    </summary>
    
      <category term="LeetCode算法之旅" scheme="https://lierabbit.cn/categories/LeetCode%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>最接近的三数之和（3Sum Closest）</title>
    <link href="https://lierabbit.cn/2018/05/23/%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>https://lierabbit.cn/2018/05/23/最接近的三数之和/</id>
    <published>2018-05-23T07:52:05.000Z</published>
    <updated>2018-09-17T07:54:46.137Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。</p><blockquote><p>例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.<br>与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).</p></blockquote><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>确定第一个数，然后通过夹逼算法寻找接近target的数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = nums[<span class="number">0</span>] + nums[<span class="number">1</span>] + nums[<span class="number">2</span>];</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> lo = i + <span class="number">1</span>, hi = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = nums[i] + nums[lo] + nums[hi];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (sum &lt; target)</span><br><span class="line">                lo++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target)</span><br><span class="line">                hi--;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> target;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (Math.abs(target - sum) &lt; Math.abs(target - res))</span><br><span class="line">                res = sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(N<sup>2</sup>)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 tar
      
    
    </summary>
    
      <category term="LeetCode算法之旅" scheme="https://lierabbit.cn/categories/LeetCode%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>三数之和（3Sum）</title>
    <link href="https://lierabbit.cn/2018/05/23/%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>https://lierabbit.cn/2018/05/23/三数之和/</id>
    <published>2018-05-23T07:21:13.000Z</published>
    <updated>2018-09-17T07:54:46.130Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。</p><p>注意：答案中不可以包含重复的三元组。<br>例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，<br>满足要求的三元组集合为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [-1, 0, 1],</span><br><span class="line">  [-1, -1, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>先确定一个数，则另外两数之和等于该数的相反数，通过夹逼算法寻找两数之和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 跳过前后一样的数字</span></span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span> || nums[i] != nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">int</span> lo = i + <span class="number">1</span>, hi = nums.length - <span class="number">1</span>, sum = -nums[i];</span><br><span class="line">            <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[lo] + nums[hi] == sum) &#123;</span><br><span class="line">                    res.add(Arrays.asList(nums[i], nums[lo], nums[hi]));</span><br><span class="line">                    <span class="comment">// 跳过前后一样的数字</span></span><br><span class="line">                    <span class="keyword">while</span> (lo &lt; hi &amp;&amp; nums[lo] == nums[lo + <span class="number">1</span>])</span><br><span class="line">                        lo++;</span><br><span class="line">                    <span class="keyword">while</span> (lo &lt; hi &amp;&amp; nums[hi] == nums[hi - <span class="number">1</span>])</span><br><span class="line">                        hi--;</span><br><span class="line">                    lo++;</span><br><span class="line">                    hi--;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[lo] + nums[hi] &lt; sum)</span><br><span class="line">                    lo++;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    hi--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(N<sup>2</sup>)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0
      
    
    </summary>
    
      <category term="LeetCode算法之旅" scheme="https://lierabbit.cn/categories/LeetCode%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>最长公共前缀（Longest Common Prefix）</title>
    <link href="https://lierabbit.cn/2018/05/21/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/"/>
    <id>https://lierabbit.cn/2018/05/21/最长公共前缀/</id>
    <published>2018-05-21T06:48:08.000Z</published>
    <updated>2018-09-17T07:54:46.137Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>编写一个函数来查找字符串数组中的最长公共前缀。<br>如果不存在公共前缀，返回空字符串 “”。</p><blockquote><p>示例 1:<br>输入: [“flower”,”flow”,”flight”]<br>输出: “fl”</p></blockquote><blockquote><p>示例 2:<br>输入: [“dog”,”racecar”,”car”]<br>输出: “”<br>解释: 输入不存在公共前缀。</p></blockquote><blockquote><p>说明:<br>所有输入只包含小写字母 a-z 。</p></blockquote><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><h3 id="横向匹配所有字符串"><a href="#横向匹配所有字符串" class="headerlink" title="横向匹配所有字符串"></a>横向匹配所有字符串</h3><p><img src="https://blog-1252204470.cos.ap-guangzhou.myqcloud.com/2018/05/21/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/1.jpg" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (strs == <span class="keyword">null</span> || strs.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    String prefix = strs[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (strs[i].indexOf(prefix) != <span class="number">0</span>) &#123;</span><br><span class="line">            prefix = prefix.substring(<span class="number">0</span>, prefix.length() - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (prefix.isEmpty())</span><br><span class="line">                <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> prefix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(S)，其中S是所有字符串中所有字符的总和<br>空间复杂度：O(1)，只使用了恒定的额外空间</p><h3 id="二分搜索"><a href="#二分搜索" class="headerlink" title="二分搜索"></a>二分搜索</h3><p><img src="https://blog-1252204470.cos.ap-guangzhou.myqcloud.com/2018/05/21/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/2.jpg" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix2</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (strs == <span class="keyword">null</span> || strs.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> minLen = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (String str : strs)</span><br><span class="line">        minLen = Math.min(minLen, str.length());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">1</span>, right = minLen;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> middle = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (isCommonPrefix(strs, middle))</span><br><span class="line">            left = middle + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            right = middle - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> strs[<span class="number">0</span>].substring(<span class="number">0</span>, (left + right) / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCommonPrefix</span><span class="params">(String[] strs, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    String str1 = strs[<span class="number">0</span>].substring(<span class="number">0</span>, len);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!strs[i].startsWith(str1))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(S*log(n))，其中S是所有字符串中所有字符的总和。<br>空间复杂度：O(1)。我们只使用了恒定的额外空间。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;编写一个函数来查找字符串数组中的最长公共前缀。&lt;br&gt;如果不存在公共前缀，返回空字符串 “”。&lt;/p&gt;
&lt;blockquot
      
    
    </summary>
    
      <category term="LeetCode算法之旅" scheme="https://lierabbit.cn/categories/LeetCode%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>罗马数字转整数（Roman to Integer）</title>
    <link href="https://lierabbit.cn/2018/05/14/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/"/>
    <id>https://lierabbit.cn/2018/05/14/罗马数字转整数/</id>
    <published>2018-05-14T13:44:33.000Z</published>
    <updated>2018-09-17T07:54:46.140Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">罗马数字包含以下七种字符：I， V， X， L，C，D 和 M。</span><br><span class="line">字符          数值</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure><p>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。<br>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p><ul><li>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。</li><li>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 </li><li>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。</li></ul><p>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p><blockquote><p>示例 1:<br>输入: “III”<br>输出: 3</p></blockquote><blockquote><p>示例 2:<br>输入: “IV”<br>输出: 4</p></blockquote><blockquote><p>示例 3:<br>输入: “IX”<br>输出: 9</p></blockquote><blockquote><p>示例 4:<br>输入: “LVIII”<br>输出: 58<br>解释: C = 100, L = 50, XXX = 30, III = 3.</p></blockquote><blockquote><p>示例 5:<br>输入: “MCMXCIV”<br>输出: 1994<br>解释: M = 1000, CM = 900, XC = 90, IV = 4.</p></blockquote><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>如果当前字符代表的数字小于下一个字符代表的数字，则做减法，反之加法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">'I'</span>, <span class="number">1</span>);</span><br><span class="line">    map.put(<span class="string">'V'</span>, <span class="number">5</span>);</span><br><span class="line">    map.put(<span class="string">'X'</span>, <span class="number">10</span>);</span><br><span class="line">    map.put(<span class="string">'L'</span>, <span class="number">50</span>);</span><br><span class="line">    map.put(<span class="string">'C'</span>, <span class="number">100</span>);</span><br><span class="line">    map.put(<span class="string">'D'</span>, <span class="number">500</span>);</span><br><span class="line">    map.put(<span class="string">'M'</span>, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.get(s.charAt(i)) &lt; map.get(s.charAt(i + <span class="number">1</span>)))</span><br><span class="line">            sum -= map.get(s.charAt(i));</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            sum += map.get(s.charAt(i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sum += map.get(s.charAt(s.length() - <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(1)<br>空间复杂度：O(1)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pr
      
    
    </summary>
    
      <category term="LeetCode算法之旅" scheme="https://lierabbit.cn/categories/LeetCode%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>整数转罗马数字（Integer to Roman）</title>
    <link href="https://lierabbit.cn/2018/05/14/%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/"/>
    <id>https://lierabbit.cn/2018/05/14/整数转罗马数字/</id>
    <published>2018-05-14T08:39:40.000Z</published>
    <updated>2018-09-17T07:54:46.136Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。</span><br><span class="line">字符          数值</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure><p>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。<br>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p><ul><li>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。</li><li>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 </li><li>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。</li></ul><p>给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。</p><blockquote><p>示例 1:<br>输入: 3<br>输出: “III”</p></blockquote><blockquote><p>示例 2:<br>输入: 4<br>输出: “IV”</p></blockquote><blockquote><p>示例 3:<br>输入: 9<br>输出: “IX”</p></blockquote><blockquote><p>示例 4:<br>输入: 58<br>输出: “LVIII”<br>解释: C = 100, L = 50, XXX = 30, III = 3.</p></blockquote><blockquote><p>示例 5:<br>输入: 1994<br>输出: “MCMXCIV”<br>解释: M = 1000, CM = 900, XC = 90, IV = 4.</p></blockquote><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>直接储存各个数位上的字符，再根据数字取出对应的字符🙃</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    String M[] = &#123;<span class="string">""</span>, <span class="string">"M"</span>, <span class="string">"MM"</span>, <span class="string">"MMM"</span>&#125;;</span><br><span class="line">    String C[] = &#123;<span class="string">""</span>, <span class="string">"C"</span>, <span class="string">"CC"</span>, <span class="string">"CCC"</span>, <span class="string">"CD"</span>, <span class="string">"D"</span>, <span class="string">"DC"</span>, <span class="string">"DCC"</span>, <span class="string">"DCCC"</span>, <span class="string">"CM"</span>&#125;;</span><br><span class="line">    String X[] = &#123;<span class="string">""</span>, <span class="string">"X"</span>, <span class="string">"XX"</span>, <span class="string">"XXX"</span>, <span class="string">"XL"</span>, <span class="string">"L"</span>, <span class="string">"LX"</span>, <span class="string">"LXX"</span>, <span class="string">"LXXX"</span>, <span class="string">"XC"</span>&#125;;</span><br><span class="line">    String I[] = &#123;<span class="string">""</span>, <span class="string">"I"</span>, <span class="string">"II"</span>, <span class="string">"III"</span>, <span class="string">"IV"</span>, <span class="string">"V"</span>, <span class="string">"VI"</span>, <span class="string">"VII"</span>, <span class="string">"VIII"</span>, <span class="string">"IX"</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> M[num / <span class="number">1000</span>] + C[num % <span class="number">1000</span> / <span class="number">100</span>] + X[num % <span class="number">100</span> / <span class="number">10</span>] + I[num % <span class="number">10</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(1)<br>空间复杂度：O(1)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pr
      
    
    </summary>
    
      <category term="LeetCode算法之旅" scheme="https://lierabbit.cn/categories/LeetCode%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>盛最多水的容器（Container With Most Water）</title>
    <link href="https://lierabbit.cn/2018/05/14/%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/"/>
    <id>https://lierabbit.cn/2018/05/14/盛最多水的容器/</id>
    <published>2018-05-14T08:06:24.000Z</published>
    <updated>2018-09-17T07:54:46.139Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。画 n 条垂直线，使得垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>从头和尾开始找起，一开始就获得了最大宽度，由于面积是取较小的高度，所以移动高度较小的索引以期待能获得更高的高度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = height.length - <span class="number">1</span>, max = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        max = Math.max(max, (r - l) * Math.min(height[l], height[r]));</span><br><span class="line">        <span class="keyword">if</span> (height[l] &lt; height[r])</span><br><span class="line">            l++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            r--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。画 n 条垂直线，使得垂直线 i 的
      
    
    </summary>
    
      <category term="LeetCode算法之旅" scheme="https://lierabbit.cn/categories/LeetCode%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式匹配（Regular Expression Matching）</title>
    <link href="https://lierabbit.cn/2018/05/14/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D-1/"/>
    <id>https://lierabbit.cn/2018/05/14/正则表达式匹配-1/</id>
    <published>2018-05-14T07:19:01.000Z</published>
    <updated>2018-09-17T07:54:46.139Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个字符串 (s) 和一个字符模式 (p)。实现支持 ‘.’ 和 ‘*‘ 的正则表达式匹配。<br>‘.’ 匹配任意单个字符。<br>‘*‘ 匹配零个或多个前面的元素。<br>匹配应该覆盖整个字符串 (s) ，而不是部分字符串。</p><blockquote><p>说明:<br>s 可能为空，且只包含从 a-z 的小写字母。<br>p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。</p></blockquote><blockquote><p>示例 1:<br>输入:<br>s = “aa”<br>p = “a”<br>输出: false<br>解释: “a” 无法匹配 “aa” 整个字符串。</p></blockquote><blockquote><p>示例 2:<br>输入:<br>s = “aa”<br>p = “a*“<br>输出: true<br>解释: ‘*‘ 代表可匹配零个或多个前面的元素, 即可以匹配 ‘a’ 。因此, 重复 ‘a’ 一次, 字符串可变为 “aa”。</p></blockquote><blockquote><p>示例 3:<br>输入:<br>s = “ab”<br>p = “.*“<br>输出: true<br>解释: “.*“ 表示可匹配零个或多个(‘*‘)任意字符(‘.’)。</p></blockquote><blockquote><p>示例 4:<br>输入:<br>s = “aab”<br>p = “c*a*b”<br>输出: true<br>解释: ‘c’ 可以不被重复, ‘a’ 可以被重复一次。因此可以匹配字符串 “aab”。</p></blockquote><blockquote><p>示例 5:<br>输入:<br>s = “mississippi”<br>p = “mis*is*p*.”<br>输出: false</p></blockquote><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>当模式中的第二个字符是“*”时：<br>如果字符串第一个字符跟模式第一个字符不匹配，则模式后移2个字符，继续匹配。如果字符串第一个字符跟模式第一个字符匹配，可以有2种匹配方式： </p><ul><li>模式后移2字符，相当于x*被忽略</li><li>字符串后移1字符，模式不变，即继续匹配字符下一位，因为*可以匹配多位<br>当模式中的第二个字符不是“*”时：</li><li>如果字符串第一个字符和模式中的第一个字符相匹配，那么字符串和模式都后移一个字符，然后匹配剩余的</li><li>如果字符串第一个字符和模式中的第一个字符相不匹配，直接返回false</li></ul><p>这里需要注意的是：要时刻检验数组是否越界</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || p == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isMatchCore(s, <span class="number">0</span>, p, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatchCore</span><span class="params">(String s, <span class="keyword">int</span> sIndex, String p, <span class="keyword">int</span> pIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 有效性检验：str到尾，pattern到尾，匹配成功</span></span><br><span class="line">    <span class="keyword">if</span> (s.length() == sIndex &amp;&amp; p.length() == pIndex)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// pattern先到尾，匹配失败</span></span><br><span class="line">    <span class="keyword">if</span> (p.length() == pIndex)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 模式后一个字符是*，且字符串第1个跟模式第1个匹配,分2种匹配模式。如不匹配，模式后移2位</span></span><br><span class="line">    <span class="keyword">if</span> (pIndex + <span class="number">1</span> &lt; p.length() &amp;&amp; p.charAt(pIndex + <span class="number">1</span>) == <span class="string">'*'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sIndex &lt; s.length() &amp;&amp; (s.charAt(sIndex) == p.charAt(pIndex) || p.charAt(pIndex) == <span class="string">'.'</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> isMatchCore(s, sIndex + <span class="number">1</span>, p, pIndex) || <span class="comment">// x*匹配1个字符，再匹配str中的下一个</span></span><br><span class="line">                    isMatchCore(s, sIndex, p, pIndex + <span class="number">2</span>); <span class="comment">// 模式后移2位，视为x*匹配0个字符</span></span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> isMatchCore(s, sIndex, p, pIndex + <span class="number">2</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 模式后一个字符不是*，且字符串第1个跟模式第1个匹配，则都后移1位，否则直接返回false</span></span><br><span class="line">        <span class="keyword">if</span> (sIndex &lt; s.length() &amp;&amp; (s.charAt(sIndex) == p.charAt(pIndex) || p.charAt(pIndex) == <span class="string">'.'</span>))</span><br><span class="line">            <span class="keyword">return</span> isMatchCore(s, sIndex + <span class="number">1</span>, p, pIndex + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>只需要注意后一个字符是否为*即可，<br>第一个字符直接进行对比判断，当第二个字符为*时，有2种情况</p><ul><li>0个字符匹配，模式直接往后跳2位</li><li>1个字符匹配，字符串往后跳1位<br>没*的话直接对比匹配即可</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch2</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p.isEmpty())</span><br><span class="line">        <span class="keyword">return</span> s.isEmpty();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> firstMatch = !s.isEmpty() &amp;&amp; (s.charAt(<span class="number">0</span>) == p.charAt(<span class="number">0</span>) || p.charAt(<span class="number">0</span>) == <span class="string">'.'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p.length() &gt; <span class="number">1</span> &amp;&amp; p.charAt(<span class="number">1</span>) == <span class="string">'*'</span>)</span><br><span class="line">        <span class="keyword">return</span> isMatch2(s, p.substring(<span class="number">2</span>)) || (firstMatch &amp;&amp; isMatch2(s.substring(<span class="number">1</span>), p));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> firstMatch &amp;&amp; isMatch2(s.substring(<span class="number">1</span>), p.substring(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个字符串 (s) 和一个字符模式 (p)。实现支持 ‘.’ 和 ‘*‘ 的正则表达式匹配。&lt;br&gt;‘.’ 匹配任意单个
      
    
    </summary>
    
      <category term="LeetCode算法之旅" scheme="https://lierabbit.cn/categories/LeetCode%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>回文数（Palindrome Number）</title>
    <link href="https://lierabbit.cn/2018/05/09/%E5%9B%9E%E6%96%87%E6%95%B0/"/>
    <id>https://lierabbit.cn/2018/05/09/回文数/</id>
    <published>2018-05-09T04:28:24.000Z</published>
    <updated>2018-09-17T07:54:46.135Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p><blockquote><p>示例 1:<br>输入: 121<br>输出: true</p></blockquote><blockquote><p>示例 2:<br>输入: -121<br>输出: false<br>解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</p></blockquote><blockquote><p>示例 3:<br>输入: 10<br>输出: false<br>解释: 从右向左读, 为 01 。因此它不是一个回文数。</p></blockquote><blockquote><p>进阶: 你能不将整数转为字符串来解决这个问题吗？</p></blockquote><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ul><li>如果是负数则不是回文数，因为只有一个’-‘</li><li>如果个位为0则不是回文数，0除外。因为如果个位为0则首位必须为0，然而除了0之外没有首位为0的数</li><li>反转数的一半，例如x=12321，反转后x=12，reverse=123，那么x==reverse或者x==reverse/10</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span> || (x % <span class="number">10</span> == <span class="number">0</span> &amp;&amp; x != <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> reverse = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 反转数字的一半</span></span><br><span class="line">    <span class="keyword">while</span> (x &gt; reverse) &#123;</span><br><span class="line">        reverse = reverse * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x == reverse || reverse / <span class="number">10</span> == x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(log<sub>10</sub>(n))<br>空间复杂度：O(1)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。&lt;/p&gt;
&lt;blockquote&gt;

      
    
    </summary>
    
      <category term="LeetCode算法之旅" scheme="https://lierabbit.cn/categories/LeetCode%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>字符串转整数（String to Integer (atoi)）</title>
    <link href="https://lierabbit.cn/2018/05/09/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%95%B4%E6%95%B0/"/>
    <id>https://lierabbit.cn/2018/05/09/字符串转整数/</id>
    <published>2018-05-09T03:42:42.000Z</published>
    <updated>2018-09-17T07:54:46.135Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>实现 atoi，将字符串转为整数。<br>在找到第一个非空字符之前，需要移除掉字符串中的空格字符。如果第一个非空字符是正号或负号，选取该符号，并将其与后面尽可能多的连续的数字组合起来，这部分字符即为整数的值。如果第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。<br>字符串可以在形成整数的字符后面包括多余的字符，这些字符可以被忽略，它们对于函数没有影响。<br>当字符串中的第一个非空字符序列不是个有效的整数；或字符串为空；或字符串仅包含空白字符时，则不进行转换。<br>若函数不能执行有效的转换，返回 0。</p><blockquote><p>说明：<br>假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231,  231 − 1]。如果数值超过可表示的范围，则返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。</p></blockquote><blockquote><p>示例 1:<br>输入: “42”<br>输出: 42</p></blockquote><blockquote><p>示例 2:<br>输入: “   -42”<br>输出: -42<br>解释: 第一个非空白字符为 ‘-‘, 它是一个负号。我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。</p></blockquote><blockquote><p>示例 3:<br>输入: “4193 with words”<br>输出: 4193<br>解释: 转换截止于数字 ‘3’ ，因为它的下一个字符不为数字。</p></blockquote><blockquote><p>示例 4:<br>输入: “words and 987”<br>输出: 0<br>解释: 第一个非空字符是 ‘w’, 但它不是数字或正、负号。因此无法执行有效的转换。</p></blockquote><blockquote><p>示例 5:<br>输入: “-91283472332”<br>输出: -2147483648<br>解释: 数字 “-91283472332” 超过 32 位有符号整数范围。 因此返回 INT_MIN (−231) 。</p></blockquote><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>只需要注意4个地方</p><ul><li>字符串前面的空格</li><li>符号位</li><li>只要连续的数字</li><li>溢出判断</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span> || str.length() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>, base = <span class="number">0</span>, sign = <span class="number">1</span>, len = str.length();</span><br><span class="line">    <span class="comment">// 跳过空格</span></span><br><span class="line">    <span class="keyword">while</span> (index &lt; len &amp;&amp; str.charAt(index) == <span class="string">' '</span>)</span><br><span class="line">        index++;</span><br><span class="line">    <span class="comment">// 获取符号位</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; len &amp;&amp; (str.charAt(index) == <span class="string">'+'</span> || str.charAt(index) == <span class="string">'-'</span>))</span><br><span class="line">        sign = <span class="number">1</span> - <span class="number">2</span> * ((str.charAt(index++) == <span class="string">'-'</span>) ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 只取数字，碰到非数字退出循环</span></span><br><span class="line">    <span class="keyword">while</span> (index &lt; len &amp;&amp; str.charAt(index) &gt;= <span class="string">'0'</span> &amp;&amp; str.charAt(index) &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line">        <span class="comment">// 溢出判断，MAX_VALUE的个位为7</span></span><br><span class="line">        <span class="keyword">if</span> (base &gt; Integer.MAX_VALUE / <span class="number">10</span> || (base == Integer.MAX_VALUE / <span class="number">10</span> &amp;&amp; str.charAt(index) - <span class="string">'0'</span> &gt; <span class="number">7</span>))</span><br><span class="line">            <span class="keyword">if</span> (sign == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">        base = base * <span class="number">10</span> + str.charAt(index++) - <span class="string">'0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sign * base;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;实现 atoi，将字符串转为整数。&lt;br&gt;在找到第一个非空字符之前，需要移除掉字符串中的空格字符。如果第一个非空字符是正号或
      
    
    </summary>
    
      <category term="LeetCode算法之旅" scheme="https://lierabbit.cn/categories/LeetCode%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
