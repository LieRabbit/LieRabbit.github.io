<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>谎话兔博客</title>
  
  <subtitle>LieRabbit</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://lierabbit.cn/"/>
  <updated>2018-08-26T08:14:33.045Z</updated>
  <id>https://lierabbit.cn/</id>
  
  <author>
    <name>谎话兔</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>矩形覆盖</title>
    <link href="https://lierabbit.cn/2018/03/02/%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%96/"/>
    <id>https://lierabbit.cn/2018/03/02/矩形覆盖/</id>
    <published>2018-03-02T13:16:17.000Z</published>
    <updated>2018-08-26T08:14:33.045Z</updated>
    
    <content type="html"><![CDATA[<p>我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？</p><p>思路：<br>依旧是斐波那契数列<br>2*n的大矩形，和n个2*1的小矩形<br>其中target*2为大矩阵的大小<br>有以下几种情形： </p><ul><li>target &lt;= 0 大矩形为&lt;= 2*0,直接return 1； </li><li>target = 1大矩形为2*1，只有一种摆放方法，return1； </li><li>target = 2 大矩形为2*2，有两种摆放方法，return2； </li><li>target = n 分为两步考虑：<br>第一次摆放一块 2*1 的小矩阵（用YY表示），则摆放方法总共为f(target - 1)</li></ul><table><thead><tr><th style="text-align:center">Y</th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center">Y</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table><p>第一次摆放一块1*2的小矩阵，则摆放方法总共为f(target-2)<br>因为，摆放了一块1*2的小矩阵（用YY表示），对应下方的1*2（用XX表示）摆放方法就确定了，所以为f(targte-2) </p><table><thead><tr><th style="text-align:center">Y</th><th style="text-align:center">Y</th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center">X</td><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table><p>则f(targte) = f(target-1) + f(target-2)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">RectCover</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (target == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (target == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> prePre = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= target; i++) &#123;</span><br><span class="line">            res = pre + prePre;</span><br><span class="line">            prePre = pre;</span><br><span class="line">            pre = res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？&lt;/p&gt;
&lt;p&gt;思路：&lt;br&gt;依旧是斐波那契数列&lt;br&gt;2*n的大矩形，和n个2*1的小矩形&lt;br&gt;其中target*2为大矩阵的大小&lt;br&gt;有以
      
    
    </summary>
    
      <category term="剑指Offer" scheme="https://lierabbit.cn/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>变态跳台阶</title>
    <link href="https://lierabbit.cn/2018/03/02/%E5%8F%98%E6%80%81%E8%B7%B3%E5%8F%B0%E9%98%B6/"/>
    <id>https://lierabbit.cn/2018/03/02/变态跳台阶/</id>
    <published>2018-03-02T12:52:02.000Z</published>
    <updated>2018-08-26T07:59:05.249Z</updated>
    
    <content type="html"><![CDATA[<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级，它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p><p>思路：每个台阶都有跳与不跳两种情况（除了最后一个台阶），最后一个台阶必须跳。所以共用2^(n-1)中情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloorII</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) Math.pow(<span class="number">2</span>, target - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一只青蛙一次可以跳上1级台阶，也可以跳上2级，它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。&lt;/p&gt;
&lt;p&gt;思路：每个台阶都有跳与不跳两种情况（除了最后一个台阶），最后一个台阶必须跳。所以共用2^(n-1)中情况&lt;/p&gt;
&lt;figure class=&quot;hig
      
    
    </summary>
    
      <category term="剑指Offer" scheme="https://lierabbit.cn/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>跳台阶</title>
    <link href="https://lierabbit.cn/2018/03/02/%E8%B7%B3%E5%8F%B0%E9%98%B6/"/>
    <id>https://lierabbit.cn/2018/03/02/跳台阶/</id>
    <published>2018-03-02T11:17:53.000Z</published>
    <updated>2018-08-26T07:57:27.293Z</updated>
    
    <content type="html"><![CDATA[<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p><p>思路：</p><ul><li>1级台阶只有一种方式：往上走一级</li><li>2级台阶2种方式：往上走两级</li><li>3级及以上台阶：f(i)=f(i-1)+f(i-2)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloor</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (target == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> prePre = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= target; i++) &#123;</span><br><span class="line">            result = pre + prePre;</span><br><span class="line">            prePre = pre;</span><br><span class="line">            pre = result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。&lt;/p&gt;
&lt;p&gt;思路：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1级台阶只有一种方式：往上走一级&lt;/li&gt;
&lt;li&gt;2级台阶2种方式：往上走两级&lt;/li&gt;
&lt;li&gt;3级及以上台阶：f(i)=f(i-
      
    
    </summary>
    
      <category term="剑指Offer" scheme="https://lierabbit.cn/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>斐波那契数列</title>
    <link href="https://lierabbit.cn/2018/03/02/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"/>
    <id>https://lierabbit.cn/2018/03/02/斐波那契数列/</id>
    <published>2018-03-02T11:09:14.000Z</published>
    <updated>2018-08-26T07:55:57.713Z</updated>
    
    <content type="html"><![CDATA[<p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。<br>n&lt;=39<br>斐波那契数列（Fibonacci sequence），又称黄金分割数列、因数学家列昂纳多·斐波那契（Leonardoda Fibonacci）以兔子繁殖为例子而引入，故又称为“兔子数列”，指的是这样一个数列：1、1、2、3、5、8、13、21、34、……在数学上，斐波纳契数列以如下被以递归的方法定义：F(0)=0，F(1)=1, F(n)=F(n-1)+F(n-2)（n&gt;=2，n∈N*）在现代物理、准晶体结构、化学等领域，斐波纳契数列都有直接的应用，为此，美国数学会从1963年起出版了以《斐波纳契数列季刊》为名的一份数学杂志，用于专门刊载这方面的研究成果。</p><p>思路：记录f(n-1)，f(n-2)，即可得出f(n)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> prePre = <span class="number">1</span>; <span class="comment">// n - 2</span></span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">1</span>; <span class="comment">// n - 1</span></span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>; <span class="comment">// n</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            result = prePre + pre;</span><br><span class="line">            prePre = pre;</span><br><span class="line">            pre = result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。&lt;br&gt;n&amp;lt;=39&lt;br&gt;斐波那契数列（Fibonacci sequence），又称黄金分割数列、因数学家列昂纳多·斐波那契（Leonardoda Fibonacci）以兔子繁殖为例子而引入
      
    
    </summary>
    
      <category term="剑指Offer" scheme="https://lierabbit.cn/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>旋转数组的最小数字</title>
    <link href="https://lierabbit.cn/2018/03/02/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/"/>
    <id>https://lierabbit.cn/2018/03/02/旋转数组的最小数字/</id>
    <published>2018-03-02T10:21:30.000Z</published>
    <updated>2018-08-26T07:44:07.076Z</updated>
    
    <content type="html"><![CDATA[<p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p><p>思路：</p><ul><li>使用二分查找，当局部列表有序返回头元素</li><li>当局部列表有序返回头元素</li><li>当局部列表头元素小于中间元素，这里有循环，也就是有最小值，搜索左边</li><li>当局部列表中间元素小于尾元素，这里有循环，也就是有最小值，搜索右边</li><li>当局部列表头元素等于中间元素等于尾元素，遍历寻找最小值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = array.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (left + <span class="number">1</span> == right) <span class="comment">// 只剩2个数时直接比较其大小</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (array[left] &lt; array[right]) <span class="comment">// 当局部列表有序返回头</span></span><br><span class="line">            <span class="keyword">return</span> array[left];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (array[left] &gt; array[mid]) <span class="comment">// 当局部列表头元素大于中间元素，这里有循环，也就是有最小值，搜索左边</span></span><br><span class="line">            right = mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (array[mid] &gt; array[right]) <span class="comment">// 当局部列表中间元素大于尾元素，这里有循环，也就是有最小值，搜索右边</span></span><br><span class="line">            left = mid;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 当局部列表头元素等于中间元素等于尾元素，遍历寻找最小值</span></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                <span class="keyword">if</span> (array[left] == array[mid])</span><br><span class="line">                    left++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (array[left] &lt; array[mid])</span><br><span class="line">                    <span class="keyword">return</span> array[left];</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    right = mid;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Math.min(array[left], array[right]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回
      
    
    </summary>
    
      <category term="剑指Offer" scheme="https://lierabbit.cn/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>用两个栈实现队列</title>
    <link href="https://lierabbit.cn/2018/03/01/%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <id>https://lierabbit.cn/2018/03/01/用两个栈实现队列/</id>
    <published>2018-03-01T15:38:47.000Z</published>
    <updated>2018-08-26T07:41:29.710Z</updated>
    
    <content type="html"><![CDATA[<p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p><p>思路：</p><ul><li>当弹出栈不空时不能压入弹出栈</li><li>必须一次性将压入栈倒出到弹出栈</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 用两个栈实现队列 </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stack2.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack1.isEmpty())</span><br><span class="line">                stack2.add(stack1.pop());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        用两个栈实现队列 twoStackQueue = <span class="keyword">new</span> 用两个栈实现队列();</span><br><span class="line">        twoStackQueue.push(<span class="number">1</span>);</span><br><span class="line">        twoStackQueue.push(<span class="number">2</span>);</span><br><span class="line">        twoStackQueue.push(<span class="number">3</span>);</span><br><span class="line">        System.out.println(twoStackQueue.pop());</span><br><span class="line">        System.out.println(twoStackQueue.pop());</span><br><span class="line">        twoStackQueue.push(<span class="number">4</span>);</span><br><span class="line">        System.out.println(twoStackQueue.pop());</span><br><span class="line">        twoStackQueue.push(<span class="number">5</span>);</span><br><span class="line">        System.out.println(twoStackQueue.pop());</span><br><span class="line">        System.out.println(twoStackQueue.pop());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。&lt;/p&gt;
&lt;p&gt;思路：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当弹出栈不空时不能压入弹出栈&lt;/li&gt;
&lt;li&gt;必须一次性将压入栈倒出到弹出栈&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;high
      
    
    </summary>
    
      <category term="剑指Offer" scheme="https://lierabbit.cn/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>重建二叉树</title>
    <link href="https://lierabbit.cn/2018/03/01/%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://lierabbit.cn/2018/03/01/重建二叉树/</id>
    <published>2018-03-01T14:52:29.000Z</published>
    <updated>2018-08-26T07:37:42.347Z</updated>
    
    <content type="html"><![CDATA[<p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p><p>思路：每次将左右两颗子树当成新的子树进行处理，中序的左右子树索引很好找，前序的开始结束索引通过计算中序中左右子树的大小来计算，然后递归求解，直到<code>startPre&gt;endPre||startIn&gt;endIn</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span>[] pre, <span class="keyword">int</span>[] in)</span> </span>&#123;</span><br><span class="line">    TreeNode root = process(pre, <span class="number">0</span>, pre.length - <span class="number">1</span>, in, <span class="number">0</span>, in.length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">process</span><span class="params">(<span class="keyword">int</span>[] pre, <span class="keyword">int</span> startPre, <span class="keyword">int</span> endPre, <span class="keyword">int</span> in[], <span class="keyword">int</span> startIn, <span class="keyword">int</span> endIn)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (startPre &gt; endPre || startIn &gt; endIn)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 先序的每个节点都是子树的头节点</span></span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(pre[startPre]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = startIn; i &lt;= endIn; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pre[startPre] == in[i]) &#123;</span><br><span class="line">            root.left = process(pre, startPre + <span class="number">1</span>, startPre + i - startIn, in, startIn, i - <span class="number">1</span>);</span><br><span class="line">            root.right = process(pre, startPre + i - startIn + <span class="number">1</span>, endPre, in, i + <span class="number">1</span>, endIn);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。&lt;/p&gt;
&lt;p&gt;思路：每次将左右两颗子
      
    
    </summary>
    
      <category term="剑指Offer" scheme="https://lierabbit.cn/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>从尾到头打印链表</title>
    <link href="https://lierabbit.cn/2018/02/28/%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/"/>
    <id>https://lierabbit.cn/2018/02/28/从尾到头打印链表/</id>
    <published>2018-02-28T15:49:14.000Z</published>
    <updated>2018-08-26T07:24:55.235Z</updated>
    
    <content type="html"><![CDATA[<p>输入一个链表，从尾到头打印链表每个节点的值。</p><h3 id="递归到最后，在一个个的添加进List"><a href="#递归到最后，在一个个的添加进List" class="headerlink" title="递归到最后，在一个个的添加进List"></a>递归到最后，在一个个的添加进List</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    printListFromTailToHead(listNode, res);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printListFromTailToHead</span><span class="params">(ListNode node, List&lt;Integer&gt; res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">        printListFromTailToHead(node.next, res);</span><br><span class="line">        res.add(node.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用栈从头到尾装入所有节点即可，因为栈先进后出的特性，在弹出的时候就是从尾到头"><a href="#使用栈从头到尾装入所有节点即可，因为栈先进后出的特性，在弹出的时候就是从尾到头" class="headerlink" title="使用栈从头到尾装入所有节点即可，因为栈先进后出的特性，在弹出的时候就是从尾到头"></a>使用栈从头到尾装入所有节点即可，因为栈先进后出的特性，在弹出的时候就是从尾到头</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Stack&lt;ListNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    ListNode node = listNode;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">        stack.add(node);</span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!stack.empty()) &#123;</span><br><span class="line">        node = stack.pop();</span><br><span class="line">        res.add(node.val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="反转链表后再打印"><a href="#反转链表后再打印" class="headerlink" title="反转链表后再打印"></a>反转链表后再打印</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead3</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    ListNode node = reverseList(listNode);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">        res.add(node.val);</span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">    ListNode next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        next = head.next;</span><br><span class="line">        head.next = pre;</span><br><span class="line">        pre = head;</span><br><span class="line">        head = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;输入一个链表，从尾到头打印链表每个节点的值。&lt;/p&gt;
&lt;h3 id=&quot;递归到最后，在一个个的添加进List&quot;&gt;&lt;a href=&quot;#递归到最后，在一个个的添加进List&quot; class=&quot;headerlink&quot; title=&quot;递归到最后，在一个个的添加进List&quot;&gt;&lt;/a&gt;递归
      
    
    </summary>
    
      <category term="剑指Offer" scheme="https://lierabbit.cn/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>替换空格</title>
    <link href="https://lierabbit.cn/2018/02/28/%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/"/>
    <id>https://lierabbit.cn/2018/02/28/替换空格/</id>
    <published>2018-02-28T15:46:46.000Z</published>
    <updated>2018-08-26T07:22:25.618Z</updated>
    
    <content type="html"><![CDATA[<p>请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p><p>思路：<br>一、使用replaceAll<br>iniString.replaceAll(“ “,”%20”)<br>二、手动实现<br>思路：记录空格出现次数，新数组长度等于原数组长度+空格数*2，遍历原数组按规则放入新数组即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(StringBuffer str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++)</span><br><span class="line">        <span class="keyword">if</span> (str.charAt(i) == <span class="string">' '</span>)</span><br><span class="line">            count++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> charsLen = str.length() + count * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">char</span>[] chars = <span class="keyword">new</span> <span class="keyword">char</span>[charsLen];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = str.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">char</span> ch = str.charAt(i);</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">' '</span>) &#123;</span><br><span class="line">            chars[--charsLen] = <span class="string">'0'</span>;</span><br><span class="line">            chars[--charsLen] = <span class="string">'2'</span>;</span><br><span class="line">            chars[--charsLen] = <span class="string">'%'</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            chars[--charsLen] = str.charAt(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(chars);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。&lt;/p&gt;
&lt;p&gt;思路：&lt;br&gt;一、使用replaceAll&lt;br&gt;iniString.replaceAll(“ “,”%
      
    
    </summary>
    
      <category term="剑指Offer" scheme="https://lierabbit.cn/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>二维数组中的查找</title>
    <link href="https://lierabbit.cn/2018/02/28/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/"/>
    <id>https://lierabbit.cn/2018/02/28/二维数组中的查找/</id>
    <published>2018-02-28T15:31:31.000Z</published>
    <updated>2018-08-26T07:20:56.572Z</updated>
    
    <content type="html"><![CDATA[<p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p>思路：</p><ul><li>从数组的右上角开始寻找</li><li>当前数大于目前位置时，不用往左找了，因为左边的数都比当前位置的小，往下找</li><li>当前数小于目前位置时，不用往下走了，因为下面的数都比当前位置的大，往左找</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span>[][] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> col = array[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (row &lt; array.length &amp;&amp; col &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[row][col] &gt; target)</span><br><span class="line">            col--;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (array[row][col] &lt; target)</span><br><span class="line">            row++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。&lt;/p&gt;
&lt;p&gt;思路：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从数组的右上角开始寻找&lt;/li&gt;
&lt;li&gt;当前数大于目前位
      
    
    </summary>
    
      <category term="剑指Offer" scheme="https://lierabbit.cn/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>游戏</title>
    <link href="https://lierabbit.cn/2018/02/27/%E6%B8%B8%E6%88%8F/"/>
    <id>https://lierabbit.cn/2018/02/27/游戏/</id>
    <published>2018-02-27T12:19:44.000Z</published>
    <updated>2018-08-25T10:04:10.032Z</updated>
    
    <content type="html"><![CDATA[<p>A与B做游戏。 在一个n*m的矩阵中的出发点是（1，m），终点是（n,1），规则是只能向左移动一格，向下一格或向左下移动一格，先走到终点的为winner。 A先走。<br>给定两个整数n和m，请返回最后的获胜者的名字(A或B)。</p><p>测试样例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5 3</span><br><span class="line">返回：B</span><br></pre></td></tr></table></figure></p><p>思路：最优策略是两个人每次共走2格，如果A向左下2移动一格，相当于移动2格，此时B也应该向左下移动，总共是4格</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">getWinner</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="comment">// 最优策略是两个人每次共走2格，</span></span><br><span class="line">    <span class="comment">// 如果A向左下2移动一格，相当于移动2格，此时B也应该向左下移动，总共是4格</span></span><br><span class="line">    <span class="keyword">if</span> (m % <span class="number">2</span> != <span class="number">0</span> &amp;&amp; n % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'B'</span>;<span class="comment">// // 此时B距离终点只有1格</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'A'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;A与B做游戏。 在一个n*m的矩阵中的出发点是（1，m），终点是（n,1），规则是只能向左移动一格，向下一格或向左下移动一格，先走到终点的为winner。 A先走。&lt;br&gt;给定两个整数n和m，请返回最后的获胜者的名字(A或B)。&lt;/p&gt;
&lt;p&gt;测试样例：&lt;br&gt;&lt;figur
      
    
    </summary>
    
      <category term="直通BAT面试算法" scheme="https://lierabbit.cn/categories/%E7%9B%B4%E9%80%9ABAT%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数组清空</title>
    <link href="https://lierabbit.cn/2018/02/27/%E6%95%B0%E7%BB%84%E6%B8%85%E7%A9%BA/"/>
    <id>https://lierabbit.cn/2018/02/27/数组清空/</id>
    <published>2018-02-27T12:08:20.000Z</published>
    <updated>2018-08-25T10:00:51.924Z</updated>
    
    <content type="html"><![CDATA[<p>现在有一个整数数组，其元素值均为1-n范围内的某个整数，现在你和你的朋友在玩一个游戏，游戏的目的是把数组清空，你们轮流操作，你是先手，每次操作你可以删除数组中值为某个数的元素任意多个(当然数组中值为这个数的元素个数应大于等于你删除的个数,且你至少要删除一个数)。最先把数组清空的人获得胜利。假设你们都采取最优策略，请你计算你能否获得胜利。<br>给定一个整数数组A和元素个数n。请返回一个整数，1代表你能获胜，0代表你不能获胜。</p><p>测试样例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1,1,1]</span><br><span class="line">返回：1</span><br></pre></td></tr></table></figure></p><p>思路：最优策略为和对方删除同样数量的元素，导致最后留下只能两次删除完所有元素，这样在对方再走一步后你就获胜了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWinner</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计所有数字出现次数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : A)</span><br><span class="line">        map.merge(num, <span class="number">1</span>, (a, b) -&gt; a + b);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将所有次数进行异或运算</span></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> count : map.values()) &#123;</span><br><span class="line">        res ^= count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出现次数成对则为0</span></span><br><span class="line">    <span class="keyword">return</span> res != <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;现在有一个整数数组，其元素值均为1-n范围内的某个整数，现在你和你的朋友在玩一个游戏，游戏的目的是把数组清空，你们轮流操作，你是先手，每次操作你可以删除数组中值为某个数的元素任意多个(当然数组中值为这个数的元素个数应大于等于你删除的个数,且你至少要删除一个数)。最先把数组清
      
    
    </summary>
    
      <category term="直通BAT面试算法" scheme="https://lierabbit.cn/categories/%E7%9B%B4%E9%80%9ABAT%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>跳格子</title>
    <link href="https://lierabbit.cn/2018/02/27/%E8%B7%B3%E6%A0%BC%E5%AD%90/"/>
    <id>https://lierabbit.cn/2018/02/27/跳格子/</id>
    <published>2018-02-27T08:54:47.000Z</published>
    <updated>2018-08-25T09:54:01.466Z</updated>
    
    <content type="html"><![CDATA[<p>你和你的朋友正在玩棋子跳格子的游戏，而棋盘是一个由n个格子组成的长条，你们两人轮流移动一颗棋子，每次可以选择让棋子跳1-3格，先将棋子移出棋盘的人获得胜利。我们知道你们两人都会采取最优策略，现在已知格子数目，并且初始时棋子在第一格由你操作。请你计算你是否能获胜。<br>给定格子的数目n(n为不超过300的正整数)。返回一个整数，1代表能获胜，0代表不能获胜。</p><p>测试样例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">返回：1</span><br></pre></td></tr></table></figure></p><p>思路： 通过列举1、2、3、4格的情况发现，只要轮到我的时候还剩4格，我必输无疑，因为无论我选择走多少格对方都可以一次走出棋盘。更巧的是，无论我走多少格，对方都可以选择走一种格数来使这一回合凑齐4格。因此，只要总格数是4的整数倍，我就必输无疑。而在其他任何种格数下，在走第一步的时候我都可以选择走一种格数使得剩下的格数为4的整数倍，这样对方就必输无疑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">checkWin</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">return</span> (n - <span class="number">1</span>) % <span class="number">4</span> == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;你和你的朋友正在玩棋子跳格子的游戏，而棋盘是一个由n个格子组成的长条，你们两人轮流移动一颗棋子，每次可以选择让棋子跳1-3格，先将棋子移出棋盘的人获得胜利。我们知道你们两人都会采取最优策略，现在已知格子数目，并且初始时棋子在第一格由你操作。请你计算你是否能获胜。&lt;br&gt;给定
      
    
    </summary>
    
      <category term="直通BAT面试算法" scheme="https://lierabbit.cn/categories/%E7%9B%B4%E9%80%9ABAT%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>赛马</title>
    <link href="https://lierabbit.cn/2018/02/27/%E8%B5%9B%E9%A9%AC/"/>
    <id>https://lierabbit.cn/2018/02/27/赛马/</id>
    <published>2018-02-27T08:43:49.000Z</published>
    <updated>2018-08-25T09:50:20.935Z</updated>
    
    <content type="html"><![CDATA[<p>作为一个马场的主人，你要安排你的n匹赛马和另一个马场的n匹马比赛。你已经知道了对方马场的出战表，即参加每一场的马的强壮程度。当然你也知道你自己的所有马的强壮程度。我们假定比赛的结果直接由马的强壮程度决定，即更壮的马获胜(若相同则双方均不算获胜)，请你设计一个策略，使你能获得尽量多的场次的胜利。<br>给定对方每场比赛的马的强壮程度oppo及你的所有马的强壮程度horses(强壮程度为整数，且数字越大越强壮)同时给定n，请返回最多能获胜的场次。</p><p>测试样例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1,2,3],[1,2,3],3</span><br><span class="line">返回：2</span><br></pre></td></tr></table></figure></p><p>思路：和田忌赛马类似，用最强的马与能赢别人的最强的马比</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">winMost</span><span class="params">(<span class="keyword">int</span>[] oppo, <span class="keyword">int</span>[] horses, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    Arrays.sort(oppo);</span><br><span class="line">    Arrays.sort(horses);</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        <span class="keyword">if</span> (horses[n - res - <span class="number">1</span>] &gt; oppo[i])</span><br><span class="line">            res++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;作为一个马场的主人，你要安排你的n匹赛马和另一个马场的n匹马比赛。你已经知道了对方马场的出战表，即参加每一场的马的强壮程度。当然你也知道你自己的所有马的强壮程度。我们假定比赛的结果直接由马的强壮程度决定，即更壮的马获胜(若相同则双方均不算获胜)，请你设计一个策略，使你能获得
      
    
    </summary>
    
      <category term="直通BAT面试算法" scheme="https://lierabbit.cn/categories/%E7%9B%B4%E9%80%9ABAT%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>涂色</title>
    <link href="https://lierabbit.cn/2018/02/27/%E6%B6%82%E8%89%B2/"/>
    <id>https://lierabbit.cn/2018/02/27/涂色/</id>
    <published>2018-02-27T08:26:06.000Z</published>
    <updated>2018-08-25T09:45:21.943Z</updated>
    
    <content type="html"><![CDATA[<p>你要在一个nxm的格子图上涂色，你每次可以选择一个未涂色的格子涂上你开始选定的那种颜色。同时为了美观，我们要求你涂色的格子不能相邻，也就是说，不能有公共边，现在问你，在采取最优策略的情况下，你最多能涂多少个格子？<br>给定格子图的长n和宽m。请返回最多能涂的格子数目。</p><p>测试样例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1,2</span><br><span class="line">返回：1</span><br></pre></td></tr></table></figure></p><p>思路：<br>只有一种颜色，要想不相邻，每行一个隔一个涂色即可，如果行数或者列数为偶数，最多的格子即为(m / 2) <em> n或者(n / 2) </em> m，显然就是m <em> n / 2<br>如果行列均不为偶数，假设多加一列，则最大格子就为((n + 1) / 2) </em> m,然后需要减去多加的格子数为(m - 1) / 2,两式合并即为(n <em> m + 1) / 2<br>又由int除法特性，可以将两式合并为(n </em> m + 1) / 2,即为所求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMost</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">return</span> (n * m + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;你要在一个nxm的格子图上涂色，你每次可以选择一个未涂色的格子涂上你开始选定的那种颜色。同时为了美观，我们要求你涂色的格子不能相邻，也就是说，不能有公共边，现在问你，在采取最优策略的情况下，你最多能涂多少个格子？&lt;br&gt;给定格子图的长n和宽m。请返回最多能涂的格子数目。&lt;/
      
    
    </summary>
    
      <category term="直通BAT面试算法" scheme="https://lierabbit.cn/categories/%E7%9B%B4%E9%80%9ABAT%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>最优编辑</title>
    <link href="https://lierabbit.cn/2018/02/27/%E6%9C%80%E4%BC%98%E7%BC%96%E8%BE%91/"/>
    <id>https://lierabbit.cn/2018/02/27/最优编辑/</id>
    <published>2018-02-27T08:03:25.000Z</published>
    <updated>2018-08-25T09:29:01.079Z</updated>
    
    <content type="html"><![CDATA[<p>对于两个字符串A和B，我们需要进行插入、删除和修改操作将A串变为B串，定义c0，c1，c2分别为三种操作的代价，请设计一个高效算法，求出将A串变为B串所需要的最少代价。<br>给定两个字符串A和B，及它们的长度和三种操作代价，请返回将A串变为B串所需要的最小代价。保证两串长度均小于等于300，且三种代价值均小于等于100。</p><p>测试样例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;abc&quot;,3,&quot;adc&quot;,3,5,3,100</span><br><span class="line">返回：8</span><br></pre></td></tr></table></figure></p><p>思路：<br><img src="https://blog-1252204470.cos.ap-guangzhou.myqcloud.com/2018/02/27/%E6%9C%80%E4%BC%98%E7%BC%96%E8%BE%91/1.jpg" alt=""><br>下面具体说明dp矩阵每个位置的值是如何计算的:</p><ol><li>dp[0][0]设置为0，表示str1空的子串编辑成str2空的子串，故代价为0。</li><li>矩阵dp第一列即dp[0..M][0],dp[i][0]表示str1[0.i-1]编辑成空串的最小代价，即把str1[0..i-1]所有字符都删掉的代价，故dp[i][0]=dc*i。</li><li>矩阵dp第一行即dp[0][0..N]。dp[0][j]表示空串编辑成str2[0.j-1]的最小代价，即在空串里插入str2[0..j-1]的所有字符的代价，故dp[0][j]=ic*j。</li><li>其他位置按照先从左到右，再从上到下来计算，dp[i][j]的值只可能来自以下四种情况:<br>(1) str1[0..i-1]可以先编辑成str1[0..i-2] 也就是删除字符str1[i-1],然后由str1[0..i-2]编辑成str2[0..j-1] dp[i-1][j]就表示str1[0..i-2]编辑成str2[0..j-1]的最小代价，那么dp[i][j]可能等于dc+dp[i-1][j].<br>(2) str1[0..i-1]可以先编辑成str2[0.j-2],然后将str2[0..j-2]插入字符str2[j-1],编辑成str2[0..j-1] dp[i][j-1]表示str1[0..i-1]编辑成str2[0..j-2]的最小代价，那么dp[i][j]可能等于dp[ij][j-1]+ic.<br>(3) 如果str1[i-1]!=str2[j-1].先把str1[0..i-1]中str1[0..i-2]的部分变成str2[0..j-2],然后把字符str1[i-1]替换成str2[j-1],这样str1[0..i-1]就编辑成str2[0..j-1]了.dp[i-1][j-1]就表示str1[0.i-2]编辑成str2[0.i-2]的最小代价，那么dp[i][j]可能等于dp[i-1][j-1] +rC。<br>(4) 如果str1[i-1]==str2[j-1],先把str1[0..i-1]中str1[0..i-2]的部分变成str2[0.j-2],因为此时字符str1[i-1]等于str2[j-1],所以str1[0..i-1]已经编辑成str2[0.j-1]了。dp[i-1][j-1]就表示str1[0.i-2]编辑成str2[0.i-2]的最小代价，那么dp[i]j]可能等于dp[i-1j[j-1].<br>以上四种可能的值中，选最小值作为dp[i][j]的值。</li><li>最终结果返回dp最右下角的值</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMinCost</span><span class="params">(String str1, <span class="keyword">int</span> n, String str2, <span class="keyword">int</span> m, <span class="keyword">int</span> ic, <span class="keyword">int</span> dc, <span class="keyword">int</span> rc)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> col = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化列</span></span><br><span class="line">    <span class="keyword">while</span> (row &lt;= n) &#123;</span><br><span class="line">        dp[row][<span class="number">0</span>] = row * dc;</span><br><span class="line">        row++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化行</span></span><br><span class="line">    <span class="keyword">while</span> (col &lt;= m) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][col] = col * ic;</span><br><span class="line">        col++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (row = <span class="number">1</span>; row &lt;= n; row++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (col = <span class="number">1</span>; col &lt;= m; col++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str1.charAt(row - <span class="number">1</span>) == str2.charAt(col - <span class="number">1</span>))</span><br><span class="line">                dp[row][col] = Math.min(dp[row - <span class="number">1</span>][col] + dc, Math.min(dp[row][col - <span class="number">1</span>] + ic, dp[row - <span class="number">1</span>][col - <span class="number">1</span>]));</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[row][col] = Math.min(dp[row - <span class="number">1</span>][col] + dc, Math.min(dp[row][col - <span class="number">1</span>] + ic, dp[row - <span class="number">1</span>][col - <span class="number">1</span>] + rc));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[n][m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对于两个字符串A和B，我们需要进行插入、删除和修改操作将A串变为B串，定义c0，c1，c2分别为三种操作的代价，请设计一个高效算法，求出将A串变为B串所需要的最少代价。&lt;br&gt;给定两个字符串A和B，及它们的长度和三种操作代价，请返回将A串变为B串所需要的最小代价。保证两串长
      
    
    </summary>
    
      <category term="直通BAT面试算法" scheme="https://lierabbit.cn/categories/%E7%9B%B4%E9%80%9ABAT%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>01背包</title>
    <link href="https://lierabbit.cn/2018/02/27/01%E8%83%8C%E5%8C%85/"/>
    <id>https://lierabbit.cn/2018/02/27/01背包/</id>
    <published>2018-02-27T05:56:21.000Z</published>
    <updated>2018-08-25T09:24:56.788Z</updated>
    
    <content type="html"><![CDATA[<p>一个背包有一定的承重cap，有N件物品，每件都有自己的价值，记录在数组v中，也都有自己的重量，记录在数组w中，每件物品只能选择要装入背包还是不装入背包，要求在不超过背包承重的前提下，选出物品的总价值最大。<br>给定物品的重量w价值v及物品数n和承重cap。请返回最大总价值。</p><p>测试样例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1,2,3],[1,2,3],3,6</span><br><span class="line">返回：6</span><br></pre></td></tr></table></figure></p><p>思路：物品编号从1到n，一件一件物品考虑是否加入背包。<br>假设dp[x] [y]表示前x件物品，不超过重量y的时候的最大价值。枚举一下第x件物品的情况:<br>情况一:如果选择第x件物品，则前X-1件物品得到的重量不能超过y-w[x]。<br>情况二:如果不选第x件物品，则前X-1件物品得到的重量不能超过y。<br>所以，dp[x] [y]可能等于dp[x-1][y],也就是不取第x件物品的时，价值和之前一样。<br>也可能是dp[x-1][y-w[x]] +v[x]，也就是决定拿第x件物品的情况，当然会获得x物品的价值。<br>两种可能性中，应该选择价值最大的那个。dp[x][y]=max{dp[x-1][y],dp[x-1][y-w[x]]+v[x]}。<br>对于dp矩阵来说，行数是物品的数量n，行数是背包的重量W。从左到右，再从上到下依次计算所有的dp值即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(<span class="keyword">int</span>[] w, <span class="keyword">int</span>[] v, <span class="keyword">int</span> n, <span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][cap + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> row;</span><br><span class="line">    <span class="keyword">int</span> col = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化列</span></span><br><span class="line">    <span class="keyword">while</span> (col &lt;= cap) &#123;</span><br><span class="line">        <span class="keyword">if</span> (col &gt;= w[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        col++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (col &lt;= cap)</span><br><span class="line">        dp[<span class="number">0</span>][col++] = v[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (row = <span class="number">1</span>; row &lt; n; row++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (col = <span class="number">1</span>; col &lt;= cap; col++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (col - w[row] &lt; <span class="number">0</span>)</span><br><span class="line">                dp[row][col] = dp[row - <span class="number">1</span>][col];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[row][col] = Math.max(dp[row - <span class="number">1</span>][col - w[row]] + v[row], dp[row - <span class="number">1</span>][col]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[n - <span class="number">1</span>][cap];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一个背包有一定的承重cap，有N件物品，每件都有自己的价值，记录在数组v中，也都有自己的重量，记录在数组w中，每件物品只能选择要装入背包还是不装入背包，要求在不超过背包承重的前提下，选出物品的总价值最大。&lt;br&gt;给定物品的重量w价值v及物品数n和承重cap。请返回最大总价值
      
    
    </summary>
    
      <category term="直通BAT面试算法" scheme="https://lierabbit.cn/categories/%E7%9B%B4%E9%80%9ABAT%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LCS（最长公共子序列）</title>
    <link href="https://lierabbit.cn/2018/02/27/LCS%EF%BC%88%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%EF%BC%89/"/>
    <id>https://lierabbit.cn/2018/02/27/LCS（最长公共子序列）/</id>
    <published>2018-02-27T05:14:01.000Z</published>
    <updated>2018-08-25T09:20:13.004Z</updated>
    
    <content type="html"><![CDATA[<p>给定两个字符串A和B，返回两个字符串的最长公共子序列的长度。例如，A=”1A2C3D4B56”，B=”B1D23CA45B6A”，”123456”或者”12C4B6”都是最长公共子序列。<br>给定两个字符串A和B，同时给定两个串的长度n和m，请返回最长公共子序列的长度。保证两串长度均小于等于300。</p><p>测试样例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;1A2C3D4B56&quot;,10,&quot;B1D23CA45B6A&quot;,12</span><br><span class="line">返回：6</span><br></pre></td></tr></table></figure></p><p>思路：</p><ol><li>矩阵dp第一列，即dp[i][0],代表str1[0..i]与str2[0]的最长公共子序列长度。str2[0]只有一个字符，所以dp[i][0]最大为1。如果str1[i]==str2[0],则令dp[i][0]为1，一旦dp[i][0]被设为1，则令dp[i+1..M][0]全部为1</li><li>矩阵dp第一行，即dp[0][j]，与步骤1同理。如果str1[0]==str2[j],则令dp[0][j]为1，一旦dp[0][j]被设为1，则令dp[0][j+1..N]全部为1</li><li>其他位置，dp[i][j]的值只可能来自以下三种情况:<br>情况一:可能是dp[i-1][j]的值。这代表str1[0..i-1]与str2[0..j]的最长公共子序列长度。<br>举例:str1=”A1BC2”，str2=”AB34C”。str1[0..3]为” A1BC”,str2[0..4]为” AB34C”，这两部分最长公共子序列为”ABC”即dp[3][4]为3。str1整体和str2整体最长公共子序列也是”ABC”，所以dp[4][4]可能来自dp[3][4].<br>情况二:同理可知，dp[i][j]的值也可能是dp[i][j-1].<br>情况三:如果str1[i]==str2[j],还可能是dp[i-1][j-1]+1的值。<br>举例:比如str1=”ABCD”,str2=”ABCD”.str1[0..2]即”ABC”与str2[0..2]即”ABC”的最长公共子序列为”ABC”，也就是dp[2][2]为3。因为str1和str2的最后一个字符都是” D”，所以dp[i][j]=dp[i-1][j-1]+1.<br>三种可能的值中，选最大值作为dp[i][j]的值。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLCS</span><span class="params">(String A, <span class="keyword">int</span> n, String B, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">if</span> (A == <span class="keyword">null</span> || A.length() == <span class="number">0</span> || B == <span class="keyword">null</span> || B.length() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][m];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化列</span></span><br><span class="line">    <span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (row &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (B.charAt(<span class="number">0</span>) == A.charAt(row)) &#123;</span><br><span class="line">            dp[row][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            row++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            dp[row][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        row++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (row &lt; n)</span><br><span class="line">        dp[row++][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化行</span></span><br><span class="line">    <span class="keyword">int</span> col = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (col &lt; m) &#123;</span><br><span class="line">        <span class="keyword">if</span> (A.charAt(<span class="number">0</span>) == B.charAt(col)) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][col] = <span class="number">1</span>;</span><br><span class="line">            col++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            dp[<span class="number">0</span>][col] = <span class="number">0</span>;</span><br><span class="line">        col++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (col &lt; m)</span><br><span class="line">        dp[<span class="number">0</span>][col++] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (row = <span class="number">1</span>; row &lt; n; row++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (col = <span class="number">1</span>; col &lt; m; col++) &#123;</span><br><span class="line">            <span class="keyword">int</span> max = Math.max(dp[row - <span class="number">1</span>][col], dp[row][col - <span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span> (A.charAt(row) == B.charAt(col))</span><br><span class="line">                max = Math.max(max, dp[row - <span class="number">1</span>][col - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">            dp[row][col] = max;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[row - <span class="number">1</span>][col - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定两个字符串A和B，返回两个字符串的最长公共子序列的长度。例如，A=”1A2C3D4B56”，B=”B1D23CA45B6A”，”123456”或者”12C4B6”都是最长公共子序列。&lt;br&gt;给定两个字符串A和B，同时给定两个串的长度n和m，请返回最长公共子序列的长度。保
      
    
    </summary>
    
      <category term="直通BAT面试算法" scheme="https://lierabbit.cn/categories/%E7%9B%B4%E9%80%9ABAT%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LIS（最长上升子序列）</title>
    <link href="https://lierabbit.cn/2018/02/27/LIS%EF%BC%88%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%EF%BC%89/"/>
    <id>https://lierabbit.cn/2018/02/27/LIS（最长上升子序列）/</id>
    <published>2018-02-27T05:06:20.000Z</published>
    <updated>2018-08-25T09:12:31.522Z</updated>
    
    <content type="html"><![CDATA[<p>这是一个经典的LIS(即最长上升子序列)问题，请设计一个尽量优的解法求出序列的最长上升子序列的长度。<br>给定一个序列A及它的长度n(长度小于等于500)，请返回LIS的长度。</p><p>测试样例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1,4,2,5,3],5</span><br><span class="line">返回：3</span><br></pre></td></tr></table></figure></p><p>思路：记录以每一个数结尾的最大上升子序列长度，取最大的即为结果<br>maxs[i]表示以maxs[i]结尾的最大上升子序列长度，maxs[i] = 前面所有比它小的数的最大上升子序列长度中最大的+1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLIS</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] maxs = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    maxs[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> maxLen = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; i; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; arr[k])</span><br><span class="line">                max = Math.max(max, maxs[k] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        maxs[i] = max;</span><br><span class="line">        maxLen = Math.max(maxLen, max);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这是一个经典的LIS(即最长上升子序列)问题，请设计一个尽量优的解法求出序列的最长上升子序列的长度。&lt;br&gt;给定一个序列A及它的长度n(长度小于等于500)，请返回LIS的长度。&lt;/p&gt;
&lt;p&gt;测试样例：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;
      
    
    </summary>
    
      <category term="直通BAT面试算法" scheme="https://lierabbit.cn/categories/%E7%9B%B4%E9%80%9ABAT%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>矩阵最小路径和</title>
    <link href="https://lierabbit.cn/2018/02/26/%E7%9F%A9%E9%98%B5%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/"/>
    <id>https://lierabbit.cn/2018/02/26/矩阵最小路径和/</id>
    <published>2018-02-26T15:34:42.000Z</published>
    <updated>2018-08-25T09:08:32.395Z</updated>
    
    <content type="html"><![CDATA[<p>有一个矩阵map，它每个格子有一个权值。从左上角的格子开始每次只能向右或者向下走，最后到达右下角的位置，路径上所有的数字累加起来就是路径和，返回所有的路径中最小的路径和。<br>给定一个矩阵map及它的行数n和列数m，请返回最小路径和。保证行列数均小于等于100.</p><p>测试样例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[1,2,3],[1,1,1]],2,3</span><br><span class="line">返回：4</span><br></pre></td></tr></table></figure></p><p>思路：<br><img src="https://blog-1252204470.cos.ap-guangzhou.myqcloud.com/2018/02/26/%E7%9F%A9%E9%98%B5%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/1.jpg" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">(<span class="keyword">int</span>[][] map, <span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][m];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; n; row++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (row == <span class="number">0</span>)</span><br><span class="line">            dp[row][<span class="number">0</span>] = map[row][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            dp[row][<span class="number">0</span>] = dp[row - <span class="number">1</span>][<span class="number">0</span>] + map[row][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">1</span>; col &lt; m; col++)</span><br><span class="line">        dp[<span class="number">0</span>][col] = dp[<span class="number">0</span>][col - <span class="number">1</span>] + map[<span class="number">0</span>][col];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">1</span>; row &lt; n; row++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">1</span>; col &lt; m; col++) &#123;</span><br><span class="line">            dp[row][col] = map[row][col] + Math.min(dp[row - <span class="number">1</span>][col], dp[row][col - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[n - <span class="number">1</span>][m - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有一个矩阵map，它每个格子有一个权值。从左上角的格子开始每次只能向右或者向下走，最后到达右下角的位置，路径上所有的数字累加起来就是路径和，返回所有的路径中最小的路径和。&lt;br&gt;给定一个矩阵map及它的行数n和列数m，请返回最小路径和。保证行列数均小于等于100.&lt;/p&gt;

      
    
    </summary>
    
      <category term="直通BAT面试算法" scheme="https://lierabbit.cn/categories/%E7%9B%B4%E9%80%9ABAT%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
