<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>谎话兔博客</title>
  
  <subtitle>LieRabbit</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://lierabbit.cn/"/>
  <updated>2018-08-26T09:50:23.587Z</updated>
  <id>https://lierabbit.cn/</id>
  
  <author>
    <name>谎话兔</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>链表中倒数第k个节点</title>
    <link href="https://lierabbit.cn/2018/03/04/%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
    <id>https://lierabbit.cn/2018/03/04/链表中倒数第k个节点/</id>
    <published>2018-03-04T05:09:59.000Z</published>
    <updated>2018-08-26T09:50:23.587Z</updated>
    
    <content type="html"><![CDATA[<p>输入一个链表，输出该链表中倒数第k个结点。</p><p>思路：使用pre,cur两个指针，初始化都为头节点，让pre先走k-1步，若中途走到尾了则没有倒数第K个节点，因为k&gt;链表长度。然后再让两个指针同时走，当pre到尾了则cur就是倒数第K个节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">FindKthToTail</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || k &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    ListNode pre = head; <span class="comment">// 先走的指针</span></span><br><span class="line">    ListNode cur = head; <span class="comment">// 当前的指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// pre先走k-1步</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pre.next != <span class="keyword">null</span>)</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当pre到尾cur就是倒数第K个节点</span></span><br><span class="line">    <span class="keyword">while</span> (pre.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        pre = pre.next;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;输入一个链表，输出该链表中倒数第k个结点。&lt;/p&gt;
&lt;p&gt;思路：使用pre,cur两个指针，初始化都为头节点，让pre先走k-1步，若中途走到尾了则没有倒数第K个节点，因为k&amp;gt;链表长度。然后再让两个指针同时走，当pre到尾了则cur就是倒数第K个节点&lt;/p&gt;
&lt;fig
      
    
    </summary>
    
      <category term="剑指Offer" scheme="https://lierabbit.cn/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>调整数组顺序使奇数位于偶数前面</title>
    <link href="https://lierabbit.cn/2018/03/04/%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/"/>
    <id>https://lierabbit.cn/2018/03/04/调整数组顺序使奇数位于偶数前面/</id>
    <published>2018-03-04T04:14:13.000Z</published>
    <updated>2018-08-26T09:48:42.472Z</updated>
    
    <content type="html"><![CDATA[<p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p><p>思路：首先统计奇数的个数，然后新建一个等长数组，设置两个指针，奇数指针从0开始，偶数指针从奇数个数的末尾开始 遍历，填数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reOrderArray</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length == <span class="number">0</span> || array.length == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>; <span class="comment">// 记录奇数出现次数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> a : array)</span><br><span class="line">        <span class="keyword">if</span> (a % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">            count++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[array.length]; <span class="comment">// 新建数组装入奇数和偶数</span></span><br><span class="line">    <span class="keyword">int</span> pre = <span class="number">0</span>; <span class="comment">// 从头开始</span></span><br><span class="line">    <span class="keyword">int</span> back = count; <span class="comment">// 从最后一个奇数后面开始</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> a : array)</span><br><span class="line">        <span class="keyword">if</span> (a % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">            temp[back++] = a;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            temp[pre++] = a;</span><br><span class="line"></span><br><span class="line">    System.arraycopy(temp, <span class="number">0</span>, array, <span class="number">0</span>, array.length); <span class="comment">// 复制temp到array</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。&lt;/p&gt;
&lt;p&gt;思路：首先统计奇数的个数，然后新建一个等长数组，设置两个指针，奇数指针从0开始，偶数指
      
    
    </summary>
    
      <category term="剑指Offer" scheme="https://lierabbit.cn/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数组的整数次方</title>
    <link href="https://lierabbit.cn/2018/03/03/%E6%95%B0%E7%BB%84%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/"/>
    <id>https://lierabbit.cn/2018/03/03/数组的整数次方/</id>
    <published>2018-03-03T15:42:07.000Z</published>
    <updated>2018-08-26T09:46:23.273Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</p><p>思路：<br><img src="https://blog-1252204470.cos.ap-guangzhou.myqcloud.com/2018/03/03/%E6%95%B0%E7%BB%84%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/1.jpg" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">double</span> temp = base;</span><br><span class="line">    <span class="keyword">boolean</span> isNegative;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (exponent &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        exponent = -exponent;</span><br><span class="line">        isNegative = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        isNegative = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (exponent != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((exponent &amp; <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">            result *= temp;</span><br><span class="line">        temp *= temp;</span><br><span class="line">        exponent &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isNegative ? <span class="number">1</span> / result : result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。&lt;/p&gt;
&lt;p&gt;思路：&lt;br&gt;&lt;img src=&quot;https://blog-1252204470.cos.ap-guangzhou.myqcloud.com/201
      
    
    </summary>
    
      <category term="剑指Offer" scheme="https://lierabbit.cn/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>二进制中1的个数</title>
    <link href="https://lierabbit.cn/2018/03/02/%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
    <id>https://lierabbit.cn/2018/03/02/二进制中1的个数/</id>
    <published>2018-03-02T15:15:50.000Z</published>
    <updated>2018-08-26T09:40:08.490Z</updated>
    
    <content type="html"><![CDATA[<p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p><h3 id="方法一：与1进行-amp-运算，无符号右移一位"><a href="#方法一：与1进行-amp-运算，无符号右移一位" class="headerlink" title="方法一：与1进行&amp;运算，无符号右移一位"></a>方法一：与1进行&amp;运算，无符号右移一位</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">            count++;</span><br><span class="line">        n &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法二：如果一个整数不为0，那么这个整数至少有一位是1。如果我们把这个整数减1，那么原来处在整数最右边的1就会变为0，原来在1后面的所有的0都会变成1-如果最右边的1后面还有0的话-。其余所有位将不会受到影响。"><a href="#方法二：如果一个整数不为0，那么这个整数至少有一位是1。如果我们把这个整数减1，那么原来处在整数最右边的1就会变为0，原来在1后面的所有的0都会变成1-如果最右边的1后面还有0的话-。其余所有位将不会受到影响。" class="headerlink" title="方法二：如果一个整数不为0，那么这个整数至少有一位是1。如果我们把这个整数减1，那么原来处在整数最右边的1就会变为0，原来在1后面的所有的0都会变成1(如果最右边的1后面还有0的话)。其余所有位将不会受到影响。"></a>方法二：如果一个整数不为0，那么这个整数至少有一位是1。如果我们把这个整数减1，那么原来处在整数最右边的1就会变为0，原来在1后面的所有的0都会变成1(如果最右边的1后面还有0的话)。其余所有位将不会受到影响。</h3><p>举个例子：一个二进制数1100，从右边数起第三位是处于最右边的一个1。减去1后，第三位变成0，它后面的两位0变成了1，而前面的1保持不变，因此得到的结果是1011.我们发现减1的结果是把最右边的一个1开始的所有位都取反了。这个时候如果我们再把原来的整数和减去1之后的结果做与运算，从原来整数最右边一个1那一位开始所有位都会变成0。如1100&amp;1011=1000.也就是说，把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0.那么一个整数的二进制有多少个1，就可以进行多少次这样的操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        n = n &amp; (n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。&lt;/p&gt;
&lt;h3 id=&quot;方法一：与1进行-amp-运算，无符号右移一位&quot;&gt;&lt;a href=&quot;#方法一：与1进行-amp-运算，无符号右移一位&quot; class=&quot;headerlink&quot; title=&quot;方法一：与1
      
    
    </summary>
    
      <category term="剑指Offer" scheme="https://lierabbit.cn/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>矩形覆盖</title>
    <link href="https://lierabbit.cn/2018/03/02/%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%96/"/>
    <id>https://lierabbit.cn/2018/03/02/矩形覆盖/</id>
    <published>2018-03-02T13:16:17.000Z</published>
    <updated>2018-08-26T08:14:33.045Z</updated>
    
    <content type="html"><![CDATA[<p>我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？</p><p>思路：<br>依旧是斐波那契数列<br>2*n的大矩形，和n个2*1的小矩形<br>其中target*2为大矩阵的大小<br>有以下几种情形： </p><ul><li>target &lt;= 0 大矩形为&lt;= 2*0,直接return 1； </li><li>target = 1大矩形为2*1，只有一种摆放方法，return1； </li><li>target = 2 大矩形为2*2，有两种摆放方法，return2； </li><li>target = n 分为两步考虑：<br>第一次摆放一块 2*1 的小矩阵（用YY表示），则摆放方法总共为f(target - 1)</li></ul><table><thead><tr><th style="text-align:center">Y</th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center">Y</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table><p>第一次摆放一块1*2的小矩阵，则摆放方法总共为f(target-2)<br>因为，摆放了一块1*2的小矩阵（用YY表示），对应下方的1*2（用XX表示）摆放方法就确定了，所以为f(targte-2) </p><table><thead><tr><th style="text-align:center">Y</th><th style="text-align:center">Y</th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center">X</td><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table><p>则f(targte) = f(target-1) + f(target-2)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">RectCover</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (target == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (target == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> prePre = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= target; i++) &#123;</span><br><span class="line">            res = pre + prePre;</span><br><span class="line">            prePre = pre;</span><br><span class="line">            pre = res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？&lt;/p&gt;
&lt;p&gt;思路：&lt;br&gt;依旧是斐波那契数列&lt;br&gt;2*n的大矩形，和n个2*1的小矩形&lt;br&gt;其中target*2为大矩阵的大小&lt;br&gt;有以
      
    
    </summary>
    
      <category term="剑指Offer" scheme="https://lierabbit.cn/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>变态跳台阶</title>
    <link href="https://lierabbit.cn/2018/03/02/%E5%8F%98%E6%80%81%E8%B7%B3%E5%8F%B0%E9%98%B6/"/>
    <id>https://lierabbit.cn/2018/03/02/变态跳台阶/</id>
    <published>2018-03-02T12:52:02.000Z</published>
    <updated>2018-08-26T07:59:05.249Z</updated>
    
    <content type="html"><![CDATA[<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级，它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p><p>思路：每个台阶都有跳与不跳两种情况（除了最后一个台阶），最后一个台阶必须跳。所以共用2^(n-1)中情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloorII</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) Math.pow(<span class="number">2</span>, target - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一只青蛙一次可以跳上1级台阶，也可以跳上2级，它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。&lt;/p&gt;
&lt;p&gt;思路：每个台阶都有跳与不跳两种情况（除了最后一个台阶），最后一个台阶必须跳。所以共用2^(n-1)中情况&lt;/p&gt;
&lt;figure class=&quot;hig
      
    
    </summary>
    
      <category term="剑指Offer" scheme="https://lierabbit.cn/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>跳台阶</title>
    <link href="https://lierabbit.cn/2018/03/02/%E8%B7%B3%E5%8F%B0%E9%98%B6/"/>
    <id>https://lierabbit.cn/2018/03/02/跳台阶/</id>
    <published>2018-03-02T11:17:53.000Z</published>
    <updated>2018-08-26T07:57:27.293Z</updated>
    
    <content type="html"><![CDATA[<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p><p>思路：</p><ul><li>1级台阶只有一种方式：往上走一级</li><li>2级台阶2种方式：往上走两级</li><li>3级及以上台阶：f(i)=f(i-1)+f(i-2)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloor</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (target == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> prePre = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= target; i++) &#123;</span><br><span class="line">            result = pre + prePre;</span><br><span class="line">            prePre = pre;</span><br><span class="line">            pre = result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。&lt;/p&gt;
&lt;p&gt;思路：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1级台阶只有一种方式：往上走一级&lt;/li&gt;
&lt;li&gt;2级台阶2种方式：往上走两级&lt;/li&gt;
&lt;li&gt;3级及以上台阶：f(i)=f(i-
      
    
    </summary>
    
      <category term="剑指Offer" scheme="https://lierabbit.cn/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>斐波那契数列</title>
    <link href="https://lierabbit.cn/2018/03/02/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"/>
    <id>https://lierabbit.cn/2018/03/02/斐波那契数列/</id>
    <published>2018-03-02T11:09:14.000Z</published>
    <updated>2018-08-26T07:55:57.713Z</updated>
    
    <content type="html"><![CDATA[<p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。<br>n&lt;=39<br>斐波那契数列（Fibonacci sequence），又称黄金分割数列、因数学家列昂纳多·斐波那契（Leonardoda Fibonacci）以兔子繁殖为例子而引入，故又称为“兔子数列”，指的是这样一个数列：1、1、2、3、5、8、13、21、34、……在数学上，斐波纳契数列以如下被以递归的方法定义：F(0)=0，F(1)=1, F(n)=F(n-1)+F(n-2)（n&gt;=2，n∈N*）在现代物理、准晶体结构、化学等领域，斐波纳契数列都有直接的应用，为此，美国数学会从1963年起出版了以《斐波纳契数列季刊》为名的一份数学杂志，用于专门刊载这方面的研究成果。</p><p>思路：记录f(n-1)，f(n-2)，即可得出f(n)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> prePre = <span class="number">1</span>; <span class="comment">// n - 2</span></span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">1</span>; <span class="comment">// n - 1</span></span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>; <span class="comment">// n</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            result = prePre + pre;</span><br><span class="line">            prePre = pre;</span><br><span class="line">            pre = result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。&lt;br&gt;n&amp;lt;=39&lt;br&gt;斐波那契数列（Fibonacci sequence），又称黄金分割数列、因数学家列昂纳多·斐波那契（Leonardoda Fibonacci）以兔子繁殖为例子而引入
      
    
    </summary>
    
      <category term="剑指Offer" scheme="https://lierabbit.cn/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>旋转数组的最小数字</title>
    <link href="https://lierabbit.cn/2018/03/02/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/"/>
    <id>https://lierabbit.cn/2018/03/02/旋转数组的最小数字/</id>
    <published>2018-03-02T10:21:30.000Z</published>
    <updated>2018-08-26T07:44:07.076Z</updated>
    
    <content type="html"><![CDATA[<p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p><p>思路：</p><ul><li>使用二分查找，当局部列表有序返回头元素</li><li>当局部列表有序返回头元素</li><li>当局部列表头元素小于中间元素，这里有循环，也就是有最小值，搜索左边</li><li>当局部列表中间元素小于尾元素，这里有循环，也就是有最小值，搜索右边</li><li>当局部列表头元素等于中间元素等于尾元素，遍历寻找最小值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = array.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (left + <span class="number">1</span> == right) <span class="comment">// 只剩2个数时直接比较其大小</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (array[left] &lt; array[right]) <span class="comment">// 当局部列表有序返回头</span></span><br><span class="line">            <span class="keyword">return</span> array[left];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (array[left] &gt; array[mid]) <span class="comment">// 当局部列表头元素大于中间元素，这里有循环，也就是有最小值，搜索左边</span></span><br><span class="line">            right = mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (array[mid] &gt; array[right]) <span class="comment">// 当局部列表中间元素大于尾元素，这里有循环，也就是有最小值，搜索右边</span></span><br><span class="line">            left = mid;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 当局部列表头元素等于中间元素等于尾元素，遍历寻找最小值</span></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                <span class="keyword">if</span> (array[left] == array[mid])</span><br><span class="line">                    left++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (array[left] &lt; array[mid])</span><br><span class="line">                    <span class="keyword">return</span> array[left];</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    right = mid;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Math.min(array[left], array[right]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回
      
    
    </summary>
    
      <category term="剑指Offer" scheme="https://lierabbit.cn/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>用两个栈实现队列</title>
    <link href="https://lierabbit.cn/2018/03/01/%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <id>https://lierabbit.cn/2018/03/01/用两个栈实现队列/</id>
    <published>2018-03-01T15:38:47.000Z</published>
    <updated>2018-08-26T07:41:29.710Z</updated>
    
    <content type="html"><![CDATA[<p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p><p>思路：</p><ul><li>当弹出栈不空时不能压入弹出栈</li><li>必须一次性将压入栈倒出到弹出栈</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 用两个栈实现队列 </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stack2.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack1.isEmpty())</span><br><span class="line">                stack2.add(stack1.pop());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        用两个栈实现队列 twoStackQueue = <span class="keyword">new</span> 用两个栈实现队列();</span><br><span class="line">        twoStackQueue.push(<span class="number">1</span>);</span><br><span class="line">        twoStackQueue.push(<span class="number">2</span>);</span><br><span class="line">        twoStackQueue.push(<span class="number">3</span>);</span><br><span class="line">        System.out.println(twoStackQueue.pop());</span><br><span class="line">        System.out.println(twoStackQueue.pop());</span><br><span class="line">        twoStackQueue.push(<span class="number">4</span>);</span><br><span class="line">        System.out.println(twoStackQueue.pop());</span><br><span class="line">        twoStackQueue.push(<span class="number">5</span>);</span><br><span class="line">        System.out.println(twoStackQueue.pop());</span><br><span class="line">        System.out.println(twoStackQueue.pop());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。&lt;/p&gt;
&lt;p&gt;思路：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当弹出栈不空时不能压入弹出栈&lt;/li&gt;
&lt;li&gt;必须一次性将压入栈倒出到弹出栈&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;high
      
    
    </summary>
    
      <category term="剑指Offer" scheme="https://lierabbit.cn/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>重建二叉树</title>
    <link href="https://lierabbit.cn/2018/03/01/%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://lierabbit.cn/2018/03/01/重建二叉树/</id>
    <published>2018-03-01T14:52:29.000Z</published>
    <updated>2018-08-26T07:37:42.347Z</updated>
    
    <content type="html"><![CDATA[<p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p><p>思路：每次将左右两颗子树当成新的子树进行处理，中序的左右子树索引很好找，前序的开始结束索引通过计算中序中左右子树的大小来计算，然后递归求解，直到<code>startPre&gt;endPre||startIn&gt;endIn</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span>[] pre, <span class="keyword">int</span>[] in)</span> </span>&#123;</span><br><span class="line">    TreeNode root = process(pre, <span class="number">0</span>, pre.length - <span class="number">1</span>, in, <span class="number">0</span>, in.length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">process</span><span class="params">(<span class="keyword">int</span>[] pre, <span class="keyword">int</span> startPre, <span class="keyword">int</span> endPre, <span class="keyword">int</span> in[], <span class="keyword">int</span> startIn, <span class="keyword">int</span> endIn)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (startPre &gt; endPre || startIn &gt; endIn)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 先序的每个节点都是子树的头节点</span></span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(pre[startPre]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = startIn; i &lt;= endIn; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pre[startPre] == in[i]) &#123;</span><br><span class="line">            root.left = process(pre, startPre + <span class="number">1</span>, startPre + i - startIn, in, startIn, i - <span class="number">1</span>);</span><br><span class="line">            root.right = process(pre, startPre + i - startIn + <span class="number">1</span>, endPre, in, i + <span class="number">1</span>, endIn);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。&lt;/p&gt;
&lt;p&gt;思路：每次将左右两颗子
      
    
    </summary>
    
      <category term="剑指Offer" scheme="https://lierabbit.cn/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>从尾到头打印链表</title>
    <link href="https://lierabbit.cn/2018/02/28/%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/"/>
    <id>https://lierabbit.cn/2018/02/28/从尾到头打印链表/</id>
    <published>2018-02-28T15:49:14.000Z</published>
    <updated>2018-08-26T07:24:55.235Z</updated>
    
    <content type="html"><![CDATA[<p>输入一个链表，从尾到头打印链表每个节点的值。</p><h3 id="递归到最后，在一个个的添加进List"><a href="#递归到最后，在一个个的添加进List" class="headerlink" title="递归到最后，在一个个的添加进List"></a>递归到最后，在一个个的添加进List</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    printListFromTailToHead(listNode, res);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printListFromTailToHead</span><span class="params">(ListNode node, List&lt;Integer&gt; res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">        printListFromTailToHead(node.next, res);</span><br><span class="line">        res.add(node.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用栈从头到尾装入所有节点即可，因为栈先进后出的特性，在弹出的时候就是从尾到头"><a href="#使用栈从头到尾装入所有节点即可，因为栈先进后出的特性，在弹出的时候就是从尾到头" class="headerlink" title="使用栈从头到尾装入所有节点即可，因为栈先进后出的特性，在弹出的时候就是从尾到头"></a>使用栈从头到尾装入所有节点即可，因为栈先进后出的特性，在弹出的时候就是从尾到头</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Stack&lt;ListNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    ListNode node = listNode;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">        stack.add(node);</span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!stack.empty()) &#123;</span><br><span class="line">        node = stack.pop();</span><br><span class="line">        res.add(node.val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="反转链表后再打印"><a href="#反转链表后再打印" class="headerlink" title="反转链表后再打印"></a>反转链表后再打印</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead3</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    ListNode node = reverseList(listNode);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">        res.add(node.val);</span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">    ListNode next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        next = head.next;</span><br><span class="line">        head.next = pre;</span><br><span class="line">        pre = head;</span><br><span class="line">        head = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;输入一个链表，从尾到头打印链表每个节点的值。&lt;/p&gt;
&lt;h3 id=&quot;递归到最后，在一个个的添加进List&quot;&gt;&lt;a href=&quot;#递归到最后，在一个个的添加进List&quot; class=&quot;headerlink&quot; title=&quot;递归到最后，在一个个的添加进List&quot;&gt;&lt;/a&gt;递归
      
    
    </summary>
    
      <category term="剑指Offer" scheme="https://lierabbit.cn/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>替换空格</title>
    <link href="https://lierabbit.cn/2018/02/28/%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/"/>
    <id>https://lierabbit.cn/2018/02/28/替换空格/</id>
    <published>2018-02-28T15:46:46.000Z</published>
    <updated>2018-08-26T07:22:25.618Z</updated>
    
    <content type="html"><![CDATA[<p>请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p><p>思路：<br>一、使用replaceAll<br>iniString.replaceAll(“ “,”%20”)<br>二、手动实现<br>思路：记录空格出现次数，新数组长度等于原数组长度+空格数*2，遍历原数组按规则放入新数组即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(StringBuffer str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++)</span><br><span class="line">        <span class="keyword">if</span> (str.charAt(i) == <span class="string">' '</span>)</span><br><span class="line">            count++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> charsLen = str.length() + count * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">char</span>[] chars = <span class="keyword">new</span> <span class="keyword">char</span>[charsLen];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = str.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">char</span> ch = str.charAt(i);</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">' '</span>) &#123;</span><br><span class="line">            chars[--charsLen] = <span class="string">'0'</span>;</span><br><span class="line">            chars[--charsLen] = <span class="string">'2'</span>;</span><br><span class="line">            chars[--charsLen] = <span class="string">'%'</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            chars[--charsLen] = str.charAt(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(chars);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。&lt;/p&gt;
&lt;p&gt;思路：&lt;br&gt;一、使用replaceAll&lt;br&gt;iniString.replaceAll(“ “,”%
      
    
    </summary>
    
      <category term="剑指Offer" scheme="https://lierabbit.cn/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>二维数组中的查找</title>
    <link href="https://lierabbit.cn/2018/02/28/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/"/>
    <id>https://lierabbit.cn/2018/02/28/二维数组中的查找/</id>
    <published>2018-02-28T15:31:31.000Z</published>
    <updated>2018-08-26T07:20:56.572Z</updated>
    
    <content type="html"><![CDATA[<p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p>思路：</p><ul><li>从数组的右上角开始寻找</li><li>当前数大于目前位置时，不用往左找了，因为左边的数都比当前位置的小，往下找</li><li>当前数小于目前位置时，不用往下走了，因为下面的数都比当前位置的大，往左找</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span>[][] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> col = array[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (row &lt; array.length &amp;&amp; col &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[row][col] &gt; target)</span><br><span class="line">            col--;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (array[row][col] &lt; target)</span><br><span class="line">            row++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。&lt;/p&gt;
&lt;p&gt;思路：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从数组的右上角开始寻找&lt;/li&gt;
&lt;li&gt;当前数大于目前位
      
    
    </summary>
    
      <category term="剑指Offer" scheme="https://lierabbit.cn/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>游戏</title>
    <link href="https://lierabbit.cn/2018/02/27/%E6%B8%B8%E6%88%8F/"/>
    <id>https://lierabbit.cn/2018/02/27/游戏/</id>
    <published>2018-02-27T12:19:44.000Z</published>
    <updated>2018-08-25T10:04:10.032Z</updated>
    
    <content type="html"><![CDATA[<p>A与B做游戏。 在一个n*m的矩阵中的出发点是（1，m），终点是（n,1），规则是只能向左移动一格，向下一格或向左下移动一格，先走到终点的为winner。 A先走。<br>给定两个整数n和m，请返回最后的获胜者的名字(A或B)。</p><p>测试样例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5 3</span><br><span class="line">返回：B</span><br></pre></td></tr></table></figure></p><p>思路：最优策略是两个人每次共走2格，如果A向左下2移动一格，相当于移动2格，此时B也应该向左下移动，总共是4格</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">getWinner</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="comment">// 最优策略是两个人每次共走2格，</span></span><br><span class="line">    <span class="comment">// 如果A向左下2移动一格，相当于移动2格，此时B也应该向左下移动，总共是4格</span></span><br><span class="line">    <span class="keyword">if</span> (m % <span class="number">2</span> != <span class="number">0</span> &amp;&amp; n % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'B'</span>;<span class="comment">// // 此时B距离终点只有1格</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'A'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;A与B做游戏。 在一个n*m的矩阵中的出发点是（1，m），终点是（n,1），规则是只能向左移动一格，向下一格或向左下移动一格，先走到终点的为winner。 A先走。&lt;br&gt;给定两个整数n和m，请返回最后的获胜者的名字(A或B)。&lt;/p&gt;
&lt;p&gt;测试样例：&lt;br&gt;&lt;figur
      
    
    </summary>
    
      <category term="直通BAT面试算法" scheme="https://lierabbit.cn/categories/%E7%9B%B4%E9%80%9ABAT%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数组清空</title>
    <link href="https://lierabbit.cn/2018/02/27/%E6%95%B0%E7%BB%84%E6%B8%85%E7%A9%BA/"/>
    <id>https://lierabbit.cn/2018/02/27/数组清空/</id>
    <published>2018-02-27T12:08:20.000Z</published>
    <updated>2018-08-25T10:00:51.924Z</updated>
    
    <content type="html"><![CDATA[<p>现在有一个整数数组，其元素值均为1-n范围内的某个整数，现在你和你的朋友在玩一个游戏，游戏的目的是把数组清空，你们轮流操作，你是先手，每次操作你可以删除数组中值为某个数的元素任意多个(当然数组中值为这个数的元素个数应大于等于你删除的个数,且你至少要删除一个数)。最先把数组清空的人获得胜利。假设你们都采取最优策略，请你计算你能否获得胜利。<br>给定一个整数数组A和元素个数n。请返回一个整数，1代表你能获胜，0代表你不能获胜。</p><p>测试样例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1,1,1]</span><br><span class="line">返回：1</span><br></pre></td></tr></table></figure></p><p>思路：最优策略为和对方删除同样数量的元素，导致最后留下只能两次删除完所有元素，这样在对方再走一步后你就获胜了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWinner</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计所有数字出现次数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : A)</span><br><span class="line">        map.merge(num, <span class="number">1</span>, (a, b) -&gt; a + b);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将所有次数进行异或运算</span></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> count : map.values()) &#123;</span><br><span class="line">        res ^= count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出现次数成对则为0</span></span><br><span class="line">    <span class="keyword">return</span> res != <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;现在有一个整数数组，其元素值均为1-n范围内的某个整数，现在你和你的朋友在玩一个游戏，游戏的目的是把数组清空，你们轮流操作，你是先手，每次操作你可以删除数组中值为某个数的元素任意多个(当然数组中值为这个数的元素个数应大于等于你删除的个数,且你至少要删除一个数)。最先把数组清
      
    
    </summary>
    
      <category term="直通BAT面试算法" scheme="https://lierabbit.cn/categories/%E7%9B%B4%E9%80%9ABAT%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>跳格子</title>
    <link href="https://lierabbit.cn/2018/02/27/%E8%B7%B3%E6%A0%BC%E5%AD%90/"/>
    <id>https://lierabbit.cn/2018/02/27/跳格子/</id>
    <published>2018-02-27T08:54:47.000Z</published>
    <updated>2018-08-25T09:54:01.466Z</updated>
    
    <content type="html"><![CDATA[<p>你和你的朋友正在玩棋子跳格子的游戏，而棋盘是一个由n个格子组成的长条，你们两人轮流移动一颗棋子，每次可以选择让棋子跳1-3格，先将棋子移出棋盘的人获得胜利。我们知道你们两人都会采取最优策略，现在已知格子数目，并且初始时棋子在第一格由你操作。请你计算你是否能获胜。<br>给定格子的数目n(n为不超过300的正整数)。返回一个整数，1代表能获胜，0代表不能获胜。</p><p>测试样例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">返回：1</span><br></pre></td></tr></table></figure></p><p>思路： 通过列举1、2、3、4格的情况发现，只要轮到我的时候还剩4格，我必输无疑，因为无论我选择走多少格对方都可以一次走出棋盘。更巧的是，无论我走多少格，对方都可以选择走一种格数来使这一回合凑齐4格。因此，只要总格数是4的整数倍，我就必输无疑。而在其他任何种格数下，在走第一步的时候我都可以选择走一种格数使得剩下的格数为4的整数倍，这样对方就必输无疑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">checkWin</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">return</span> (n - <span class="number">1</span>) % <span class="number">4</span> == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;你和你的朋友正在玩棋子跳格子的游戏，而棋盘是一个由n个格子组成的长条，你们两人轮流移动一颗棋子，每次可以选择让棋子跳1-3格，先将棋子移出棋盘的人获得胜利。我们知道你们两人都会采取最优策略，现在已知格子数目，并且初始时棋子在第一格由你操作。请你计算你是否能获胜。&lt;br&gt;给定
      
    
    </summary>
    
      <category term="直通BAT面试算法" scheme="https://lierabbit.cn/categories/%E7%9B%B4%E9%80%9ABAT%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>赛马</title>
    <link href="https://lierabbit.cn/2018/02/27/%E8%B5%9B%E9%A9%AC/"/>
    <id>https://lierabbit.cn/2018/02/27/赛马/</id>
    <published>2018-02-27T08:43:49.000Z</published>
    <updated>2018-08-25T09:50:20.935Z</updated>
    
    <content type="html"><![CDATA[<p>作为一个马场的主人，你要安排你的n匹赛马和另一个马场的n匹马比赛。你已经知道了对方马场的出战表，即参加每一场的马的强壮程度。当然你也知道你自己的所有马的强壮程度。我们假定比赛的结果直接由马的强壮程度决定，即更壮的马获胜(若相同则双方均不算获胜)，请你设计一个策略，使你能获得尽量多的场次的胜利。<br>给定对方每场比赛的马的强壮程度oppo及你的所有马的强壮程度horses(强壮程度为整数，且数字越大越强壮)同时给定n，请返回最多能获胜的场次。</p><p>测试样例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1,2,3],[1,2,3],3</span><br><span class="line">返回：2</span><br></pre></td></tr></table></figure></p><p>思路：和田忌赛马类似，用最强的马与能赢别人的最强的马比</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">winMost</span><span class="params">(<span class="keyword">int</span>[] oppo, <span class="keyword">int</span>[] horses, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    Arrays.sort(oppo);</span><br><span class="line">    Arrays.sort(horses);</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        <span class="keyword">if</span> (horses[n - res - <span class="number">1</span>] &gt; oppo[i])</span><br><span class="line">            res++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;作为一个马场的主人，你要安排你的n匹赛马和另一个马场的n匹马比赛。你已经知道了对方马场的出战表，即参加每一场的马的强壮程度。当然你也知道你自己的所有马的强壮程度。我们假定比赛的结果直接由马的强壮程度决定，即更壮的马获胜(若相同则双方均不算获胜)，请你设计一个策略，使你能获得
      
    
    </summary>
    
      <category term="直通BAT面试算法" scheme="https://lierabbit.cn/categories/%E7%9B%B4%E9%80%9ABAT%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>涂色</title>
    <link href="https://lierabbit.cn/2018/02/27/%E6%B6%82%E8%89%B2/"/>
    <id>https://lierabbit.cn/2018/02/27/涂色/</id>
    <published>2018-02-27T08:26:06.000Z</published>
    <updated>2018-08-25T09:45:21.943Z</updated>
    
    <content type="html"><![CDATA[<p>你要在一个nxm的格子图上涂色，你每次可以选择一个未涂色的格子涂上你开始选定的那种颜色。同时为了美观，我们要求你涂色的格子不能相邻，也就是说，不能有公共边，现在问你，在采取最优策略的情况下，你最多能涂多少个格子？<br>给定格子图的长n和宽m。请返回最多能涂的格子数目。</p><p>测试样例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1,2</span><br><span class="line">返回：1</span><br></pre></td></tr></table></figure></p><p>思路：<br>只有一种颜色，要想不相邻，每行一个隔一个涂色即可，如果行数或者列数为偶数，最多的格子即为(m / 2) <em> n或者(n / 2) </em> m，显然就是m <em> n / 2<br>如果行列均不为偶数，假设多加一列，则最大格子就为((n + 1) / 2) </em> m,然后需要减去多加的格子数为(m - 1) / 2,两式合并即为(n <em> m + 1) / 2<br>又由int除法特性，可以将两式合并为(n </em> m + 1) / 2,即为所求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMost</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">return</span> (n * m + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;你要在一个nxm的格子图上涂色，你每次可以选择一个未涂色的格子涂上你开始选定的那种颜色。同时为了美观，我们要求你涂色的格子不能相邻，也就是说，不能有公共边，现在问你，在采取最优策略的情况下，你最多能涂多少个格子？&lt;br&gt;给定格子图的长n和宽m。请返回最多能涂的格子数目。&lt;/
      
    
    </summary>
    
      <category term="直通BAT面试算法" scheme="https://lierabbit.cn/categories/%E7%9B%B4%E9%80%9ABAT%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>最优编辑</title>
    <link href="https://lierabbit.cn/2018/02/27/%E6%9C%80%E4%BC%98%E7%BC%96%E8%BE%91/"/>
    <id>https://lierabbit.cn/2018/02/27/最优编辑/</id>
    <published>2018-02-27T08:03:25.000Z</published>
    <updated>2018-08-25T09:29:01.079Z</updated>
    
    <content type="html"><![CDATA[<p>对于两个字符串A和B，我们需要进行插入、删除和修改操作将A串变为B串，定义c0，c1，c2分别为三种操作的代价，请设计一个高效算法，求出将A串变为B串所需要的最少代价。<br>给定两个字符串A和B，及它们的长度和三种操作代价，请返回将A串变为B串所需要的最小代价。保证两串长度均小于等于300，且三种代价值均小于等于100。</p><p>测试样例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;abc&quot;,3,&quot;adc&quot;,3,5,3,100</span><br><span class="line">返回：8</span><br></pre></td></tr></table></figure></p><p>思路：<br><img src="https://blog-1252204470.cos.ap-guangzhou.myqcloud.com/2018/02/27/%E6%9C%80%E4%BC%98%E7%BC%96%E8%BE%91/1.jpg" alt=""><br>下面具体说明dp矩阵每个位置的值是如何计算的:</p><ol><li>dp[0][0]设置为0，表示str1空的子串编辑成str2空的子串，故代价为0。</li><li>矩阵dp第一列即dp[0..M][0],dp[i][0]表示str1[0.i-1]编辑成空串的最小代价，即把str1[0..i-1]所有字符都删掉的代价，故dp[i][0]=dc*i。</li><li>矩阵dp第一行即dp[0][0..N]。dp[0][j]表示空串编辑成str2[0.j-1]的最小代价，即在空串里插入str2[0..j-1]的所有字符的代价，故dp[0][j]=ic*j。</li><li>其他位置按照先从左到右，再从上到下来计算，dp[i][j]的值只可能来自以下四种情况:<br>(1) str1[0..i-1]可以先编辑成str1[0..i-2] 也就是删除字符str1[i-1],然后由str1[0..i-2]编辑成str2[0..j-1] dp[i-1][j]就表示str1[0..i-2]编辑成str2[0..j-1]的最小代价，那么dp[i][j]可能等于dc+dp[i-1][j].<br>(2) str1[0..i-1]可以先编辑成str2[0.j-2],然后将str2[0..j-2]插入字符str2[j-1],编辑成str2[0..j-1] dp[i][j-1]表示str1[0..i-1]编辑成str2[0..j-2]的最小代价，那么dp[i][j]可能等于dp[ij][j-1]+ic.<br>(3) 如果str1[i-1]!=str2[j-1].先把str1[0..i-1]中str1[0..i-2]的部分变成str2[0..j-2],然后把字符str1[i-1]替换成str2[j-1],这样str1[0..i-1]就编辑成str2[0..j-1]了.dp[i-1][j-1]就表示str1[0.i-2]编辑成str2[0.i-2]的最小代价，那么dp[i][j]可能等于dp[i-1][j-1] +rC。<br>(4) 如果str1[i-1]==str2[j-1],先把str1[0..i-1]中str1[0..i-2]的部分变成str2[0.j-2],因为此时字符str1[i-1]等于str2[j-1],所以str1[0..i-1]已经编辑成str2[0.j-1]了。dp[i-1][j-1]就表示str1[0.i-2]编辑成str2[0.i-2]的最小代价，那么dp[i]j]可能等于dp[i-1j[j-1].<br>以上四种可能的值中，选最小值作为dp[i][j]的值。</li><li>最终结果返回dp最右下角的值</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMinCost</span><span class="params">(String str1, <span class="keyword">int</span> n, String str2, <span class="keyword">int</span> m, <span class="keyword">int</span> ic, <span class="keyword">int</span> dc, <span class="keyword">int</span> rc)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> col = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化列</span></span><br><span class="line">    <span class="keyword">while</span> (row &lt;= n) &#123;</span><br><span class="line">        dp[row][<span class="number">0</span>] = row * dc;</span><br><span class="line">        row++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化行</span></span><br><span class="line">    <span class="keyword">while</span> (col &lt;= m) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][col] = col * ic;</span><br><span class="line">        col++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (row = <span class="number">1</span>; row &lt;= n; row++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (col = <span class="number">1</span>; col &lt;= m; col++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str1.charAt(row - <span class="number">1</span>) == str2.charAt(col - <span class="number">1</span>))</span><br><span class="line">                dp[row][col] = Math.min(dp[row - <span class="number">1</span>][col] + dc, Math.min(dp[row][col - <span class="number">1</span>] + ic, dp[row - <span class="number">1</span>][col - <span class="number">1</span>]));</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[row][col] = Math.min(dp[row - <span class="number">1</span>][col] + dc, Math.min(dp[row][col - <span class="number">1</span>] + ic, dp[row - <span class="number">1</span>][col - <span class="number">1</span>] + rc));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[n][m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对于两个字符串A和B，我们需要进行插入、删除和修改操作将A串变为B串，定义c0，c1，c2分别为三种操作的代价，请设计一个高效算法，求出将A串变为B串所需要的最少代价。&lt;br&gt;给定两个字符串A和B，及它们的长度和三种操作代价，请返回将A串变为B串所需要的最小代价。保证两串长
      
    
    </summary>
    
      <category term="直通BAT面试算法" scheme="https://lierabbit.cn/categories/%E7%9B%B4%E9%80%9ABAT%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
