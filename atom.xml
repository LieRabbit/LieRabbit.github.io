<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>谎话兔博客</title>
  
  <subtitle>LieRabbit</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://lierabbit.cn/"/>
  <updated>2018-08-25T10:04:10.032Z</updated>
  <id>https://lierabbit.cn/</id>
  
  <author>
    <name>谎话兔</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>游戏</title>
    <link href="https://lierabbit.cn/2018/02/27/%E6%B8%B8%E6%88%8F/"/>
    <id>https://lierabbit.cn/2018/02/27/游戏/</id>
    <published>2018-02-27T12:19:44.000Z</published>
    <updated>2018-08-25T10:04:10.032Z</updated>
    
    <content type="html"><![CDATA[<p>A与B做游戏。 在一个n*m的矩阵中的出发点是（1，m），终点是（n,1），规则是只能向左移动一格，向下一格或向左下移动一格，先走到终点的为winner。 A先走。<br>给定两个整数n和m，请返回最后的获胜者的名字(A或B)。</p><p>测试样例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5 3</span><br><span class="line">返回：B</span><br></pre></td></tr></table></figure></p><p>思路：最优策略是两个人每次共走2格，如果A向左下2移动一格，相当于移动2格，此时B也应该向左下移动，总共是4格</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">getWinner</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="comment">// 最优策略是两个人每次共走2格，</span></span><br><span class="line">    <span class="comment">// 如果A向左下2移动一格，相当于移动2格，此时B也应该向左下移动，总共是4格</span></span><br><span class="line">    <span class="keyword">if</span> (m % <span class="number">2</span> != <span class="number">0</span> &amp;&amp; n % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'B'</span>;<span class="comment">// // 此时B距离终点只有1格</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'A'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;A与B做游戏。 在一个n*m的矩阵中的出发点是（1，m），终点是（n,1），规则是只能向左移动一格，向下一格或向左下移动一格，先走到终点的为winner。 A先走。&lt;br&gt;给定两个整数n和m，请返回最后的获胜者的名字(A或B)。&lt;/p&gt;
&lt;p&gt;测试样例：&lt;br&gt;&lt;figur
      
    
    </summary>
    
      <category term="直通BAT面试算法" scheme="https://lierabbit.cn/categories/%E7%9B%B4%E9%80%9ABAT%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数组清空</title>
    <link href="https://lierabbit.cn/2018/02/27/%E6%95%B0%E7%BB%84%E6%B8%85%E7%A9%BA/"/>
    <id>https://lierabbit.cn/2018/02/27/数组清空/</id>
    <published>2018-02-27T12:08:20.000Z</published>
    <updated>2018-08-25T10:00:51.924Z</updated>
    
    <content type="html"><![CDATA[<p>现在有一个整数数组，其元素值均为1-n范围内的某个整数，现在你和你的朋友在玩一个游戏，游戏的目的是把数组清空，你们轮流操作，你是先手，每次操作你可以删除数组中值为某个数的元素任意多个(当然数组中值为这个数的元素个数应大于等于你删除的个数,且你至少要删除一个数)。最先把数组清空的人获得胜利。假设你们都采取最优策略，请你计算你能否获得胜利。<br>给定一个整数数组A和元素个数n。请返回一个整数，1代表你能获胜，0代表你不能获胜。</p><p>测试样例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1,1,1]</span><br><span class="line">返回：1</span><br></pre></td></tr></table></figure></p><p>思路：最优策略为和对方删除同样数量的元素，导致最后留下只能两次删除完所有元素，这样在对方再走一步后你就获胜了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWinner</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计所有数字出现次数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : A)</span><br><span class="line">        map.merge(num, <span class="number">1</span>, (a, b) -&gt; a + b);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将所有次数进行异或运算</span></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> count : map.values()) &#123;</span><br><span class="line">        res ^= count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出现次数成对则为0</span></span><br><span class="line">    <span class="keyword">return</span> res != <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;现在有一个整数数组，其元素值均为1-n范围内的某个整数，现在你和你的朋友在玩一个游戏，游戏的目的是把数组清空，你们轮流操作，你是先手，每次操作你可以删除数组中值为某个数的元素任意多个(当然数组中值为这个数的元素个数应大于等于你删除的个数,且你至少要删除一个数)。最先把数组清
      
    
    </summary>
    
      <category term="直通BAT面试算法" scheme="https://lierabbit.cn/categories/%E7%9B%B4%E9%80%9ABAT%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>跳格子</title>
    <link href="https://lierabbit.cn/2018/02/27/%E8%B7%B3%E6%A0%BC%E5%AD%90/"/>
    <id>https://lierabbit.cn/2018/02/27/跳格子/</id>
    <published>2018-02-27T08:54:47.000Z</published>
    <updated>2018-08-25T09:54:01.466Z</updated>
    
    <content type="html"><![CDATA[<p>你和你的朋友正在玩棋子跳格子的游戏，而棋盘是一个由n个格子组成的长条，你们两人轮流移动一颗棋子，每次可以选择让棋子跳1-3格，先将棋子移出棋盘的人获得胜利。我们知道你们两人都会采取最优策略，现在已知格子数目，并且初始时棋子在第一格由你操作。请你计算你是否能获胜。<br>给定格子的数目n(n为不超过300的正整数)。返回一个整数，1代表能获胜，0代表不能获胜。</p><p>测试样例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">返回：1</span><br></pre></td></tr></table></figure></p><p>思路： 通过列举1、2、3、4格的情况发现，只要轮到我的时候还剩4格，我必输无疑，因为无论我选择走多少格对方都可以一次走出棋盘。更巧的是，无论我走多少格，对方都可以选择走一种格数来使这一回合凑齐4格。因此，只要总格数是4的整数倍，我就必输无疑。而在其他任何种格数下，在走第一步的时候我都可以选择走一种格数使得剩下的格数为4的整数倍，这样对方就必输无疑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">checkWin</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">return</span> (n - <span class="number">1</span>) % <span class="number">4</span> == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;你和你的朋友正在玩棋子跳格子的游戏，而棋盘是一个由n个格子组成的长条，你们两人轮流移动一颗棋子，每次可以选择让棋子跳1-3格，先将棋子移出棋盘的人获得胜利。我们知道你们两人都会采取最优策略，现在已知格子数目，并且初始时棋子在第一格由你操作。请你计算你是否能获胜。&lt;br&gt;给定
      
    
    </summary>
    
      <category term="直通BAT面试算法" scheme="https://lierabbit.cn/categories/%E7%9B%B4%E9%80%9ABAT%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>赛马</title>
    <link href="https://lierabbit.cn/2018/02/27/%E8%B5%9B%E9%A9%AC/"/>
    <id>https://lierabbit.cn/2018/02/27/赛马/</id>
    <published>2018-02-27T08:43:49.000Z</published>
    <updated>2018-08-25T09:50:20.935Z</updated>
    
    <content type="html"><![CDATA[<p>作为一个马场的主人，你要安排你的n匹赛马和另一个马场的n匹马比赛。你已经知道了对方马场的出战表，即参加每一场的马的强壮程度。当然你也知道你自己的所有马的强壮程度。我们假定比赛的结果直接由马的强壮程度决定，即更壮的马获胜(若相同则双方均不算获胜)，请你设计一个策略，使你能获得尽量多的场次的胜利。<br>给定对方每场比赛的马的强壮程度oppo及你的所有马的强壮程度horses(强壮程度为整数，且数字越大越强壮)同时给定n，请返回最多能获胜的场次。</p><p>测试样例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1,2,3],[1,2,3],3</span><br><span class="line">返回：2</span><br></pre></td></tr></table></figure></p><p>思路：和田忌赛马类似，用最强的马与能赢别人的最强的马比</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">winMost</span><span class="params">(<span class="keyword">int</span>[] oppo, <span class="keyword">int</span>[] horses, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    Arrays.sort(oppo);</span><br><span class="line">    Arrays.sort(horses);</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        <span class="keyword">if</span> (horses[n - res - <span class="number">1</span>] &gt; oppo[i])</span><br><span class="line">            res++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;作为一个马场的主人，你要安排你的n匹赛马和另一个马场的n匹马比赛。你已经知道了对方马场的出战表，即参加每一场的马的强壮程度。当然你也知道你自己的所有马的强壮程度。我们假定比赛的结果直接由马的强壮程度决定，即更壮的马获胜(若相同则双方均不算获胜)，请你设计一个策略，使你能获得
      
    
    </summary>
    
      <category term="直通BAT面试算法" scheme="https://lierabbit.cn/categories/%E7%9B%B4%E9%80%9ABAT%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>涂色</title>
    <link href="https://lierabbit.cn/2018/02/27/%E6%B6%82%E8%89%B2/"/>
    <id>https://lierabbit.cn/2018/02/27/涂色/</id>
    <published>2018-02-27T08:26:06.000Z</published>
    <updated>2018-08-25T09:45:21.943Z</updated>
    
    <content type="html"><![CDATA[<p>你要在一个nxm的格子图上涂色，你每次可以选择一个未涂色的格子涂上你开始选定的那种颜色。同时为了美观，我们要求你涂色的格子不能相邻，也就是说，不能有公共边，现在问你，在采取最优策略的情况下，你最多能涂多少个格子？<br>给定格子图的长n和宽m。请返回最多能涂的格子数目。</p><p>测试样例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1,2</span><br><span class="line">返回：1</span><br></pre></td></tr></table></figure></p><p>思路：<br>只有一种颜色，要想不相邻，每行一个隔一个涂色即可，如果行数或者列数为偶数，最多的格子即为(m / 2) <em> n或者(n / 2) </em> m，显然就是m <em> n / 2<br>如果行列均不为偶数，假设多加一列，则最大格子就为((n + 1) / 2) </em> m,然后需要减去多加的格子数为(m - 1) / 2,两式合并即为(n <em> m + 1) / 2<br>又由int除法特性，可以将两式合并为(n </em> m + 1) / 2,即为所求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMost</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">return</span> (n * m + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;你要在一个nxm的格子图上涂色，你每次可以选择一个未涂色的格子涂上你开始选定的那种颜色。同时为了美观，我们要求你涂色的格子不能相邻，也就是说，不能有公共边，现在问你，在采取最优策略的情况下，你最多能涂多少个格子？&lt;br&gt;给定格子图的长n和宽m。请返回最多能涂的格子数目。&lt;/
      
    
    </summary>
    
      <category term="直通BAT面试算法" scheme="https://lierabbit.cn/categories/%E7%9B%B4%E9%80%9ABAT%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>最优编辑</title>
    <link href="https://lierabbit.cn/2018/02/27/%E6%9C%80%E4%BC%98%E7%BC%96%E8%BE%91/"/>
    <id>https://lierabbit.cn/2018/02/27/最优编辑/</id>
    <published>2018-02-27T08:03:25.000Z</published>
    <updated>2018-08-25T09:29:01.079Z</updated>
    
    <content type="html"><![CDATA[<p>对于两个字符串A和B，我们需要进行插入、删除和修改操作将A串变为B串，定义c0，c1，c2分别为三种操作的代价，请设计一个高效算法，求出将A串变为B串所需要的最少代价。<br>给定两个字符串A和B，及它们的长度和三种操作代价，请返回将A串变为B串所需要的最小代价。保证两串长度均小于等于300，且三种代价值均小于等于100。</p><p>测试样例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;abc&quot;,3,&quot;adc&quot;,3,5,3,100</span><br><span class="line">返回：8</span><br></pre></td></tr></table></figure></p><p>思路：<br><img src="https://blog-1252204470.cos.ap-guangzhou.myqcloud.com/2018/02/27/%E6%9C%80%E4%BC%98%E7%BC%96%E8%BE%91/1.jpg" alt=""><br>下面具体说明dp矩阵每个位置的值是如何计算的:</p><ol><li>dp[0][0]设置为0，表示str1空的子串编辑成str2空的子串，故代价为0。</li><li>矩阵dp第一列即dp[0..M][0],dp[i][0]表示str1[0.i-1]编辑成空串的最小代价，即把str1[0..i-1]所有字符都删掉的代价，故dp[i][0]=dc*i。</li><li>矩阵dp第一行即dp[0][0..N]。dp[0][j]表示空串编辑成str2[0.j-1]的最小代价，即在空串里插入str2[0..j-1]的所有字符的代价，故dp[0][j]=ic*j。</li><li>其他位置按照先从左到右，再从上到下来计算，dp[i][j]的值只可能来自以下四种情况:<br>(1) str1[0..i-1]可以先编辑成str1[0..i-2] 也就是删除字符str1[i-1],然后由str1[0..i-2]编辑成str2[0..j-1] dp[i-1][j]就表示str1[0..i-2]编辑成str2[0..j-1]的最小代价，那么dp[i][j]可能等于dc+dp[i-1][j].<br>(2) str1[0..i-1]可以先编辑成str2[0.j-2],然后将str2[0..j-2]插入字符str2[j-1],编辑成str2[0..j-1] dp[i][j-1]表示str1[0..i-1]编辑成str2[0..j-2]的最小代价，那么dp[i][j]可能等于dp[ij][j-1]+ic.<br>(3) 如果str1[i-1]!=str2[j-1].先把str1[0..i-1]中str1[0..i-2]的部分变成str2[0..j-2],然后把字符str1[i-1]替换成str2[j-1],这样str1[0..i-1]就编辑成str2[0..j-1]了.dp[i-1][j-1]就表示str1[0.i-2]编辑成str2[0.i-2]的最小代价，那么dp[i][j]可能等于dp[i-1][j-1] +rC。<br>(4) 如果str1[i-1]==str2[j-1],先把str1[0..i-1]中str1[0..i-2]的部分变成str2[0.j-2],因为此时字符str1[i-1]等于str2[j-1],所以str1[0..i-1]已经编辑成str2[0.j-1]了。dp[i-1][j-1]就表示str1[0.i-2]编辑成str2[0.i-2]的最小代价，那么dp[i]j]可能等于dp[i-1j[j-1].<br>以上四种可能的值中，选最小值作为dp[i][j]的值。</li><li>最终结果返回dp最右下角的值</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMinCost</span><span class="params">(String str1, <span class="keyword">int</span> n, String str2, <span class="keyword">int</span> m, <span class="keyword">int</span> ic, <span class="keyword">int</span> dc, <span class="keyword">int</span> rc)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> col = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化列</span></span><br><span class="line">    <span class="keyword">while</span> (row &lt;= n) &#123;</span><br><span class="line">        dp[row][<span class="number">0</span>] = row * dc;</span><br><span class="line">        row++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化行</span></span><br><span class="line">    <span class="keyword">while</span> (col &lt;= m) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][col] = col * ic;</span><br><span class="line">        col++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (row = <span class="number">1</span>; row &lt;= n; row++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (col = <span class="number">1</span>; col &lt;= m; col++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str1.charAt(row - <span class="number">1</span>) == str2.charAt(col - <span class="number">1</span>))</span><br><span class="line">                dp[row][col] = Math.min(dp[row - <span class="number">1</span>][col] + dc, Math.min(dp[row][col - <span class="number">1</span>] + ic, dp[row - <span class="number">1</span>][col - <span class="number">1</span>]));</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[row][col] = Math.min(dp[row - <span class="number">1</span>][col] + dc, Math.min(dp[row][col - <span class="number">1</span>] + ic, dp[row - <span class="number">1</span>][col - <span class="number">1</span>] + rc));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[n][m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对于两个字符串A和B，我们需要进行插入、删除和修改操作将A串变为B串，定义c0，c1，c2分别为三种操作的代价，请设计一个高效算法，求出将A串变为B串所需要的最少代价。&lt;br&gt;给定两个字符串A和B，及它们的长度和三种操作代价，请返回将A串变为B串所需要的最小代价。保证两串长
      
    
    </summary>
    
      <category term="直通BAT面试算法" scheme="https://lierabbit.cn/categories/%E7%9B%B4%E9%80%9ABAT%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>01背包</title>
    <link href="https://lierabbit.cn/2018/02/27/01%E8%83%8C%E5%8C%85/"/>
    <id>https://lierabbit.cn/2018/02/27/01背包/</id>
    <published>2018-02-27T05:56:21.000Z</published>
    <updated>2018-08-25T09:24:56.788Z</updated>
    
    <content type="html"><![CDATA[<p>一个背包有一定的承重cap，有N件物品，每件都有自己的价值，记录在数组v中，也都有自己的重量，记录在数组w中，每件物品只能选择要装入背包还是不装入背包，要求在不超过背包承重的前提下，选出物品的总价值最大。<br>给定物品的重量w价值v及物品数n和承重cap。请返回最大总价值。</p><p>测试样例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1,2,3],[1,2,3],3,6</span><br><span class="line">返回：6</span><br></pre></td></tr></table></figure></p><p>思路：物品编号从1到n，一件一件物品考虑是否加入背包。<br>假设dp[x] [y]表示前x件物品，不超过重量y的时候的最大价值。枚举一下第x件物品的情况:<br>情况一:如果选择第x件物品，则前X-1件物品得到的重量不能超过y-w[x]。<br>情况二:如果不选第x件物品，则前X-1件物品得到的重量不能超过y。<br>所以，dp[x] [y]可能等于dp[x-1][y],也就是不取第x件物品的时，价值和之前一样。<br>也可能是dp[x-1][y-w[x]] +v[x]，也就是决定拿第x件物品的情况，当然会获得x物品的价值。<br>两种可能性中，应该选择价值最大的那个。dp[x][y]=max{dp[x-1][y],dp[x-1][y-w[x]]+v[x]}。<br>对于dp矩阵来说，行数是物品的数量n，行数是背包的重量W。从左到右，再从上到下依次计算所有的dp值即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(<span class="keyword">int</span>[] w, <span class="keyword">int</span>[] v, <span class="keyword">int</span> n, <span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][cap + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> row;</span><br><span class="line">    <span class="keyword">int</span> col = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化列</span></span><br><span class="line">    <span class="keyword">while</span> (col &lt;= cap) &#123;</span><br><span class="line">        <span class="keyword">if</span> (col &gt;= w[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        col++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (col &lt;= cap)</span><br><span class="line">        dp[<span class="number">0</span>][col++] = v[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (row = <span class="number">1</span>; row &lt; n; row++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (col = <span class="number">1</span>; col &lt;= cap; col++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (col - w[row] &lt; <span class="number">0</span>)</span><br><span class="line">                dp[row][col] = dp[row - <span class="number">1</span>][col];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[row][col] = Math.max(dp[row - <span class="number">1</span>][col - w[row]] + v[row], dp[row - <span class="number">1</span>][col]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[n - <span class="number">1</span>][cap];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一个背包有一定的承重cap，有N件物品，每件都有自己的价值，记录在数组v中，也都有自己的重量，记录在数组w中，每件物品只能选择要装入背包还是不装入背包，要求在不超过背包承重的前提下，选出物品的总价值最大。&lt;br&gt;给定物品的重量w价值v及物品数n和承重cap。请返回最大总价值
      
    
    </summary>
    
      <category term="直通BAT面试算法" scheme="https://lierabbit.cn/categories/%E7%9B%B4%E9%80%9ABAT%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LCS（最长公共子序列）</title>
    <link href="https://lierabbit.cn/2018/02/27/LCS%EF%BC%88%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%EF%BC%89/"/>
    <id>https://lierabbit.cn/2018/02/27/LCS（最长公共子序列）/</id>
    <published>2018-02-27T05:14:01.000Z</published>
    <updated>2018-08-25T09:20:13.004Z</updated>
    
    <content type="html"><![CDATA[<p>给定两个字符串A和B，返回两个字符串的最长公共子序列的长度。例如，A=”1A2C3D4B56”，B=”B1D23CA45B6A”，”123456”或者”12C4B6”都是最长公共子序列。<br>给定两个字符串A和B，同时给定两个串的长度n和m，请返回最长公共子序列的长度。保证两串长度均小于等于300。</p><p>测试样例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;1A2C3D4B56&quot;,10,&quot;B1D23CA45B6A&quot;,12</span><br><span class="line">返回：6</span><br></pre></td></tr></table></figure></p><p>思路：</p><ol><li>矩阵dp第一列，即dp[i][0],代表str1[0..i]与str2[0]的最长公共子序列长度。str2[0]只有一个字符，所以dp[i][0]最大为1。如果str1[i]==str2[0],则令dp[i][0]为1，一旦dp[i][0]被设为1，则令dp[i+1..M][0]全部为1</li><li>矩阵dp第一行，即dp[0][j]，与步骤1同理。如果str1[0]==str2[j],则令dp[0][j]为1，一旦dp[0][j]被设为1，则令dp[0][j+1..N]全部为1</li><li>其他位置，dp[i][j]的值只可能来自以下三种情况:<br>情况一:可能是dp[i-1][j]的值。这代表str1[0..i-1]与str2[0..j]的最长公共子序列长度。<br>举例:str1=”A1BC2”，str2=”AB34C”。str1[0..3]为” A1BC”,str2[0..4]为” AB34C”，这两部分最长公共子序列为”ABC”即dp[3][4]为3。str1整体和str2整体最长公共子序列也是”ABC”，所以dp[4][4]可能来自dp[3][4].<br>情况二:同理可知，dp[i][j]的值也可能是dp[i][j-1].<br>情况三:如果str1[i]==str2[j],还可能是dp[i-1][j-1]+1的值。<br>举例:比如str1=”ABCD”,str2=”ABCD”.str1[0..2]即”ABC”与str2[0..2]即”ABC”的最长公共子序列为”ABC”，也就是dp[2][2]为3。因为str1和str2的最后一个字符都是” D”，所以dp[i][j]=dp[i-1][j-1]+1.<br>三种可能的值中，选最大值作为dp[i][j]的值。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLCS</span><span class="params">(String A, <span class="keyword">int</span> n, String B, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">if</span> (A == <span class="keyword">null</span> || A.length() == <span class="number">0</span> || B == <span class="keyword">null</span> || B.length() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][m];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化列</span></span><br><span class="line">    <span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (row &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (B.charAt(<span class="number">0</span>) == A.charAt(row)) &#123;</span><br><span class="line">            dp[row][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            row++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            dp[row][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        row++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (row &lt; n)</span><br><span class="line">        dp[row++][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化行</span></span><br><span class="line">    <span class="keyword">int</span> col = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (col &lt; m) &#123;</span><br><span class="line">        <span class="keyword">if</span> (A.charAt(<span class="number">0</span>) == B.charAt(col)) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][col] = <span class="number">1</span>;</span><br><span class="line">            col++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            dp[<span class="number">0</span>][col] = <span class="number">0</span>;</span><br><span class="line">        col++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (col &lt; m)</span><br><span class="line">        dp[<span class="number">0</span>][col++] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (row = <span class="number">1</span>; row &lt; n; row++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (col = <span class="number">1</span>; col &lt; m; col++) &#123;</span><br><span class="line">            <span class="keyword">int</span> max = Math.max(dp[row - <span class="number">1</span>][col], dp[row][col - <span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span> (A.charAt(row) == B.charAt(col))</span><br><span class="line">                max = Math.max(max, dp[row - <span class="number">1</span>][col - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">            dp[row][col] = max;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[row - <span class="number">1</span>][col - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定两个字符串A和B，返回两个字符串的最长公共子序列的长度。例如，A=”1A2C3D4B56”，B=”B1D23CA45B6A”，”123456”或者”12C4B6”都是最长公共子序列。&lt;br&gt;给定两个字符串A和B，同时给定两个串的长度n和m，请返回最长公共子序列的长度。保
      
    
    </summary>
    
      <category term="直通BAT面试算法" scheme="https://lierabbit.cn/categories/%E7%9B%B4%E9%80%9ABAT%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LIS（最长上升子序列）</title>
    <link href="https://lierabbit.cn/2018/02/27/LIS%EF%BC%88%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%EF%BC%89/"/>
    <id>https://lierabbit.cn/2018/02/27/LIS（最长上升子序列）/</id>
    <published>2018-02-27T05:06:20.000Z</published>
    <updated>2018-08-25T09:12:31.522Z</updated>
    
    <content type="html"><![CDATA[<p>这是一个经典的LIS(即最长上升子序列)问题，请设计一个尽量优的解法求出序列的最长上升子序列的长度。<br>给定一个序列A及它的长度n(长度小于等于500)，请返回LIS的长度。</p><p>测试样例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1,4,2,5,3],5</span><br><span class="line">返回：3</span><br></pre></td></tr></table></figure></p><p>思路：记录以每一个数结尾的最大上升子序列长度，取最大的即为结果<br>maxs[i]表示以maxs[i]结尾的最大上升子序列长度，maxs[i] = 前面所有比它小的数的最大上升子序列长度中最大的+1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLIS</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] maxs = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    maxs[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> maxLen = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; i; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; arr[k])</span><br><span class="line">                max = Math.max(max, maxs[k] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        maxs[i] = max;</span><br><span class="line">        maxLen = Math.max(maxLen, max);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这是一个经典的LIS(即最长上升子序列)问题，请设计一个尽量优的解法求出序列的最长上升子序列的长度。&lt;br&gt;给定一个序列A及它的长度n(长度小于等于500)，请返回LIS的长度。&lt;/p&gt;
&lt;p&gt;测试样例：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;
      
    
    </summary>
    
      <category term="直通BAT面试算法" scheme="https://lierabbit.cn/categories/%E7%9B%B4%E9%80%9ABAT%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>矩阵最小路径和</title>
    <link href="https://lierabbit.cn/2018/02/26/%E7%9F%A9%E9%98%B5%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/"/>
    <id>https://lierabbit.cn/2018/02/26/矩阵最小路径和/</id>
    <published>2018-02-26T15:34:42.000Z</published>
    <updated>2018-08-25T09:08:32.395Z</updated>
    
    <content type="html"><![CDATA[<p>有一个矩阵map，它每个格子有一个权值。从左上角的格子开始每次只能向右或者向下走，最后到达右下角的位置，路径上所有的数字累加起来就是路径和，返回所有的路径中最小的路径和。<br>给定一个矩阵map及它的行数n和列数m，请返回最小路径和。保证行列数均小于等于100.</p><p>测试样例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[1,2,3],[1,1,1]],2,3</span><br><span class="line">返回：4</span><br></pre></td></tr></table></figure></p><p>思路：<br><img src="https://blog-1252204470.cos.ap-guangzhou.myqcloud.com/2018/02/26/%E7%9F%A9%E9%98%B5%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/1.jpg" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">(<span class="keyword">int</span>[][] map, <span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][m];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; n; row++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (row == <span class="number">0</span>)</span><br><span class="line">            dp[row][<span class="number">0</span>] = map[row][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            dp[row][<span class="number">0</span>] = dp[row - <span class="number">1</span>][<span class="number">0</span>] + map[row][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">1</span>; col &lt; m; col++)</span><br><span class="line">        dp[<span class="number">0</span>][col] = dp[<span class="number">0</span>][col - <span class="number">1</span>] + map[<span class="number">0</span>][col];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">1</span>; row &lt; n; row++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">1</span>; col &lt; m; col++) &#123;</span><br><span class="line">            dp[row][col] = map[row][col] + Math.min(dp[row - <span class="number">1</span>][col], dp[row][col - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[n - <span class="number">1</span>][m - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有一个矩阵map，它每个格子有一个权值。从左上角的格子开始每次只能向右或者向下走，最后到达右下角的位置，路径上所有的数字累加起来就是路径和，返回所有的路径中最小的路径和。&lt;br&gt;给定一个矩阵map及它的行数n和列数m，请返回最小路径和。保证行列数均小于等于100.&lt;/p&gt;

      
    
    </summary>
    
      <category term="直通BAT面试算法" scheme="https://lierabbit.cn/categories/%E7%9B%B4%E9%80%9ABAT%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>台阶问题</title>
    <link href="https://lierabbit.cn/2018/02/26/%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98/"/>
    <id>https://lierabbit.cn/2018/02/26/台阶问题/</id>
    <published>2018-02-26T15:00:08.000Z</published>
    <updated>2018-08-25T09:05:48.592Z</updated>
    
    <content type="html"><![CDATA[<p>有n级台阶，一个人每次上一级或者两级，问有多少种走完n级台阶的方法。为了防止溢出，请将结果Mod 1000000007<br>给定一个正整数int n，请返回一个数，代表上楼的方式数。保证n小于等于100000。<br>测试样例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">返回：1</span><br></pre></td></tr></table></figure><p>思路：</p><ul><li>1级台阶只有一种方式：往上走一级</li><li>2级台阶2种方式：往上走两级</li><li>3级及以上台阶：f(i)=f(i-1)+f(i-2)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        a[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        a[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            a[i] = (a[i - <span class="number">1</span>] + a[i - <span class="number">2</span>]) % <span class="number">1000000007</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> a[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有n级台阶，一个人每次上一级或者两级，问有多少种走完n级台阶的方法。为了防止溢出，请将结果Mod 1000000007&lt;br&gt;给定一个正整数int n，请返回一个数，代表上楼的方式数。保证n小于等于100000。&lt;br&gt;测试样例：&lt;/p&gt;
&lt;figure class=&quot;hi
      
    
    </summary>
    
      <category term="直通BAT面试算法" scheme="https://lierabbit.cn/categories/%E7%9B%B4%E9%80%9ABAT%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>找零钱</title>
    <link href="https://lierabbit.cn/2018/02/26/%E6%89%BE%E9%9B%B6%E9%92%B1/"/>
    <id>https://lierabbit.cn/2018/02/26/找零钱/</id>
    <published>2018-02-26T07:01:49.000Z</published>
    <updated>2018-08-25T08:48:12.496Z</updated>
    
    <content type="html"><![CDATA[<p>有数组money，money中所有的值都为正数且不重复。每个值代表一种面值的货币，每种面值的货币可以使用任意张，再给定一个整数aim(小于等于1000)代表要找的钱数，求换钱有多少种方法。<br>给定数组money及它的大小(小于等于50)，同时给定一个整数aim，请返回有多少种方法可以凑成aim。<br>测试样例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1,2,4],3,3</span><br><span class="line">返回：2</span><br></pre></td></tr></table></figure><p>假设arr={5、10、25、1},aim=1000。</p><h3 id="暴力搜索"><a href="#暴力搜索" class="headerlink" title="暴力搜索"></a>暴力搜索</h3><ol><li>用0张5元的货币，让[10,25,1]组成剩下的1000 ，最终方法数记为—————- res1</li><li>用1张5元的货币，让[10,25,1]组成剩下的995   ，最终方法数记为—————- res2</li><li>用2张5元的货币，让[10,25,1]组成剩下的990   ，最终方法数记为—————- res3<br>····································································································································<br>····································································································································<br>····································································································································</li><li>用200张5元的货币，让[10,25,1]组成剩下的0 ，最终方法数记为————— res201<br>res = res1 + res2 + res3 + ······+ res201</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">process1</span><span class="params">(<span class="keyword">int</span>[] money, <span class="keyword">int</span> index, <span class="keyword">int</span> aim)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (index == money.length)</span><br><span class="line">        res = aim == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>; <span class="comment">// 是否成功组成aim</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; money[index] * i &lt;= aim; i++) &#123;</span><br><span class="line">            res += process1(money, index + <span class="number">1</span>, aim - money[index] * i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="记忆搜索：由于暴力搜索由许多重复计算，改进而得"><a href="#记忆搜索：由于暴力搜索由许多重复计算，改进而得" class="headerlink" title="记忆搜索：由于暴力搜索由许多重复计算，改进而得"></a>记忆搜索：由于暴力搜索由许多重复计算，改进而得</h3><p>例如：<br>如果已经使用0张5元和1张10元的情况下，后续将求:process1(money,2,990)<br>2 :表示money剩下的钱为money[2,3],即[25,1]<br>990 :表示要找的剩余钱数。<br>当已经使用2张5元和0张10元的情况下，后续还是要求process1(money,2,990)<br>改进方式：发现递归过程只与index与aim有关，将index与aim的结果保存起来，若已经出现，则直接返回之前计算的结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">process2</span><span class="params">(<span class="keyword">int</span>[] money, <span class="keyword">int</span> index, <span class="keyword">int</span> aim, <span class="keyword">int</span>[][] map)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (index == money.length)</span><br><span class="line">        res = aim == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> row = index + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> col;</span><br><span class="line">        <span class="keyword">int</span> cacheWays;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; money[index] * i &lt;= aim; i++) &#123;</span><br><span class="line">            col = aim - money[index] * i;</span><br><span class="line">            cacheWays = map[row][col];</span><br><span class="line">            <span class="keyword">if</span> (cacheWays != <span class="number">0</span>) &#123;</span><br><span class="line">                res += cacheWays == -<span class="number">1</span> ? <span class="number">0</span> : cacheWays;</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                res += process2(money, row, col, map);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    map[index][aim] = res == <span class="number">0</span> ? -<span class="number">1</span> : res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动态规划：按序计算从简单到复杂的情况"><a href="#动态规划：按序计算从简单到复杂的情况" class="headerlink" title="动态规划：按序计算从简单到复杂的情况"></a>动态规划：按序计算从简单到复杂的情况</h3><p><img src="https://blog-1252204470.cos.ap-guangzhou.myqcloud.com/2018/02/26/%E6%89%BE%E9%9B%B6%E9%92%B1/1.jpg" alt=""><br>记忆搜索方法与动态规划方法的联系</p><ol><li>记忆化搜索方法就是某种形态的动态规划方法，记忆化搜索方法不关心到达某一个递归过程的路径。</li><li>只是单纯地对计算过的递归过程进行记录，避免重复的递归过程。</li><li>动态规划的方法则是规定好每一个递归过程的计算顺序，依次进行计算，后面的计算过程严格依赖前面的计算过程。</li><li>两者都是空间换时间的方法，也都有枚举的过程，区别就在于动态规划规定计算顺序，而记忆搜索不用规定。</li></ol><p>什么是动态规划方法</p><ol><li>其本质是利用申请的空间来记录每一个暴力搜索的计算结果，下次要用结果的时候直接使用，而不在进行重复的递归过程。</li><li>动态规划规定每一种递归状态的计算顺序，依次进行计算。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">process3</span><span class="params">(<span class="keyword">int</span>[] money, <span class="keyword">int</span> index, <span class="keyword">int</span> aim)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[money.length][aim + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; money.length; i++) &#123; <span class="comment">// 组成0的方法只有1种那就是不用</span></span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= aim; i++) &#123; <span class="comment">// 只使用money[0]货币的情况下组成i的方法有几种</span></span><br><span class="line">        <span class="keyword">if</span> (i % money[<span class="number">0</span>] == <span class="number">0</span>)</span><br><span class="line">            dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            dp[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; money.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= aim; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k * money[i] &lt;= j; k++)</span><br><span class="line">                dp[i][j] += dp[i - <span class="number">1</span>][j - money[i] * k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[money.length - <span class="number">1</span>][aim];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优化动态规划"><a href="#优化动态规划" class="headerlink" title="优化动态规划"></a>优化动态规划</h3><p><img src="https://blog-1252204470.cos.ap-guangzhou.myqcloud.com/2018/02/26/%E6%89%BE%E9%9B%B6%E9%92%B1/2.jpg" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">process4</span><span class="params">(<span class="keyword">int</span>[] money, <span class="keyword">int</span> index, <span class="keyword">int</span> aim)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[money.length][aim + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; money.length; i++) &#123; <span class="comment">// 组成0的方法只有1种那就是不用</span></span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= aim; i++) &#123; <span class="comment">// 只使用money[0]货币的情况下组成i的方法有几种</span></span><br><span class="line">        <span class="keyword">if</span> (i % money[<span class="number">0</span>] == <span class="number">0</span>)</span><br><span class="line">            dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            dp[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; money.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= aim; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j - money[i] &gt;= <span class="number">0</span>)</span><br><span class="line">                dp[i][j] = dp[i][j - money[i]] + dp[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[money.length - <span class="number">1</span>][aim];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4种方法的集合"><a href="#4种方法的集合" class="headerlink" title="4种方法的集合"></a>4种方法的集合</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exchange</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countWays</span><span class="params">(<span class="keyword">int</span>[] money, <span class="keyword">int</span> n, <span class="keyword">int</span> aim)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span> (money == <span class="keyword">null</span> || money.length == <span class="number">0</span> || aim &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 暴力搜索</span></span><br><span class="line"><span class="comment">//        return process1(money, 0, aim);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记忆搜索</span></span><br><span class="line"><span class="comment">//        int[][] map = new int[n + 1][aim + 1];</span></span><br><span class="line"><span class="comment">//        return process2(money, 0, aim, map);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 由记忆搜索引出的动态规划</span></span><br><span class="line"><span class="comment">//        return process3(money, n, aim);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 动态规划</span></span><br><span class="line">        <span class="keyword">return</span> process4(money, n, aim);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 暴力搜索</span></span><br><span class="line"><span class="comment">     * 用money[index...money.length-1]这里的钱组成aim，有几种方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> money</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> aim</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">process1</span><span class="params">(<span class="keyword">int</span>[] money, <span class="keyword">int</span> index, <span class="keyword">int</span> aim)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (index == money.length)</span><br><span class="line">            res = aim == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>; <span class="comment">// 是否成功组成aim</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; money[index] * i &lt;= aim; i++) &#123;</span><br><span class="line">                res += process1(money, index + <span class="number">1</span>, aim - money[index] * i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记忆搜索</span></span><br><span class="line"><span class="comment">     * 用money[index...money.length-1]这里的钱组成aim，有几种方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> money</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> aim</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">process2</span><span class="params">(<span class="keyword">int</span>[] money, <span class="keyword">int</span> index, <span class="keyword">int</span> aim, <span class="keyword">int</span>[][] map)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (index == money.length)</span><br><span class="line">            res = aim == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> row = index + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> col;</span><br><span class="line">            <span class="keyword">int</span> cacheWays;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; money[index] * i &lt;= aim; i++) &#123;</span><br><span class="line">                col = aim - money[index] * i;</span><br><span class="line">                cacheWays = map[row][col];</span><br><span class="line">                <span class="keyword">if</span> (cacheWays != <span class="number">0</span>) &#123;</span><br><span class="line">                    res += cacheWays == -<span class="number">1</span> ? <span class="number">0</span> : cacheWays;</span><br><span class="line">                &#125; <span class="keyword">else</span></span><br><span class="line">                    res += process2(money, row, col, map);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        map[index][aim] = res == <span class="number">0</span> ? -<span class="number">1</span> : res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 由记忆搜索引出的动态规划</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> money</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> aim</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">process3</span><span class="params">(<span class="keyword">int</span>[] money, <span class="keyword">int</span> index, <span class="keyword">int</span> aim)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[money.length][aim + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; money.length; i++) &#123; <span class="comment">// 组成0的方法只有1种那就是不用</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= aim; i++) &#123; <span class="comment">// 只使用money[0]货币的情况下组成i的方法有几种</span></span><br><span class="line">            <span class="keyword">if</span> (i % money[<span class="number">0</span>] == <span class="number">0</span>)</span><br><span class="line">                dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; money.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= aim; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k * money[i] &lt;= j; k++)</span><br><span class="line">                    dp[i][j] += dp[i - <span class="number">1</span>][j - money[i] * k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[money.length - <span class="number">1</span>][aim];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 优化后的动态规划</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> money</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> aim</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">process4</span><span class="params">(<span class="keyword">int</span>[] money, <span class="keyword">int</span> index, <span class="keyword">int</span> aim)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[money.length][aim + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; money.length; i++) &#123; <span class="comment">// 组成0的方法只有1种那就是不用</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= aim; i++) &#123; <span class="comment">// 只使用money[0]货币的情况下组成i的方法有几种</span></span><br><span class="line">            <span class="keyword">if</span> (i % money[<span class="number">0</span>] == <span class="number">0</span>)</span><br><span class="line">                dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; money.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= aim; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j - money[i] &gt;= <span class="number">0</span>)</span><br><span class="line">                    dp[i][j] = dp[i][j - money[i]] + dp[i - <span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[money.length - <span class="number">1</span>][aim];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] money = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        Exchange exchange = <span class="keyword">new</span> Exchange();</span><br><span class="line">        <span class="keyword">int</span> ways = exchange.countWays(money, <span class="number">3</span>, <span class="number">100</span>);</span><br><span class="line">        System.out.println(ways);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有数组money，money中所有的值都为正数且不重复。每个值代表一种面值的货币，每种面值的货币可以使用任意张，再给定一个整数aim(小于等于1000)代表要找的钱数，求换钱有多少种方法。&lt;br&gt;给定数组money及它的大小(小于等于50)，同时给定一个整数aim，请返回有
      
    
    </summary>
    
      <category term="直通BAT面试算法" scheme="https://lierabbit.cn/categories/%E7%9B%B4%E9%80%9ABAT%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>机器吐球</title>
    <link href="https://lierabbit.cn/2018/02/25/%E6%9C%BA%E5%99%A8%E5%90%90%E7%90%83/"/>
    <id>https://lierabbit.cn/2018/02/25/机器吐球/</id>
    <published>2018-02-25T06:36:35.000Z</published>
    <updated>2018-08-25T08:31:23.978Z</updated>
    
    <content type="html"><![CDATA[<p>有一个机器按自然数序列的方式吐出球，1号球，2号球，3号球等等。你有一个袋子，袋子里最多只能装下K个球，并且除袋子以外，你没有更多的空间，一个球一旦扔掉，就再也不可拿回。设计一种选择方式，使得当机器吐出第N号球的时候，你袋子中的球数是K个，同时可以保证从1号球到N号球中的每一个，被选进袋子的概率都是K/N。举一个更具体的例子，有一个只能装下10个球的袋子，当吐出100个球时，袋子里有10 球，并且1~100号中的每一个球被选中的概率都是10/100。然后继续吐球，当吐出1000个球时，袋子里有 10 个球，并且1~1000号中的每一个球被选中的概率都是10/1000。继续吐球，当吐出i个球时，袋子里有10个球，并且1~i号中的每一个球被选中的概率都是10/i。也就是随着N的变化，1~N号球被选中的概率动态变化成k/N。请将吐出第N个球时袋子中的球的编号返回。</p><p>思路：此题核心解法为蓄水池抽样算法，过程如下:</p><ol><li>处理1~k号球时，直接放进袋子里</li><li>处理第i号球时，以k/i的概率决定是否将第i号球放进袋子。如果不决定将第i号球放进袋子，直接扔掉第i号球。如果决定将第i号球放进袋子，那么就从袋子里的k个球中随机扔掉一个，然后把第i号球放入袋子</li><li>处理第i+1号球时，重复步骤1或步骤2</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] selected = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Random rand = <span class="keyword">new</span> Random(<span class="number">12345</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每次拿一个球都会调用这个函数，N表示第i次调用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] carryBalls(<span class="keyword">int</span> N, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    <span class="keyword">if</span> (selected == <span class="keyword">null</span>)</span><br><span class="line">        selected = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">    <span class="keyword">if</span> (N &lt;= k) &#123;</span><br><span class="line">        selected[N - <span class="number">1</span>] = N;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (rand.nextInt(N) &lt; k) <span class="comment">// i/k的概率是否放入</span></span><br><span class="line">            selected[rand.nextInt(k)] = N; <span class="comment">// 1/k的概率随机丢弃一个旧的，放入新的</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> selected;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有一个机器按自然数序列的方式吐出球，1号球，2号球，3号球等等。你有一个袋子，袋子里最多只能装下K个球，并且除袋子以外，你没有更多的空间，一个球一旦扔掉，就再也不可拿回。设计一种选择方式，使得当机器吐出第N号球的时候，你袋子中的球数是K个，同时可以保证从1号球到N号球中的每
      
    
    </summary>
    
      <category term="直通BAT面试算法" scheme="https://lierabbit.cn/categories/%E7%9B%B4%E9%80%9ABAT%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>随机数组打印</title>
    <link href="https://lierabbit.cn/2018/02/25/%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%BB%84%E6%89%93%E5%8D%B0/"/>
    <id>https://lierabbit.cn/2018/02/25/随机数组打印/</id>
    <published>2018-02-25T06:05:56.000Z</published>
    <updated>2018-08-25T08:30:12.857Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个长度为N且没有重复元素的数组arr和一个整数M，实现函数等概率随机打印arr中的M个数。</p><p>思路：</p><ol><li>随机在[0，N-1]抽一个数打印，与N-1交换</li><li>随机在[0，N-2]抽一个数打印，与N-2交换</li><li>……</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] print(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> N, <span class="keyword">int</span> M) &#123;</span><br><span class="line">    Random random = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[M];</span><br><span class="line">    <span class="keyword">int</span> randomValue;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++) &#123;</span><br><span class="line">        randomValue = random.nextInt(N - i);</span><br><span class="line">        res[<span class="number">0</span>] = arr[randomValue];</span><br><span class="line">        swap(arr, randomValue, N - i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定一个长度为N且没有重复元素的数组arr和一个整数M，实现函数等概率随机打印arr中的M个数。&lt;/p&gt;
&lt;p&gt;思路：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;随机在[0，N-1]抽一个数打印，与N-1交换&lt;/li&gt;
&lt;li&gt;随机在[0，N-2]抽一个数打印，与N-2交换&lt;/li&gt;
&lt;l
      
    
    </summary>
    
      <category term="直通BAT面试算法" scheme="https://lierabbit.cn/categories/%E7%9B%B4%E9%80%9ABAT%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>随机区间函数</title>
    <link href="https://lierabbit.cn/2018/02/25/%E9%9A%8F%E6%9C%BA%E5%8C%BA%E9%97%B4%E5%87%BD%E6%95%B0/"/>
    <id>https://lierabbit.cn/2018/02/25/随机区间函数/</id>
    <published>2018-02-25T05:49:42.000Z</published>
    <updated>2018-08-25T08:30:17.577Z</updated>
    
    <content type="html"><![CDATA[<p>假设函数f()等概率随机返回一个在[0,1)范围上的浮点数，那么我们知道，在[0,x)区间上的数出现的概率为x(0&lt;x≤1)。给定一个大于0的整数k，并且可以使用f()函数，请实现一个函数依然返回在[0,1)范围上的数，但是在[0,x)区间上的数出现的概率为x的k次方。</p><p>思路：<br>先来看看如何把[0，X )范围上的数，从概率X调整为概率X^2<br>作法:调用两次f( )，返回较大的数即可。<br>所以本题只用调用K次f( )，返回较大的数，即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Random rand = <span class="keyword">new</span> Random(<span class="number">12345</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> rand.nextFloat();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请调用f()函数实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">random</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> max = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">        max = Math.max(max, f());</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;假设函数f()等概率随机返回一个在[0,1)范围上的浮点数，那么我们知道，在[0,x)区间上的数出现的概率为x(0&amp;lt;x≤1)。给定一个大于0的整数k，并且可以使用f()函数，请实现一个函数依然返回在[0,1)范围上的数，但是在[0,x)区间上的数出现的概率为x的k次方
      
    
    </summary>
    
      <category term="直通BAT面试算法" scheme="https://lierabbit.cn/categories/%E7%9B%B4%E9%80%9ABAT%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>随机01</title>
    <link href="https://lierabbit.cn/2018/02/25/%E9%9A%8F%E6%9C%BA01/"/>
    <id>https://lierabbit.cn/2018/02/25/随机01/</id>
    <published>2018-02-25T05:14:39.000Z</published>
    <updated>2018-08-25T08:16:40.812Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个以p概率产生0，以1-p概率产生1的随机函数RandomP::f()，p是固定的值，但你并不知道是多少。除此之外也不能使用任何额外的随机机制，请用RandomP::f()实现等概率随机产生0和1的随机函数。</p><p>思路：</p><ul><li>f()产生0的概率P，产生1的概率1-P</li><li>产生01和10序列的概率都为P * (1-P )</li><li>不断调用f(),直到能够产生01或10，序列终止。</li><li>如果产生了01，返回0。</li><li>如果产生了10，则返回1,即可。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">double</span> p = <span class="keyword">new</span> Random().nextFloat();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 随机概率p</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Random().nextFloat() &lt; p ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">random01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 通过f函数实现01等概率返回</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        a = f();</span><br><span class="line">        b = f();</span><br><span class="line">        <span class="keyword">if</span> (a != b)</span><br><span class="line">            <span class="keyword">return</span> a &gt; b ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定一个以p概率产生0，以1-p概率产生1的随机函数RandomP::f()，p是固定的值，但你并不知道是多少。除此之外也不能使用任何额外的随机机制，请用RandomP::f()实现等概率随机产生0和1的随机函数。&lt;/p&gt;
&lt;p&gt;思路：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;f()产生
      
    
    </summary>
    
      <category term="直通BAT面试算法" scheme="https://lierabbit.cn/categories/%E7%9B%B4%E9%80%9ABAT%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>随机函数</title>
    <link href="https://lierabbit.cn/2018/02/25/%E9%9A%8F%E6%9C%BA%E5%87%BD%E6%95%B0/"/>
    <id>https://lierabbit.cn/2018/02/25/随机函数/</id>
    <published>2018-02-25T05:02:24.000Z</published>
    <updated>2018-08-25T08:11:21.765Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个等概率随机产生1~5的随机函数，除此之外，不能使用任何额外的随机机制，请实现等概率随机产生1~7的随机函数。(给定一个可调用的Random5::random()方法,可以等概率地随机产生1～5的随机函数)</p><p>思路：得到一串均匀分布且长度大于7的连续序列即可（甚至都不需要连续，只要保证能产生7个以上等概率的数即可），在这个序列里选中7个（或7的倍数个），若得到的数不是这7个中的，重新产生，这样这7个数的概率肯定是相同的。<br>步骤：<br>1.已经有等概率随机产生1、2、3、4、5的随机函数。<br>2.根据步骤1得到的结果减1，将得到f( ) -&gt; 0、1、2、3、4<br>3.f( )x5 -&gt; 0、5、10、15、20<br>4.f( )x5+f () -&gt; 0、1、2、3、4…..24 <code>注意这两个f( )是分别调用的，不要化简。</code><br>5.如果步骤4产生的数大于20，则重复进行步骤4直到产生的结果在0~20之间。<br>6.步骤5的结果将等概率随机产生0~20，所以步骤5的结果%7之后等概率产生0~6。<br>7.步骤6的结果加1，将等概率产生1~7。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Random rand = <span class="keyword">new</span> Random(<span class="number">123456</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 随机产生[1,5]</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">rand5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + rand.nextInt(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过rand5实现rand7</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">randomNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value = (rand5() - <span class="number">1</span>) * <span class="number">5</span> + rand5() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (value &gt; <span class="number">20</span>)</span><br><span class="line">        value = (rand5() - <span class="number">1</span>) * <span class="number">5</span> + rand5() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> value % <span class="number">7</span> + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定一个等概率随机产生1~5的随机函数，除此之外，不能使用任何额外的随机机制，请实现等概率随机产生1~7的随机函数。(给定一个可调用的Random5::random()方法,可以等概率地随机产生1～5的随机函数)&lt;/p&gt;
&lt;p&gt;思路：得到一串均匀分布且长度大于7的连续序列即
      
    
    </summary>
    
      <category term="直通BAT面试算法" scheme="https://lierabbit.cn/categories/%E7%9B%B4%E9%80%9ABAT%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>蚂蚁</title>
    <link href="https://lierabbit.cn/2018/02/25/%E8%9A%82%E8%9A%81/"/>
    <id>https://lierabbit.cn/2018/02/25/蚂蚁/</id>
    <published>2018-02-25T03:13:03.000Z</published>
    <updated>2018-08-25T07:48:33.014Z</updated>
    
    <content type="html"><![CDATA[<p>n只蚂蚁从正n边形的n个定点沿着边移动，速度是相同的，问它们碰头的概率是多少？<br>给定一个正整数n，请返回一个数组，其中两个元素分别为结果的分子和分母，请化为最简分数。<br>测试样例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">返回：[3,4]</span><br></pre></td></tr></table></figure><p>思路：如果蚂蚁移动方向不都相同，则必定碰头。只有全部顺时针或者逆时针方向移动才不会碰头</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] collision(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">int</span> all = (<span class="keyword">int</span>) Math.pow(<span class="number">2</span>, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> g = gcd(all, all - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">    res[<span class="number">0</span>] = (all - <span class="number">2</span>) / g;</span><br><span class="line">    res[<span class="number">1</span>] = all / g;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最大公约数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">while</span> (y != <span class="number">0</span>) &#123;</span><br><span class="line">        temp = y;</span><br><span class="line">        y = x % y;</span><br><span class="line">        x = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;n只蚂蚁从正n边形的n个定点沿着边移动，速度是相同的，问它们碰头的概率是多少？&lt;br&gt;给定一个正整数n，请返回一个数组，其中两个元素分别为结果的分子和分母，请化为最简分数。&lt;br&gt;测试样例：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;tabl
      
    
    </summary>
    
      <category term="直通BAT面试算法" scheme="https://lierabbit.cn/categories/%E7%9B%B4%E9%80%9ABAT%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>足球比赛</title>
    <link href="https://lierabbit.cn/2018/02/24/%E8%B6%B3%E7%90%83%E6%AF%94%E8%B5%9B/"/>
    <id>https://lierabbit.cn/2018/02/24/足球比赛/</id>
    <published>2018-02-24T04:24:20.000Z</published>
    <updated>2018-08-25T07:47:26.554Z</updated>
    
    <content type="html"><![CDATA[<p>有2k只球队，有k-1个强队，其余都是弱队，随机把它们分成k组比赛，每组两个队，问两强相遇的概率是多大？<br>给定一个数k，请返回一个数组，其中有两个元素，分别为最终结果的分子和分母，请化成最简分数<br>测试样例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">返回：[3,7]</span><br></pre></td></tr></table></figure><p>思路：<br>1.求出全部分组情况<br>2.求出两强不相遇的情况<br>3.全部分组-两强不相遇=两强相遇</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] calc(<span class="keyword">int</span> k) &#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">int</span> all = <span class="number">1</span>; <span class="comment">// 分组全部情况</span></span><br><span class="line">    <span class="keyword">int</span> k2 = <span class="number">2</span> * k;</span><br><span class="line">    <span class="keyword">while</span> (k2 != <span class="number">0</span>) &#123;</span><br><span class="line">        all *= k2 - <span class="number">1</span>;</span><br><span class="line">        k2 -= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> noTowStrong = C(k + <span class="number">1</span>, k - <span class="number">1</span>) * A(k - <span class="number">1</span>, k - <span class="number">1</span>); <span class="comment">// 两强不相遇的情况</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">    res[<span class="number">0</span>] = all - noTowStrong;</span><br><span class="line">    res[<span class="number">1</span>] = all;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> g = gcd(res[<span class="number">0</span>], res[<span class="number">1</span>]);</span><br><span class="line">    res[<span class="number">0</span>] /= g;</span><br><span class="line">    res[<span class="number">1</span>] /= g;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最大公约数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (y != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = y;</span><br><span class="line">        y = x % y;</span><br><span class="line">        x = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟C运算</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> down 下标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> up   上标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> down, <span class="keyword">int</span> up)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> A(down, up) / A(up, up);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟A运算</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> down 下标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> up   上标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">A</span><span class="params">(<span class="keyword">int</span> down, <span class="keyword">int</span> up)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; up; i++)</span><br><span class="line">        data *= down--;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有2k只球队，有k-1个强队，其余都是弱队，随机把它们分成k组比赛，每组两个队，问两强相遇的概率是多大？&lt;br&gt;给定一个数k，请返回一个数组，其中有两个元素，分别为最终结果的分子和分母，请化成最简分数&lt;br&gt;测试样例：&lt;/p&gt;
&lt;figure class=&quot;highligh
      
    
    </summary>
    
      <category term="直通BAT面试算法" scheme="https://lierabbit.cn/categories/%E7%9B%B4%E9%80%9ABAT%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>错装信封</title>
    <link href="https://lierabbit.cn/2018/02/24/%E9%94%99%E8%A3%85%E4%BF%A1%E5%B0%81/"/>
    <id>https://lierabbit.cn/2018/02/24/错装信封/</id>
    <published>2018-02-24T03:46:24.000Z</published>
    <updated>2018-08-25T07:42:57.311Z</updated>
    
    <content type="html"><![CDATA[<p>有n个信封，包含n封信，现在把信拿出来，再装回去，要求每封信不能装回它原来的信封，问有多少种装法?<br>给定一个整数n，请返回装发个数，为了防止溢出，请返回结果Mod 1000000007的值。保证n的大小小于等于300。<br>测试样例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">返回：1</span><br></pre></td></tr></table></figure><p>思路：<br>对于n封信按照题目要求的装法即为f(n)<br>假设第n封信放入了第i个信封<br>情况一:第i封信也放入了第n个信封中，后续为f(n-2)<br>情况二:第i封信没放入了第n个信封中，后续为f(n-1)<br>n封信放入i个信封，i的选择有(n-1)种<br>所以总数为f(n)= (n-1)*(f(n-1)+f(n-2))</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">0</span>, last = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = (<span class="keyword">int</span>) ((<span class="keyword">long</span>) (i - <span class="number">1</span>) * (<span class="keyword">long</span>) (pre + last) % <span class="number">1000000007</span>);</span><br><span class="line">            pre = last;</span><br><span class="line">            last = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有n个信封，包含n封信，现在把信拿出来，再装回去，要求每封信不能装回它原来的信封，问有多少种装法?&lt;br&gt;给定一个整数n，请返回装发个数，为了防止溢出，请返回结果Mod 1000000007的值。保证n的大小小于等于300。&lt;br&gt;测试样例：&lt;/p&gt;
&lt;figure cla
      
    
    </summary>
    
      <category term="直通BAT面试算法" scheme="https://lierabbit.cn/categories/%E7%9B%B4%E9%80%9ABAT%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
