<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>谎话兔博客</title>
  
  <subtitle>LieRabbit</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://lierabbit.cn/"/>
  <updated>2018-09-04T03:07:16.944Z</updated>
  <id>https://lierabbit.cn/</id>
  
  <author>
    <name>谎话兔</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>括号生成</title>
    <link href="https://lierabbit.cn/2018/09/04/%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/"/>
    <id>https://lierabbit.cn/2018/09/04/括号生成/</id>
    <published>2018-09-04T02:41:25.000Z</published>
    <updated>2018-09-04T03:07:16.944Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。</p><p>例如，给出 n = 3，生成结果为：</p><blockquote><p>[<br>  “((()))”,<br>  “(()())”,<br>  “(())()”,<br>  “()(())”,<br>  “()()()”<br>]</p></blockquote><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>合法的括号：</p><ol><li>左括号在对应右括号的左边 -&gt; 先添加左括号再添加右括号即可保证左括号在右括号的左边</li><li>相同数量的左右括号 -&gt; 右括号数量 == 左括号数量</li><li>最终形成的字符串长度为n*2，也就是左右括号各n个</li></ol><p>根据以上分析使用回溯法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    process(res, <span class="string">""</span>, <span class="number">0</span>, <span class="number">0</span>, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> res   结果</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> str   结果中的一项</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> open  左括号数量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> close 右括号数量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n     生成的括号对数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(List&lt;String&gt; res, String str, <span class="keyword">int</span> open, <span class="keyword">int</span> close, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str.length() == n * <span class="number">2</span>) &#123;</span><br><span class="line">        res.add(str);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (open &lt; n)</span><br><span class="line">            process(res, str + <span class="string">"("</span>, open + <span class="number">1</span>, close, n);</span><br><span class="line">        <span class="keyword">if</span> (close &lt; open)</span><br><span class="line">            process(res, str + <span class="string">")"</span>, open, close + <span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。&lt;/p&gt;
&lt;p&gt;例如，给出 n =
      
    
    </summary>
    
      <category term="LeetCode算法之旅" scheme="https://lierabbit.cn/categories/LeetCode%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>合并两个有序链表</title>
    <link href="https://lierabbit.cn/2018/09/03/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <id>https://lierabbit.cn/2018/09/03/合并两个有序链表/</id>
    <published>2018-09-03T08:46:54.000Z</published>
    <updated>2018-09-03T08:55:09.881Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><blockquote><p>示例：<br>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p></blockquote><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>先比较头节点，然后递归比较剩下的节点，最后将其连接起来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l1 == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    <span class="keyword">if</span> (l2 == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">        l1.next = mergeTwoLists(l1.next, l2);</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        l2.next = mergeTwoLists(l1, l2.next);</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 &lt;/p&gt;
&lt;blockquot
      
    
    </summary>
    
      <category term="LeetCode算法之旅" scheme="https://lierabbit.cn/categories/LeetCode%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>仿segmentfault-table横向滚动</title>
    <link href="https://lierabbit.cn/2018/09/02/%E4%BB%BFsegmentfault-table%E6%A8%AA%E5%90%91%E6%BB%9A%E5%8A%A8/"/>
    <id>https://lierabbit.cn/2018/09/02/仿segmentfault-table横向滚动/</id>
    <published>2018-09-02T08:37:47.000Z</published>
    <updated>2018-09-02T09:56:24.393Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><a href="https://lierabbit.cn">自己的博客</a>在用移动端访问时，如果table的列数足够多会显示不全，如下图红圈所示</p><p><img src="https://blog-1252204470.cos.ap-guangzhou.myqcloud.com/2018/09/02/%E4%BB%BFsf--table%E6%A8%AA%E5%90%91%E6%BB%9A%E5%8A%A8/1.png" alt=""></p><p>正常情况如图</p><p><img src="https://blog-1252204470.cos.ap-guangzhou.myqcloud.com/2018/09/02/%E4%BB%BFsf--table%E6%A8%AA%E5%90%91%E6%BB%9A%E5%8A%A8/2.png" alt=""></p><h2 id="解决过程"><a href="#解决过程" class="headerlink" title="解决过程"></a>解决过程</h2><p>使用chrome发现<a href="https://segmentfault.com" target="_blank" rel="noopener">segmentfault</a>的解决方法是在table上套一个table-wrap，如下图蓝色背景和红圈所示</p><p><img src="https://blog-1252204470.cos.ap-guangzhou.myqcloud.com/2018/09/02/%E4%BB%BFsf--table%E6%A8%AA%E5%90%91%E6%BB%9A%E5%8A%A8/3.png" alt=""></p><p>首先想到直接在table上套一个table-wrap即可<br>接着查看别的table时发现并不是每一个table都被套上一个table-wrap，如下图所示，也就是说只有显示不全的table才会套上table-wrap</p><p><img src="https://blog-1252204470.cos.ap-guangzhou.myqcloud.com/2018/09/02/%E4%BB%BFsf--table%E6%A8%AA%E5%90%91%E6%BB%9A%E5%8A%A8/4.png" alt=""></p><p>table什么情况是显示不全？<br>那就是table的宽度 &gt; 文章的宽度</p><p>通过以上分析可以得出简单的步骤：</p><ol><li>获取文章的宽度(articleWidth)</li><li>获取所有的table</li><li>找出比articleWidth宽的table</li><li>使其被.table-wrap包囊</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> articleWidth = <span class="built_in">document</span>.getElementById(<span class="string">'文章'</span>).clientWidth;</span><br><span class="line"><span class="keyword">let</span> tables = $(<span class="string">'table'</span>);</span><br><span class="line"></span><br><span class="line">tables.each(<span class="function">(<span class="params">index, table</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (table.clientWidth &gt; articleWidth) &#123;</span><br><span class="line">        table.outerHTML = <span class="string">"&lt;div class='table-wrap'&gt;"</span> + table.outerHTML + <span class="string">"&lt;/div&gt;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>别忘了补上css<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.table-wrap</span>&#123;</span><br><span class="line">  <span class="attribute">overflow-x</span>: scroll;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其实不用判断table的宽度 &gt; 文章的宽度也能实现，让每一个table都套上.table-wrap，使用如下css<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.table-wrap</span>&#123;</span><br><span class="line">  <span class="attribute">overflow-x</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样的话只是会在html上多一点<code>&lt;div class=&quot;table-wrap&quot;&gt;&lt;/div&gt;</code>而已，并且当页面大小发生变化也会根据需要是否出现滚动条</p><p>实际效果用移动端或者chrome模拟移动端看<a href="https://lierabbit.cn/2018/05/08/最长回文子串">https://lierabbit.cn/2018/05/08/最长回文子串</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://lierabbit.cn&quot;&gt;自己的博客&lt;/a&gt;在用移动端访问时，如果table的列数足够多
      
    
    </summary>
    
    
      <category term="HTML" scheme="https://lierabbit.cn/tags/HTML/"/>
    
      <category term="CSS" scheme="https://lierabbit.cn/tags/CSS/"/>
    
      <category term="JavaScript" scheme="https://lierabbit.cn/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>有效的括号（Valid Parentheses）</title>
    <link href="https://lierabbit.cn/2018/09/01/%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/"/>
    <id>https://lierabbit.cn/2018/09/01/有效的括号/</id>
    <published>2018-09-01T12:16:02.000Z</published>
    <updated>2018-09-01T12:32:51.241Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li></ol><p>注意空字符串可被认为是有效字符串。</p><blockquote><p>示例 1:<br>输入: “()”<br>输出: true</p></blockquote><blockquote><p>示例 2:<br>输入: “()[]{}”<br>输出: true</p></blockquote><blockquote><p>示例 3:<br>输入: “(]”<br>输出: false</p></blockquote><blockquote><p>示例 4:<br>输入: “([)]”<br>输出: false</p></blockquote><blockquote><p>示例 5:<br>输入: “{[]}”<br>输出: true</p></blockquote><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>合法的括号特征：<code>当右括号出现，则紧靠其左边必有对应的左括号</code><br>具体做法：</p><ol><li>利用一个栈记录遍历到的左括号对应的右括号</li><li>当右括号出现，若栈顶与右括号一致则合法，反之不合法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, len = s.length(); i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> ch = s.charAt(i);</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">'('</span>)</span><br><span class="line">            stack.add(<span class="string">')'</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">'&#123;'</span>)</span><br><span class="line">            stack.add(<span class="string">'&#125;'</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">'['</span>)</span><br><span class="line">            stack.add(<span class="string">']'</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (stack.isEmpty() || stack.pop() != ch)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。&lt;/p&gt;
&lt;p&gt;有效字符串需满
      
    
    </summary>
    
      <category term="LeetCode算法之旅" scheme="https://lierabbit.cn/categories/LeetCode%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>删除链表的倒数第N个节点（Remove Nth Node From End of List）</title>
    <link href="https://lierabbit.cn/2018/08/31/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
    <id>https://lierabbit.cn/2018/08/31/删除链表的倒数第N个节点/</id>
    <published>2018-08-31T02:37:17.000Z</published>
    <updated>2018-09-01T12:17:47.736Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</p><p>示例：</p><blockquote><p>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.<br>当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.<br>说明：<br>给定的 n 保证是有效的。</p></blockquote><p>进阶：<br>你能尝试使用一趟扫描实现吗</p><p>ListNode数据结构<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line"></span><br><span class="line">    ListNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>如何一趟遍历获取倒数第n个节点？<br>使用2个指针first,second，first在前，second在后，保持间隔n走到链尾，这样second就是倒数第n个节点</p><p>如何删除当前节点操作？<br>前一个节点.next = 前一个节点.next.next</p><p>由于头节点没有前一个节点了，如何删除头节点？<br>在头节点前面加入临时头节点，这样原头节点就和普通节点一致</p><p>解决了上述3个问题可得出以下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 为了方便操作建立临时头节点</span></span><br><span class="line">    ListNode tempHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    tempHead.next = head;</span><br><span class="line">    ListNode first = tempHead;</span><br><span class="line">    ListNode second = tempHead;</span><br><span class="line">    <span class="comment">// 让first先走n+1步</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        first = first.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 两个指针一起走，当first走到链尾，second就走到倒数第n+1个节点</span></span><br><span class="line">    <span class="keyword">while</span> (first != <span class="keyword">null</span>) &#123;</span><br><span class="line">        first = first.next;</span><br><span class="line">        second = second.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除下一个节点即删除倒数第n个节点</span></span><br><span class="line">    second.next = second.next.next;</span><br><span class="line">    <span class="keyword">return</span> tempHead.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;blockquote&gt;

      
    
    </summary>
    
      <category term="LeetCode算法之旅" scheme="https://lierabbit.cn/categories/LeetCode%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>四数之和（4Sum）</title>
    <link href="https://lierabbit.cn/2018/08/30/%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>https://lierabbit.cn/2018/08/30/四数之和/</id>
    <published>2018-08-30T06:33:15.000Z</published>
    <updated>2018-08-30T06:59:41.815Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。<br>注意：<br><strong>答案中不可以包含重复的四元组。</strong><br>示例：</p><blockquote><p>给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。<br>满足要求的四元组集合为：<br>[<br>  [-1,  0, 0, 1],<br>  [-2, -1, 1, 2],<br>  [-2,  0, 0, 2]<br>]</p></blockquote><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>通过观察之前的<a href="https://lierabbit.cn/2018/04/22/两数之和/">两数之和</a>，<a href="https://lierabbit.cn/2018/05/23/三数之和/">三数之和</a>发现所有的K数之和问题都可以转变成两数之和问题：</p><ol><li>将K数之和问题转化为K-1数之和问题</li><li>重复1直到k==2</li><li>两数之和利用夹逼算法解决</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; fourSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">return</span> kSum(nums, <span class="number">0</span>, <span class="number">4</span>, target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; kSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> k, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> left = start, right = len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = nums[left] + nums[right];</span><br><span class="line">            <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">                List&lt;Integer&gt; temp = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">                temp.add(nums[left]);</span><br><span class="line">                temp.add(nums[right]);</span><br><span class="line">                res.add(temp);</span><br><span class="line">                <span class="comment">// 跳过左边重复数字</span></span><br><span class="line">                <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>])</span><br><span class="line">                    left++;</span><br><span class="line">                <span class="comment">// 跳过右边重复数字</span></span><br><span class="line">                <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>])</span><br><span class="line">                    right--;</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target)</span><br><span class="line">                left++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start, end = len - (k - <span class="number">1</span>); i &lt; end; i++) &#123;</span><br><span class="line">            <span class="comment">// 跳过重复数字</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; start &amp;&amp; nums[i] == nums[i - <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 将K数之和转换成K-1数之和</span></span><br><span class="line">            List&lt;List&lt;Integer&gt;&gt; temp = kSum(nums, i + <span class="number">1</span>, k - <span class="number">1</span>, target - nums[i]);</span><br><span class="line">            <span class="keyword">for</span> (List&lt;Integer&gt; item : temp)</span><br><span class="line">                item.add(<span class="number">0</span>, nums[i]);</span><br><span class="line">            res.addAll(temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(N<sup>k-1</sup>)，在本题中k=4，即O(N<sup>3</sup>)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d
      
    
    </summary>
    
      <category term="LeetCode算法之旅" scheme="https://lierabbit.cn/categories/LeetCode%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>电话号码的字母组合（Letter Combinations of a Phone Number）</title>
    <link href="https://lierabbit.cn/2018/08/29/%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/"/>
    <id>https://lierabbit.cn/2018/08/29/电话号码的字母组合/</id>
    <published>2018-08-29T03:01:19.000Z</published>
    <updated>2018-08-29T07:45:07.503Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。<br>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。<br><img src="https://blog-1252204470.cos.ap-guangzhou.myqcloud.com/2018/08/29/%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/1.png" alt=""></p><p><strong>示例:</strong></p><blockquote><p>输入：”23”<br>输出：[“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”].</p></blockquote><p><strong>说明:</strong><br>尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>利用队列先进先出的性质进行横向组合。<br>例如输入“23”</p><ol><li>首先取出输入中的第一个数2，它所代表的字母为a,b,c，依次放入队列，</li><li>接着取出输入中的下一个数3，它所代表的字母为d,e,f。</li><li>队列依次出队与d,e,f进行组合</li></ol><p>过程如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot; + a = a</span><br><span class="line">&quot;&quot; + b = b</span><br><span class="line">&quot;&quot; + c = c</span><br><span class="line">a + d = ad</span><br><span class="line">a + e = ae</span><br><span class="line">a + f = af</span><br><span class="line">b + d = bd</span><br><span class="line">b + e = be</span><br><span class="line">b + f = bf</span><br><span class="line">c + d = cd</span><br><span class="line">c + e = ce</span><br><span class="line">c + f = cf</span><br></pre></td></tr></table></figure></p><p>如果输入的是“234”，重复2，3步骤即可</p><p>现在还剩2个问题：<br>何时退出这个循环？<br>通过观察可知，<code>输入字符串的长度 == 组合后子项的长度</code><br>也就是说<code>队列里的所有字符串长度 == 输入的字符串长度</code>时组合完成<br>如何取得输入中的下一个数？<br>既然<code>输入字符串的长度 == 组合后子项的长度</code>，那么通过队列里的字符长度获取输入中的下一个数即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCombinations</span><span class="params">(String digits)</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;String&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 使用数组模拟按键映射，这里可以换成HashMap</span></span><br><span class="line">    String[] map = <span class="keyword">new</span> String[]&#123;<span class="string">""</span>, <span class="string">""</span>, <span class="string">"abc"</span>, <span class="string">"def"</span>, <span class="string">"ghi"</span>, <span class="string">"jkl"</span>, <span class="string">"mno"</span>, <span class="string">"pqrs"</span>, <span class="string">"tuv"</span>, <span class="string">"wxyz"</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (digits.isEmpty())</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    res.add(<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (res.peek().length() != digits.length()) &#123;</span><br><span class="line">        String temp = res.pop();</span><br><span class="line">        String value = map[digits.charAt(temp.length()) - <span class="string">'0'</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : value.toCharArray())</span><br><span class="line">            res.add(temp + c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。&lt;br&gt;给出数字到字母的映射如下（与电话按键相同）。注意 
      
    
    </summary>
    
      <category term="LeetCode算法之旅" scheme="https://lierabbit.cn/categories/LeetCode%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>最接近的三数之和（3Sum Closest）</title>
    <link href="https://lierabbit.cn/2018/05/23/%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>https://lierabbit.cn/2018/05/23/最接近的三数之和/</id>
    <published>2018-05-23T07:52:05.000Z</published>
    <updated>2018-08-29T07:44:26.375Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。</p><blockquote><p>例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.<br>与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).</p></blockquote><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>确定第一个数，然后通过夹逼算法寻找接近target的数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = nums[<span class="number">0</span>] + nums[<span class="number">1</span>] + nums[<span class="number">2</span>];</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> lo = i + <span class="number">1</span>, hi = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = nums[i] + nums[lo] + nums[hi];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (sum &lt; target)</span><br><span class="line">                lo++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target)</span><br><span class="line">                hi--;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> target;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (Math.abs(target - sum) &lt; Math.abs(target - res))</span><br><span class="line">                res = sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(N<sup>2</sup>)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 tar
      
    
    </summary>
    
      <category term="LeetCode算法之旅" scheme="https://lierabbit.cn/categories/LeetCode%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>三数之和（3Sum）</title>
    <link href="https://lierabbit.cn/2018/05/23/%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>https://lierabbit.cn/2018/05/23/三数之和/</id>
    <published>2018-05-23T07:21:13.000Z</published>
    <updated>2018-08-29T07:43:49.018Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。</p><p>注意：答案中不可以包含重复的三元组。<br>例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，<br>满足要求的三元组集合为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [-1, 0, 1],</span><br><span class="line">  [-1, -1, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>先确定一个数，则另外两数之和等于该数的相反数，通过夹逼算法寻找两数之和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 跳过前后一样的数字</span></span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span> || nums[i] != nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">int</span> lo = i + <span class="number">1</span>, hi = nums.length - <span class="number">1</span>, sum = -nums[i];</span><br><span class="line">            <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[lo] + nums[hi] == sum) &#123;</span><br><span class="line">                    res.add(Arrays.asList(nums[i], nums[lo], nums[hi]));</span><br><span class="line">                    <span class="comment">// 跳过前后一样的数字</span></span><br><span class="line">                    <span class="keyword">while</span> (lo &lt; hi &amp;&amp; nums[lo] == nums[lo + <span class="number">1</span>])</span><br><span class="line">                        lo++;</span><br><span class="line">                    <span class="keyword">while</span> (lo &lt; hi &amp;&amp; nums[hi] == nums[hi - <span class="number">1</span>])</span><br><span class="line">                        hi--;</span><br><span class="line">                    lo++;</span><br><span class="line">                    hi--;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[lo] + nums[hi] &lt; sum)</span><br><span class="line">                    lo++;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    hi--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(N<sup>2</sup>)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0
      
    
    </summary>
    
      <category term="LeetCode算法之旅" scheme="https://lierabbit.cn/categories/LeetCode%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>最长公共前缀（Longest Common Prefix）</title>
    <link href="https://lierabbit.cn/2018/05/21/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/"/>
    <id>https://lierabbit.cn/2018/05/21/最长公共前缀/</id>
    <published>2018-05-21T06:48:08.000Z</published>
    <updated>2018-08-29T07:42:25.409Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>编写一个函数来查找字符串数组中的最长公共前缀。<br>如果不存在公共前缀，返回空字符串 “”。</p><blockquote><p>示例 1:<br>输入: [“flower”,”flow”,”flight”]<br>输出: “fl”</p></blockquote><blockquote><p>示例 2:<br>输入: [“dog”,”racecar”,”car”]<br>输出: “”<br>解释: 输入不存在公共前缀。</p></blockquote><blockquote><p>说明:<br>所有输入只包含小写字母 a-z 。</p></blockquote><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><h3 id="横向匹配所有字符串"><a href="#横向匹配所有字符串" class="headerlink" title="横向匹配所有字符串"></a>横向匹配所有字符串</h3><p><img src="https://blog-1252204470.cos.ap-guangzhou.myqcloud.com/2018/05/21/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/1.jpg" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (strs == <span class="keyword">null</span> || strs.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    String prefix = strs[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (strs[i].indexOf(prefix) != <span class="number">0</span>) &#123;</span><br><span class="line">            prefix = prefix.substring(<span class="number">0</span>, prefix.length() - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (prefix.isEmpty())</span><br><span class="line">                <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> prefix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(S)，其中S是所有字符串中所有字符的总和<br>空间复杂度：O(1)，只使用了恒定的额外空间</p><h3 id="二分搜索"><a href="#二分搜索" class="headerlink" title="二分搜索"></a>二分搜索</h3><p><img src="https://blog-1252204470.cos.ap-guangzhou.myqcloud.com/2018/05/21/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/2.jpg" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix2</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (strs == <span class="keyword">null</span> || strs.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> minLen = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (String str : strs)</span><br><span class="line">        minLen = Math.min(minLen, str.length());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">1</span>, right = minLen;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> middle = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (isCommonPrefix(strs, middle))</span><br><span class="line">            left = middle + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            right = middle - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> strs[<span class="number">0</span>].substring(<span class="number">0</span>, (left + right) / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCommonPrefix</span><span class="params">(String[] strs, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    String str1 = strs[<span class="number">0</span>].substring(<span class="number">0</span>, len);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!strs[i].startsWith(str1))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(S*log(n))，其中S是所有字符串中所有字符的总和。<br>空间复杂度：O(1)。我们只使用了恒定的额外空间。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;编写一个函数来查找字符串数组中的最长公共前缀。&lt;br&gt;如果不存在公共前缀，返回空字符串 “”。&lt;/p&gt;
&lt;blockquot
      
    
    </summary>
    
      <category term="LeetCode算法之旅" scheme="https://lierabbit.cn/categories/LeetCode%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>罗马数字转整数（Roman to Integer）</title>
    <link href="https://lierabbit.cn/2018/05/14/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/"/>
    <id>https://lierabbit.cn/2018/05/14/罗马数字转整数/</id>
    <published>2018-05-14T13:44:33.000Z</published>
    <updated>2018-08-29T07:41:47.041Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">罗马数字包含以下七种字符：I， V， X， L，C，D 和 M。</span><br><span class="line">字符          数值</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure><p>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。<br>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p><ul><li>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。</li><li>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 </li><li>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。</li></ul><p>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p><blockquote><p>示例 1:<br>输入: “III”<br>输出: 3</p></blockquote><blockquote><p>示例 2:<br>输入: “IV”<br>输出: 4</p></blockquote><blockquote><p>示例 3:<br>输入: “IX”<br>输出: 9</p></blockquote><blockquote><p>示例 4:<br>输入: “LVIII”<br>输出: 58<br>解释: C = 100, L = 50, XXX = 30, III = 3.</p></blockquote><blockquote><p>示例 5:<br>输入: “MCMXCIV”<br>输出: 1994<br>解释: M = 1000, CM = 900, XC = 90, IV = 4.</p></blockquote><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>如果当前字符代表的数字小于下一个字符代表的数字，则做减法，反之加法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">'I'</span>, <span class="number">1</span>);</span><br><span class="line">    map.put(<span class="string">'V'</span>, <span class="number">5</span>);</span><br><span class="line">    map.put(<span class="string">'X'</span>, <span class="number">10</span>);</span><br><span class="line">    map.put(<span class="string">'L'</span>, <span class="number">50</span>);</span><br><span class="line">    map.put(<span class="string">'C'</span>, <span class="number">100</span>);</span><br><span class="line">    map.put(<span class="string">'D'</span>, <span class="number">500</span>);</span><br><span class="line">    map.put(<span class="string">'M'</span>, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.get(s.charAt(i)) &lt; map.get(s.charAt(i + <span class="number">1</span>)))</span><br><span class="line">            sum -= map.get(s.charAt(i));</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            sum += map.get(s.charAt(i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sum += map.get(s.charAt(s.length() - <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(1)<br>空间复杂度：O(1)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pr
      
    
    </summary>
    
      <category term="LeetCode算法之旅" scheme="https://lierabbit.cn/categories/LeetCode%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>整数转罗马数字（Integer to Roman）</title>
    <link href="https://lierabbit.cn/2018/05/14/%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/"/>
    <id>https://lierabbit.cn/2018/05/14/整数转罗马数字/</id>
    <published>2018-05-14T08:39:40.000Z</published>
    <updated>2018-08-29T07:40:50.242Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。</span><br><span class="line">字符          数值</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure><p>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。<br>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p><ul><li>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。</li><li>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 </li><li>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。</li></ul><p>给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。</p><blockquote><p>示例 1:<br>输入: 3<br>输出: “III”</p></blockquote><blockquote><p>示例 2:<br>输入: 4<br>输出: “IV”</p></blockquote><blockquote><p>示例 3:<br>输入: 9<br>输出: “IX”</p></blockquote><blockquote><p>示例 4:<br>输入: 58<br>输出: “LVIII”<br>解释: C = 100, L = 50, XXX = 30, III = 3.</p></blockquote><blockquote><p>示例 5:<br>输入: 1994<br>输出: “MCMXCIV”<br>解释: M = 1000, CM = 900, XC = 90, IV = 4.</p></blockquote><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>直接储存各个数位上的字符，再根据数字取出对应的字符🙃</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    String M[] = &#123;<span class="string">""</span>, <span class="string">"M"</span>, <span class="string">"MM"</span>, <span class="string">"MMM"</span>&#125;;</span><br><span class="line">    String C[] = &#123;<span class="string">""</span>, <span class="string">"C"</span>, <span class="string">"CC"</span>, <span class="string">"CCC"</span>, <span class="string">"CD"</span>, <span class="string">"D"</span>, <span class="string">"DC"</span>, <span class="string">"DCC"</span>, <span class="string">"DCCC"</span>, <span class="string">"CM"</span>&#125;;</span><br><span class="line">    String X[] = &#123;<span class="string">""</span>, <span class="string">"X"</span>, <span class="string">"XX"</span>, <span class="string">"XXX"</span>, <span class="string">"XL"</span>, <span class="string">"L"</span>, <span class="string">"LX"</span>, <span class="string">"LXX"</span>, <span class="string">"LXXX"</span>, <span class="string">"XC"</span>&#125;;</span><br><span class="line">    String I[] = &#123;<span class="string">""</span>, <span class="string">"I"</span>, <span class="string">"II"</span>, <span class="string">"III"</span>, <span class="string">"IV"</span>, <span class="string">"V"</span>, <span class="string">"VI"</span>, <span class="string">"VII"</span>, <span class="string">"VIII"</span>, <span class="string">"IX"</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> M[num / <span class="number">1000</span>] + C[num % <span class="number">1000</span> / <span class="number">100</span>] + X[num % <span class="number">100</span> / <span class="number">10</span>] + I[num % <span class="number">10</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(1)<br>空间复杂度：O(1)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pr
      
    
    </summary>
    
      <category term="LeetCode算法之旅" scheme="https://lierabbit.cn/categories/LeetCode%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>盛最多水的容器（Container With Most Water）</title>
    <link href="https://lierabbit.cn/2018/05/14/%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/"/>
    <id>https://lierabbit.cn/2018/05/14/盛最多水的容器/</id>
    <published>2018-05-14T08:06:24.000Z</published>
    <updated>2018-08-29T07:40:46.881Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。画 n 条垂直线，使得垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>从头和尾开始找起，一开始就获得了最大宽度，由于面积是取较小的高度，所以移动高度较小的索引以期待能获得更高的高度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = height.length - <span class="number">1</span>, max = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        max = Math.max(max, (r - l) * Math.min(height[l], height[r]));</span><br><span class="line">        <span class="keyword">if</span> (height[l] &lt; height[r])</span><br><span class="line">            l++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            r--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。画 n 条垂直线，使得垂直线 i 的
      
    
    </summary>
    
      <category term="LeetCode算法之旅" scheme="https://lierabbit.cn/categories/LeetCode%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式匹配（Regular Expression Matching）</title>
    <link href="https://lierabbit.cn/2018/05/14/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D-1/"/>
    <id>https://lierabbit.cn/2018/05/14/正则表达式匹配-1/</id>
    <published>2018-05-14T07:19:01.000Z</published>
    <updated>2018-08-29T07:36:20.811Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个字符串 (s) 和一个字符模式 (p)。实现支持 ‘.’ 和 ‘*‘ 的正则表达式匹配。<br>‘.’ 匹配任意单个字符。<br>‘*‘ 匹配零个或多个前面的元素。<br>匹配应该覆盖整个字符串 (s) ，而不是部分字符串。</p><blockquote><p>说明:<br>s 可能为空，且只包含从 a-z 的小写字母。<br>p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。</p></blockquote><blockquote><p>示例 1:<br>输入:<br>s = “aa”<br>p = “a”<br>输出: false<br>解释: “a” 无法匹配 “aa” 整个字符串。</p></blockquote><blockquote><p>示例 2:<br>输入:<br>s = “aa”<br>p = “a*“<br>输出: true<br>解释: ‘*‘ 代表可匹配零个或多个前面的元素, 即可以匹配 ‘a’ 。因此, 重复 ‘a’ 一次, 字符串可变为 “aa”。</p></blockquote><blockquote><p>示例 3:<br>输入:<br>s = “ab”<br>p = “.*“<br>输出: true<br>解释: “.*“ 表示可匹配零个或多个(‘*‘)任意字符(‘.’)。</p></blockquote><blockquote><p>示例 4:<br>输入:<br>s = “aab”<br>p = “c*a*b”<br>输出: true<br>解释: ‘c’ 可以不被重复, ‘a’ 可以被重复一次。因此可以匹配字符串 “aab”。</p></blockquote><blockquote><p>示例 5:<br>输入:<br>s = “mississippi”<br>p = “mis*is*p*.”<br>输出: false</p></blockquote><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>当模式中的第二个字符是“*”时：<br>如果字符串第一个字符跟模式第一个字符不匹配，则模式后移2个字符，继续匹配。如果字符串第一个字符跟模式第一个字符匹配，可以有2种匹配方式： </p><ul><li>模式后移2字符，相当于x*被忽略</li><li>字符串后移1字符，模式不变，即继续匹配字符下一位，因为*可以匹配多位<br>当模式中的第二个字符不是“*”时：</li><li>如果字符串第一个字符和模式中的第一个字符相匹配，那么字符串和模式都后移一个字符，然后匹配剩余的</li><li>如果字符串第一个字符和模式中的第一个字符相不匹配，直接返回false</li></ul><p>这里需要注意的是：要时刻检验数组是否越界</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || p == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isMatchCore(s, <span class="number">0</span>, p, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatchCore</span><span class="params">(String s, <span class="keyword">int</span> sIndex, String p, <span class="keyword">int</span> pIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 有效性检验：str到尾，pattern到尾，匹配成功</span></span><br><span class="line">    <span class="keyword">if</span> (s.length() == sIndex &amp;&amp; p.length() == pIndex)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// pattern先到尾，匹配失败</span></span><br><span class="line">    <span class="keyword">if</span> (p.length() == pIndex)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 模式后一个字符是*，且字符串第1个跟模式第1个匹配,分2种匹配模式。如不匹配，模式后移2位</span></span><br><span class="line">    <span class="keyword">if</span> (pIndex + <span class="number">1</span> &lt; p.length() &amp;&amp; p.charAt(pIndex + <span class="number">1</span>) == <span class="string">'*'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sIndex &lt; s.length() &amp;&amp; (s.charAt(sIndex) == p.charAt(pIndex) || p.charAt(pIndex) == <span class="string">'.'</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> isMatchCore(s, sIndex + <span class="number">1</span>, p, pIndex) || <span class="comment">// x*匹配1个字符，再匹配str中的下一个</span></span><br><span class="line">                    isMatchCore(s, sIndex, p, pIndex + <span class="number">2</span>); <span class="comment">// 模式后移2位，视为x*匹配0个字符</span></span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> isMatchCore(s, sIndex, p, pIndex + <span class="number">2</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 模式后一个字符不是*，且字符串第1个跟模式第1个匹配，则都后移1位，否则直接返回false</span></span><br><span class="line">        <span class="keyword">if</span> (sIndex &lt; s.length() &amp;&amp; (s.charAt(sIndex) == p.charAt(pIndex) || p.charAt(pIndex) == <span class="string">'.'</span>))</span><br><span class="line">            <span class="keyword">return</span> isMatchCore(s, sIndex + <span class="number">1</span>, p, pIndex + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>只需要注意后一个字符是否为*即可，<br>第一个字符直接进行对比判断，当第二个字符为*时，有2种情况</p><ul><li>0个字符匹配，模式直接往后跳2位</li><li>1个字符匹配，字符串往后跳1位<br>没*的话直接对比匹配即可</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch2</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p.isEmpty())</span><br><span class="line">        <span class="keyword">return</span> s.isEmpty();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> firstMatch = !s.isEmpty() &amp;&amp; (s.charAt(<span class="number">0</span>) == p.charAt(<span class="number">0</span>) || p.charAt(<span class="number">0</span>) == <span class="string">'.'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p.length() &gt; <span class="number">1</span> &amp;&amp; p.charAt(<span class="number">1</span>) == <span class="string">'*'</span>)</span><br><span class="line">        <span class="keyword">return</span> isMatch2(s, p.substring(<span class="number">2</span>)) || (firstMatch &amp;&amp; isMatch2(s.substring(<span class="number">1</span>), p));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> firstMatch &amp;&amp; isMatch2(s.substring(<span class="number">1</span>), p.substring(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个字符串 (s) 和一个字符模式 (p)。实现支持 ‘.’ 和 ‘*‘ 的正则表达式匹配。&lt;br&gt;‘.’ 匹配任意单个
      
    
    </summary>
    
      <category term="LeetCode算法之旅" scheme="https://lierabbit.cn/categories/LeetCode%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>回文数（Palindrome Number）</title>
    <link href="https://lierabbit.cn/2018/05/09/%E5%9B%9E%E6%96%87%E6%95%B0/"/>
    <id>https://lierabbit.cn/2018/05/09/回文数/</id>
    <published>2018-05-09T04:28:24.000Z</published>
    <updated>2018-08-29T07:36:46.618Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p><blockquote><p>示例 1:<br>输入: 121<br>输出: true</p></blockquote><blockquote><p>示例 2:<br>输入: -121<br>输出: false<br>解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</p></blockquote><blockquote><p>示例 3:<br>输入: 10<br>输出: false<br>解释: 从右向左读, 为 01 。因此它不是一个回文数。</p></blockquote><blockquote><p>进阶: 你能不将整数转为字符串来解决这个问题吗？</p></blockquote><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ul><li>如果是负数则不是回文数</li><li>如果个位为0则不是回文数，0除外。因为如果个位为0则首位必须为0，然而除了0之外没有首位为0的数</li><li>反转数的一半，例如x=12321，反转后x=12，reverse=123，那么x==reverse或者x==reverse/10</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span> || (x % <span class="number">10</span> == <span class="number">0</span> &amp;&amp; x != <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> reverse = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 反转数字的一半</span></span><br><span class="line">    <span class="keyword">while</span> (x &gt; reverse) &#123;</span><br><span class="line">        reverse = reverse * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x == reverse || reverse / <span class="number">10</span> == x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(log<sub>10</sub>(n))<br>空间复杂度：O(1)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。&lt;/p&gt;
&lt;blockquote&gt;

      
    
    </summary>
    
      <category term="LeetCode算法之旅" scheme="https://lierabbit.cn/categories/LeetCode%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>字符串转整数（String to Integer (atoi)）</title>
    <link href="https://lierabbit.cn/2018/05/09/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%95%B4%E6%95%B0/"/>
    <id>https://lierabbit.cn/2018/05/09/字符串转整数/</id>
    <published>2018-05-09T03:42:42.000Z</published>
    <updated>2018-08-29T07:36:51.819Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>实现 atoi，将字符串转为整数。<br>在找到第一个非空字符之前，需要移除掉字符串中的空格字符。如果第一个非空字符是正号或负号，选取该符号，并将其与后面尽可能多的连续的数字组合起来，这部分字符即为整数的值。如果第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。<br>字符串可以在形成整数的字符后面包括多余的字符，这些字符可以被忽略，它们对于函数没有影响。<br>当字符串中的第一个非空字符序列不是个有效的整数；或字符串为空；或字符串仅包含空白字符时，则不进行转换。<br>若函数不能执行有效的转换，返回 0。</p><blockquote><p>说明：<br>假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231,  231 − 1]。如果数值超过可表示的范围，则返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。</p></blockquote><blockquote><p>示例 1:<br>输入: “42”<br>输出: 42</p></blockquote><blockquote><p>示例 2:<br>输入: “   -42”<br>输出: -42<br>解释: 第一个非空白字符为 ‘-‘, 它是一个负号。我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。</p></blockquote><blockquote><p>示例 3:<br>输入: “4193 with words”<br>输出: 4193<br>解释: 转换截止于数字 ‘3’ ，因为它的下一个字符不为数字。</p></blockquote><blockquote><p>示例 4:<br>输入: “words and 987”<br>输出: 0<br>解释: 第一个非空字符是 ‘w’, 但它不是数字或正、负号。因此无法执行有效的转换。</p></blockquote><blockquote><p>示例 5:<br>输入: “-91283472332”<br>输出: -2147483648<br>解释: 数字 “-91283472332” 超过 32 位有符号整数范围。 因此返回 INT_MIN (−231) 。</p></blockquote><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>只需要注意4个地方</p><ul><li>字符串前面的空格</li><li>符号位</li><li>只要连续的数字</li><li>溢出判断</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span> || str.length() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>, base = <span class="number">0</span>, sign = <span class="number">1</span>, len = str.length();</span><br><span class="line">    <span class="comment">// 跳过空格</span></span><br><span class="line">    <span class="keyword">while</span> (index &lt; len &amp;&amp; str.charAt(index) == <span class="string">' '</span>)</span><br><span class="line">        index++;</span><br><span class="line">    <span class="comment">// 获取符号位</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; len &amp;&amp; (str.charAt(index) == <span class="string">'+'</span> || str.charAt(index) == <span class="string">'-'</span>))</span><br><span class="line">        sign = <span class="number">1</span> - <span class="number">2</span> * ((str.charAt(index++) == <span class="string">'-'</span>) ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 只取数字，碰到非数字退出循环</span></span><br><span class="line">    <span class="keyword">while</span> (index &lt; len &amp;&amp; str.charAt(index) &gt;= <span class="string">'0'</span> &amp;&amp; str.charAt(index) &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line">        <span class="comment">// 溢出判断，MAX_VALUE的个位为7</span></span><br><span class="line">        <span class="keyword">if</span> (base &gt; Integer.MAX_VALUE / <span class="number">10</span> || (base == Integer.MAX_VALUE / <span class="number">10</span> &amp;&amp; str.charAt(index) - <span class="string">'0'</span> &gt; <span class="number">7</span>))</span><br><span class="line">            <span class="keyword">if</span> (sign == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">        base = base * <span class="number">10</span> + str.charAt(index++) - <span class="string">'0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sign * base;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;实现 atoi，将字符串转为整数。&lt;br&gt;在找到第一个非空字符之前，需要移除掉字符串中的空格字符。如果第一个非空字符是正号或
      
    
    </summary>
    
      <category term="LeetCode算法之旅" scheme="https://lierabbit.cn/categories/LeetCode%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>反转整数（Reverse Integer）</title>
    <link href="https://lierabbit.cn/2018/05/09/%E5%8F%8D%E8%BD%AC%E6%95%B4%E6%95%B0/"/>
    <id>https://lierabbit.cn/2018/05/09/反转整数/</id>
    <published>2018-05-09T02:52:29.000Z</published>
    <updated>2018-09-04T02:32:29.087Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个 32 位有符号整数，将整数中的数字进行反转。</p><blockquote><p>示例 1:<br>输入: 123<br>输出: 321</p></blockquote><blockquote><p>示例 2:<br>输入: -123<br>输出: -321</p></blockquote><blockquote><p>示例 3:<br>输入: 120<br>输出: 21</p></blockquote><blockquote><p>注意：假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−2<sup>31</sup>,  2<sup>31 − 1</sup>]。根据这个假设，如果反转后的整数溢出，则返回 0。</p></blockquote><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>123 -&gt; 321的过程</p><ol><li>res = 0</li><li>获取个位g</li><li>res = res * 10 + g </li><li>原值 /= 10</li><li>重复2 3步骤直到原值为0</li></ol><p>反转的算法有了，还差个溢出判断。<br>a为原值，d为新值，c为个位，如果不溢出的话可以通过<code>a*10+c=d，a=(d-c)/10</code>互相转换<br>根据上述可得以下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> remainder = x % <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> newRes = res * <span class="number">10</span> + remainder;</span><br><span class="line">        <span class="keyword">if</span> ((newRes - remainder) / <span class="number">10</span> != res) <span class="comment">// 如果有溢出则无法回退到原来的结果</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        res = newRes;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(log(x))，x为要反转的数字<br>空间复杂度：O(1)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个 32 位有符号整数，将整数中的数字进行反转。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;示例 1:&lt;br&gt;输入: 1
      
    
    </summary>
    
      <category term="LeetCode算法之旅" scheme="https://lierabbit.cn/categories/LeetCode%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Z字形变换（ZigZag Conversion）</title>
    <link href="https://lierabbit.cn/2018/05/09/Z%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/"/>
    <id>https://lierabbit.cn/2018/05/09/Z字形变换/</id>
    <published>2018-05-09T02:17:52.000Z</published>
    <updated>2018-09-03T08:37:14.562Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>将字符串 “PAYPALISHIRING” 以Z字形排列成给定的行数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">P   A   H   N</span><br><span class="line">A P L S I I G</span><br><span class="line">Y   I   R</span><br></pre></td></tr></table></figure></p><p>之后从左往右，逐行读取字符：”PAHNAPLSIIGYIR”<br>实现一个将字符串进行指定行数变换的函数:<br>string convert(string s, int numRows);</p><blockquote><p>示例 1:<br>输入: s = “PAYPALISHIRING”, numRows = 3<br>输出: “PAHNAPLSIIGYIR”</p></blockquote><blockquote><p>示例 2:<br>输入: s = “PAYPALISHIRING”, numRows = 4<br>输出: “PINALSIGYAHRPI”<br>解释:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">P     I    N</span><br><span class="line">A   L S  I G</span><br><span class="line">Y A   H R</span><br><span class="line">P     I</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>观察示例可知，往下走要走numRows步，往上走要走numRows-2步（除去头尾，因为和往下走重叠）<br>模拟Z字遍历字符串</p><ol><li>往下走numRows步</li><li>往上走numRows-2步</li><li>重复1，2直到字符串遍历结束</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">convert</span><span class="params">(String s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (numRows &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">    StringBuilder[] sbs = <span class="keyword">new</span> StringBuilder[numRows];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numRows; i++)</span><br><span class="line">        sbs[i] = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>, len = s.length();</span><br><span class="line">    <span class="keyword">while</span> (index &lt; len) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; numRows &amp;&amp; index &lt; len; row++) <span class="comment">// 往下走</span></span><br><span class="line">            sbs[row].append(s.charAt(index++));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = numRows - <span class="number">2</span>; row &gt; <span class="number">0</span> &amp;&amp; index &lt; len; row--) <span class="comment">// 往上走</span></span><br><span class="line">            sbs[row].append(s.charAt(index++));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">1</span>; row &lt; numRows; row++)</span><br><span class="line">        sbs[<span class="number">0</span>].append(sbs[row]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sbs[<span class="number">0</span>].toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;将字符串 “PAYPALISHIRING” 以Z字形排列成给定的行数：&lt;br&gt;&lt;figure class=&quot;highligh
      
    
    </summary>
    
      <category term="LeetCode算法之旅" scheme="https://lierabbit.cn/categories/LeetCode%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>最长回文子串（Longest Palindromic Substring）</title>
    <link href="https://lierabbit.cn/2018/05/08/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
    <id>https://lierabbit.cn/2018/05/08/最长回文子串/</id>
    <published>2018-05-08T07:43:48.000Z</published>
    <updated>2018-09-02T06:27:08.589Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为1000。</p><blockquote><p>示例 1：<br>输入: “babad”<br>输出: “bab”<br>注意: “aba”也是一个有效答案。</p></blockquote><blockquote><p>示例 2：<br>输入: “cbbd”<br>输出: “bb”</p></blockquote><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>首先，我们通过在字母之间插入特殊字符’＃’来将输入字符串S转换为另一个字符串T，这么做的原因很快就会很快清楚。<br>例如：S =“abaaba”，T =“＃a＃b＃a＃a＃b＃a＃”。<br>为了找到最长的回文子串，我们需要在每个T<sub>i</sub>周围扩展，使得T<sub>i-d</sub> … T<sub>i + d</sub>形成回文。你应该马上看到d是以T<sub>i</sub>为中心的回文的长度。<br>我们将中间结果存储在数组P中，其中P[i]等于在T<sub>i</sub>处的回文中心的长度。最长的回文子串将成为P中的最大元素。<br>使用上面的例子，我们填充P如下（从左到右）：</p><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th><th style="text-align:center">9</th><th style="text-align:center">10</th><th style="text-align:center">11</th><th style="text-align:center">12</th></tr></thead><tbody><tr><td style="text-align:center">T</td><td style="text-align:center">#</td><td style="text-align:center">a</td><td style="text-align:center">#</td><td style="text-align:center">b</td><td style="text-align:center">#</td><td style="text-align:center">a</td><td style="text-align:center">#</td><td style="text-align:center">a</td><td style="text-align:center">#</td><td style="text-align:center">b</td><td style="text-align:center">#</td><td style="text-align:center">a</td><td style="text-align:center">#</td></tr><tr><td style="text-align:center">P</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">3</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">6</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">3</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr></tbody></table><p>看着P，我们立即看到最长的回文是“abaaba”，如P<sub>6</sub> = 6所示。<br>您是否注意到在字母之间插入特殊字符（＃），是否优雅地处理了奇数和偶数长度的回文？ （请注意：这是为了更容易地演示这个想法，并不一定需要对算法进行编码。）<br>现在，想象你在回文中心“abaaba”绘制一条想象的垂直线。你有没有注意到P中的数字是围绕这个中心对称的？不仅如此，请尝试使用另一个回文“aba”，这些数字也反映了类似的对称性。这是巧合吗？答案是肯定的，不是。这仅仅是一个条件，但无论如何，我们有很大的进步，因为我们可以消除P[i]的重新计算部分。<br>让我们继续讨论一个稍微复杂的例子，其中有更多的重叠回文，其中S =“babcbabcbaccba”。</p><p><img src="https://blog-1252204470.cos.ap-guangzhou.myqcloud.com/2018/05/08/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/1.jpg" alt=""></p><p>上图显示T由S =“babcbabcbaccba”转化而来。假设你达到了表P部分完成的状态。垂直的实线表示回文“abcbabcba”的中心（C）。两条虚线垂直线分别表示其左（L）和右（R）边缘。您处于索引i处，其围绕C的镜像索引是i’。你如何有效地计算P[i]？<br>假设我们已经到达指数i = 13，并且我们需要计算P[13]（由问号？表示）。我们首先看一下它在回文中心C周围的镜像索引i’，索引i’= 9。</p><p><img src="https://blog-1252204470.cos.ap-guangzhou.myqcloud.com/2018/05/08/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/2.jpg" alt=""></p><p>上面的两条绿色实线表示以i和i’为中心的两个回文序列覆盖的区域。我们看一下C周围的镜像索引i’。P[i’] = P[9] = 1.由于回文在其中心附近具有对称性，因此P[i]必须也是1。<br>正如你在上面看到的那样，P[i] = P[i’] = 1是非常明显的，由于回文中心周围的对称性，这一定是正确的。事实上，C之后的所有三个元素都遵循对称性（即P[12] = P[10] = 0，P[13] = P[9] = 1，P[14] = P[8] = 0）。</p><p><img src="https://blog-1252204470.cos.ap-guangzhou.myqcloud.com/2018/05/08/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/3.jpg" alt=""></p><p>现在我们处于索引i = 15，其C上的镜像索引是i’= 7。P[15] = P[7] = 7？<br>现在我们处于索引i = 15处。P[i]的值是什么？如果我们遵循对称性，P[i]的值应该与P[i’] = 7相同，但这是错误的。如果我们在T<sub>15</sub>围绕中心展开，它形成回文“A·B·C·B·一”，它实际上比它的镜像索引i’更短。 为什么？</p><p><img src="https://blog-1252204470.cos.ap-guangzhou.myqcloud.com/2018/05/08/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/4.jpg" alt=""></p><p>在索引i和i’处围绕中心重叠彩色线。 由于C周围的对称属性，绿色实线显示两侧必须匹配的区域。红色实线表示两侧可能不匹配的区域。 虚线绿线表示穿过中心的区域。<br>很显然，由两条实线表示的区域中的两个子串必须完全匹配。中心区域（用绿色虚线表示）也必须是对称的。注意P[i’]是7，并且它一直扩展到回文的左边缘（L）（用红色实线表示），它不再落在回文的对称属性之下。我们所知道的是P[i] ≥ 5，并且为了找到P[i]的实际值，我们必须通过扩展右边缘（R）来进行字符匹配。在这种情况下，由于P[21]≠P[1]，我们得出结论P[i] = 5。<br>我们总结一下这个算法的关键部分如下：</p><blockquote><p>如果 P[i’] ≤ R - i，<br>则 P[i] = P[i’]<br>否则 P[i] ≥ P[i’]。那么我们必须扩展到右边缘（R）以找到P[i]。</p></blockquote><p>看看它有多优雅？如果你能够充分掌握上述总结，那么你已经获得了这个算法的本质，这也是最难的部分。<br>最后一部分是确定我们应该在何时将C的位置与R一起移动到右侧，这很容易：</p><blockquote><p>如果以i为中心的回文确实扩展到R，我们将C更新为i（这个新回文的中心），并将R延伸到新回文的右边。</p></blockquote><p>在每一步中，都有两种可能性。如果P[i]≤R-i，我们将P[i]设置为P[i’]，这只需要一步。否则，我们试图通过从右边缘R开始将回文中心改为i。扩展R（内部while循环）总共最多需要N个步骤，并且定位和测试每个中心总共需要N步。因此，该算法确保在至多2 * N步完成，给出线性时间解决方案，时间复杂度：O(N)<br><a href="https://articles.leetcode.com/longest-palindromic-substring-part-ii/" target="_blank" rel="noopener">Manacher(马拉车)算法解释原文</a></p><h3 id="实现：真的添加-字符"><a href="#实现：真的添加-字符" class="headerlink" title="实现：真的添加#字符"></a>实现：真的添加#字符</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 改造字符串，每个字符间添加#。添加头^尾$两个不同的字符用于消除边界判断</span></span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">"^"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, len = s.length(); i &lt; len; i++)</span><br><span class="line">        sb.append(<span class="string">"#"</span>).append(s.charAt(i));</span><br><span class="line">    sb.append(<span class="string">"#$"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">0</span>, r = <span class="number">0</span>, len = sb.length(), centerIndex = <span class="number">0</span>, maxLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] p = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> iMirror = <span class="number">2</span> * c - i; <span class="comment">// 相当于 c - (i - c)</span></span><br><span class="line"></span><br><span class="line">        p[i] = r &gt; i ? Math.min(r - i, p[iMirror]) : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 基于当前点为中心扩展寻找回文</span></span><br><span class="line">        <span class="keyword">while</span> (sb.charAt(i - <span class="number">1</span> - p[i]) == sb.charAt(i + <span class="number">1</span> + p[i]))</span><br><span class="line">            p[i]++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果扩展后的右边界值大于当前右边界值则更新</span></span><br><span class="line">        <span class="keyword">if</span> (i + p[i] &gt; r) &#123;</span><br><span class="line">            c = i;</span><br><span class="line">            r = i + p[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 寻找最大值与中心点</span></span><br><span class="line">        <span class="keyword">if</span> (p[i] &gt; maxLen) &#123;</span><br><span class="line">            maxLen = p[i];</span><br><span class="line">            centerIndex = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> beginIndex = (centerIndex - <span class="number">1</span> - maxLen) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s.substring(beginIndex, beginIndex + maxLen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现：不真正添加-字符"><a href="#实现：不真正添加-字符" class="headerlink" title="实现：不真正添加#字符"></a>实现：不真正添加#字符</h3><p>要想不添加#字符，那么只需要模拟添加#字符后的操作<br>例如：<br>原始字符：abcba</p><table><thead><tr><th style="text-align:center">a</th><th style="text-align:center">b</th><th style="text-align:center">c</th><th style="text-align:center">b</th><th style="text-align:center">a</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">4</td></tr></tbody></table><p>添加#字符后</p><table><thead><tr><th style="text-align:center">#</th><th style="text-align:center">a</th><th style="text-align:center">#</th><th style="text-align:center">b</th><th style="text-align:center">#</th><th style="text-align:center">c</th><th style="text-align:center">#</th><th style="text-align:center">b</th><th style="text-align:center">#</th><th style="text-align:center">a</th><th style="text-align:center">#</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">4</td><td style="text-align:center">5</td><td style="text-align:center">6</td><td style="text-align:center">7</td><td style="text-align:center">8</td><td style="text-align:center">9</td><td style="text-align:center">10</td></tr></tbody></table><p>观察添加#字符后的字符串可知，#左边的字符在原始字符串的索引为<code>#的索引/2</code>，#右边的字符在原始字符串的索引为<code>(#的索引-1)/2</code>。<br>例如：<br>索引为4的#，它的左边字符是b，那么b在原始字符串的索引为<code>4-1/2=1</code>，它的右边字符是c，那么c在原始字符串的索引为<code>4/2=2</code>。</p><p>假设当前点为’c’则原始索引i=2，添加#字符后索引为i’=5，要对左右两边进行回文搜索。<br>那么添加#字符后进行回文搜索的过程如下</p><table><thead><tr><th style="text-align:center">左边索引</th><th style="text-align:center">左边索引对应的字符</th><th style="text-align:center">右边索引对应的字符</th><th style="text-align:center">右边索引</th></tr></thead><tbody><tr><td style="text-align:center">4</td><td style="text-align:center">#</td><td style="text-align:center">#</td><td style="text-align:center">6</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">b</td><td style="text-align:center">b</td><td style="text-align:center">7</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">#</td><td style="text-align:center">#</td><td style="text-align:center">8</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">9</td></tr><tr><td style="text-align:center">0</td><td style="text-align:center">#</td><td style="text-align:center">#</td><td style="text-align:center">10</td></tr></tbody></table><p>通过将其还原为对应的字符可实现不真正添加#字符也能运用<a href="#解决方法">上述算法</a></p><table><thead><tr><th style="text-align:center">左边索引</th><th style="text-align:center">左边索引对应的字符</th><th style="text-align:center">右边索引对应的字符</th><th style="text-align:center">右边索引</th></tr></thead><tbody><tr><td style="text-align:center">4/2=2</td><td style="text-align:center">c</td><td style="text-align:center">c</td><td style="text-align:center">（6-1）/2=2</td></tr><tr><td style="text-align:center">3/2=1</td><td style="text-align:center">b</td><td style="text-align:center">b</td><td style="text-align:center">（7-1）/2=3</td></tr><tr><td style="text-align:center">2/2=1</td><td style="text-align:center">b</td><td style="text-align:center">b</td><td style="text-align:center">（8-1）/2=3</td></tr><tr><td style="text-align:center">1/2=0</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">（9-1）/2=4</td></tr><tr><td style="text-align:center">0/2=0</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">（10-1）/2=4</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome2</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加头^尾$两个不同的字符用于消除边界判断</span></span><br><span class="line">    String temp = <span class="string">"^"</span> + s + <span class="string">"$"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">0</span>, r = <span class="number">0</span>, len = s.length() * <span class="number">2</span> + <span class="number">1</span> + <span class="number">2</span>, centerIndex = <span class="number">0</span>, maxLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] p = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> iMirror = <span class="number">2</span> * c - i;</span><br><span class="line"></span><br><span class="line">        p[i] = r &gt; i ? Math.min(r - i, p[iMirror]) : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 基于当前点为中心扩展寻找回文</span></span><br><span class="line">        <span class="keyword">int</span> left = i - <span class="number">1</span> - p[i];</span><br><span class="line">        <span class="keyword">int</span> right = i + <span class="number">1</span> + p[i];</span><br><span class="line">        <span class="keyword">while</span> (temp.charAt(left / <span class="number">2</span>) == temp.charAt((right - <span class="number">1</span>) / <span class="number">2</span>)) &#123;</span><br><span class="line">            p[i]++;</span><br><span class="line">            left--;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果扩展后的右边界值大于当前右边界值则更新</span></span><br><span class="line">        <span class="keyword">if</span> (i + p[i] &gt; r) &#123;</span><br><span class="line">            c = i;</span><br><span class="line">            r = i + p[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 寻找最大值与中心点</span></span><br><span class="line">        <span class="keyword">if</span> (p[i] &gt; maxLen) &#123;</span><br><span class="line">            maxLen = p[i];</span><br><span class="line">            centerIndex = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> beginIndex = (centerIndex - <span class="number">1</span> - maxLen) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s.substring(beginIndex, beginIndex + maxLen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为1000。&lt;/p&gt;
&lt;blockquote&gt;
&lt;
      
    
    </summary>
    
      <category term="LeetCode算法之旅" scheme="https://lierabbit.cn/categories/LeetCode%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>两个排序数组的中位数（Median of Two Sorted Arrays）</title>
    <link href="https://lierabbit.cn/2018/04/30/%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    <id>https://lierabbit.cn/2018/04/30/两个排序数组的中位数/</id>
    <published>2018-04-30T09:01:15.000Z</published>
    <updated>2018-08-29T07:37:13.557Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定两个大小为 m 和 n 的有序数组 nums1 和 nums2 。<br>请找出这两个有序数组的中位数。要求算法的时间复杂度为 O(log (m+n)) 。</p><blockquote><p>示例 1:<br>nums1 = [1, 3]<br>nums2 = [2]<br>中位数是 2.0</p></blockquote><blockquote><p>示例 2:<br>nums1 = [1, 2]<br>nums2 = [3, 4]<br>中位数是 (2 + 3)/2 = 2.5</p></blockquote><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>首先，让我们以一种非常规的方式看到’中位数’的概念。那是：</p><blockquote><p>“ 如果我们将排序后的数组切割成等于两半的等长，则平均数为最大值（lower_half）和最小值（upper_half）的平均值，即紧靠切割的两个数字 ”。</p></blockquote><p>例如，对于[2 3 5 7]，我们在3和5之间进行切割：</p><blockquote><p>[2 3 / 5 7]</p></blockquote><p>那么中位数=（3 + 5）/ 2。请注意，在本文中，我将使用’/‘来表示切割和（数字/数字）来表示通过数字进行的切割。<br>对于[2 3 4 5 6]，我们将4切割：</p><blockquote><p>[2 3（4/4）5 7]</p></blockquote><p>由于我们把4分成两半，所以我们说现在子单元的下部和上部都包含4。这个概念也导致了正确的答案：（4 + 4）/ 2 = 4。为了方便起见，我们使用L来表示切割的左边对应的数字，R表示切割的右边对应的数字。例如[2 3 5 7]，我们分别有L = 3和R = 5。我们观察到L和R的索引与数组N的长度有下列关系：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">N      Index of L / R</span><br><span class="line">1               0 / 0</span><br><span class="line">2               0 / 1</span><br><span class="line">3               1 / 1  </span><br><span class="line">4               1 / 2      </span><br><span class="line">5               2 / 2</span><br><span class="line">6               2 / 3</span><br><span class="line">7               3 / 3</span><br><span class="line">8               3 / 4</span><br></pre></td></tr></table></figure></p><p>不难断定L =（N-1）/ 2的指数，并且R = N / 2。因此，中位数可以表示为</p><blockquote><p>(L + R)/2 = (A[(N-1)/2] + A[N/2])/2</p></blockquote><p>为了准备好两个数组的情况，我们在数字之间添加一些想象的“位置”（表示为＃），并将数字视为“位置”。</p><blockquote><p>[6 9 13 18]  -&gt;   [# 6 # 9 # 13 # 18 #]    (N = 4)<br>position index     0 1 2 3 4 5  6 7  8     (N_Position = 9)</p><p>[6 9 11 13 18]-&gt;   [# 6 # 9 # 11 # 13 # 18 #]   (N = 5)<br>position index      0 1 2 3 4 5  6 7  8 9 10    (N_Position = 11)</p></blockquote><p>正如你所看到的，不管长度为N，总有正好2 * N + 1的位置。因此，中间切割应该总是在第N个位置（基于0的位置）进行。在这种情况下，由于index(L)=(N-1)/2和index(R)=N/2，我们可以推断</p><blockquote><p>index(L) = (CutPosition-1)/2, index(R) = (CutPosition)/2</p></blockquote><hr><p>现在对于两个数组的情况：</p><blockquote><p>A1: [# 1 # 2 # 3 # 4 # 5 #]    (N1 = 5, N1_positions = 11)<br>A2: [# 1 # 1 # 1 # 1 #]     (N2 = 4, N2_positions = 9)</p></blockquote><p>类似于单数组问题，我们需要找到一个将两个数组分成两半的切割</p><blockquote><p>“左半部分的任何数字”&lt;=“右半部分的任何数字”。</p></blockquote><p>我们也可以提出以下意见：</p><ol><li>共有2个N1 + 2个 N2 + 2个位置。因此，在切割的每一边必须有N1 + N2的位置，并且直接在切割处有2个位置。</li><li><p>因此，当我们在A2中的位置C2 = K处切割时，A1中的切割位置必须是C1 = N1 + N2-k。例如，如果C2 = 2，那么我们必须有C1 = 4 + 5 - C2 = 7。</p><blockquote><p>[# 1 # 2 # 3 # (4/4) # 5 #]<br>[# 1 / 1 # 1 # 1 #]</p></blockquote></li><li><p>切割完成后，我们会有两个L和两个R。他们是</p><blockquote><p>L1 = A1[(C1-1)/2]; R1 = A1[C1/2];<br>L2 = A2[(C2-1)/2]; R2 = A2[C2/2];</p></blockquote></li></ol><p>在上面的例子中，</p><blockquote><p>L1 = A1[(7-1)/2] = A1[3] = 4; R1 = A1[7/2] = A1[3] = 4;<br>L2 = A2[(2-1)/2] = A2[0] = 1; R2 = A1[2/2] = A1<a href="https://leetcode.com/problems/median-of-two-sorted-arrays/discuss/2471/Very-concise-O(log(min(MN)))-iterative-solution-with-detailed-explanation" target="_blank" rel="noopener">1</a> = 1;</p></blockquote><p>现在我们该如何决定这个切割是否是我们想要的切割？因为L1，L2是左边最大的数字，而R1，R2是右边最小的数字，所以我们只需要</p><blockquote><p>L1 &lt;= R1 &amp;&amp; L1 &lt;= R2 &amp;&amp; L2 &lt;= R1 &amp;&amp; L2 &lt;= R2</p></blockquote><p>确保下半部分的任何数字&lt;=上半部分的任何数字。事实上，因为L1 &lt;= R1和L2 &lt;= R2是自然保证的，因为A1和A2是分类的，我们只需要确保：</p><blockquote><p>L1 &lt;= R2且L2 &lt;= R1。</p></blockquote><p>现在我们可以使用简单的二分查找来找出结果。</p><blockquote><p>如果我们有L1&gt; R2，这意味着在A1的左半部分有太多的大数字，那么我们必须将C1向左移动（即向右移动C2）。<br>如果L2&gt; R1，那么A2的左半部分有太多的大数字，我们必须将C2移到左边。<br>否则，这一切是正确的。<br>在我们找到切割后，可以得出结果为（max（L1，L2）+ min（R1，R2））/ 2;</p></blockquote><p>注意：</p><ul><li><p>由于C1和C2可以相互确定，我们可以先移动其中一个，然后相应地计算另一个。但是，首先将C2（较短数组上的一个）移动更为实用。原因是，在较短的数组上，所有位置都可能是中位数的切割位置，但在较长的数组上，左右位置过于靠后的位置对于合法切割根本不可能。例如，[1]，[2 3 4 5 6 7 8]。很显然，2和3之间的切割是不可能的，因为如果你用这种方式进行切割，较短的数组没有那么多元素来平衡[3 4 5 6 7 8]部分。因此，要将较长的数组用作第一次切割的基础，必须执行范围检查。在较短的数组上执行操作会更容易，也无需进行任何检查。</p></li><li><p>唯一的边缘情况是当切割落在第0(第一个)或第2N （最后一个）位置时。例如，如果C2 = 2N2，则R2 = A2 [2 * N2 / 2] = A2 [N2]，其超出数组的边界。为了解决这个问题，我们可以想象，A1和A2实际上有两个额外的元素，INT_MAX在A [-1]和INT_MAX在A [N]。这些添加不会改变结果，但会使实现更容易：如果任何L落在数组的左边界之外，则L = INT_MIN，并且如果有任何R落在右边界之外，则R = INT_MAX。</p></li></ul><hr><p>我知道这不是很容易理解，但所有上述推理最终归结为以下简洁的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n1 = nums1.length;</span><br><span class="line">    <span class="keyword">int</span> n2 = nums2.length;</span><br><span class="line">    <span class="keyword">if</span> (n1 &lt; n2)</span><br><span class="line">        <span class="keyword">return</span> findMedianSortedArrays(nums2, nums1); <span class="comment">// 确保nums2为短数组</span></span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>, hi = n2 * <span class="number">2</span>; <span class="comment">//</span></span><br><span class="line">    <span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">        <span class="keyword">int</span> c2 = (lo + hi) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> c1 = n1 + n2 - c2;</span><br><span class="line">        <span class="keyword">double</span> L1 = (c1 == <span class="number">0</span>) ? Integer.MIN_VALUE : nums1[(c1 - <span class="number">1</span>) / <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">double</span> L2 = (c2 == <span class="number">0</span>) ? Integer.MIN_VALUE : nums2[(c2 - <span class="number">1</span>) / <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">double</span> R1 = (c1 == n1 * <span class="number">2</span>) ? Integer.MAX_VALUE : nums1[c1 / <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">double</span> R2 = (c2 == n2 * <span class="number">2</span>) ? Integer.MAX_VALUE : nums2[c2 / <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (L1 &gt; R2)</span><br><span class="line">            lo = c2 + <span class="number">1</span>; <span class="comment">// 增大c2，减小c1，向右移动c2</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (L2 &gt; R1)</span><br><span class="line">            hi = c2 - <span class="number">1</span>; <span class="comment">// 减小c2，增大c1，向左移动c2</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> (Math.max(L1, L2) + Math.min(R1, R2)) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(log(min(M,N)))</p><p><a href="https://leetcode.com/problems/median-of-two-sorted-arrays/discuss/2471/Very-concise-O(log(min(MN)))-iterative-solution-with-detailed-explanation" target="_blank" rel="noopener">算法解释原文</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定两个大小为 m 和 n 的有序数组 nums1 和 nums2 。&lt;br&gt;请找出这两个有序数组的中位数。要求算法的时间复
      
    
    </summary>
    
      <category term="LeetCode算法之旅" scheme="https://lierabbit.cn/categories/LeetCode%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
