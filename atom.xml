<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>谎话兔博客</title>
  
  <subtitle>LieRabbit</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://lierabbit.cn/"/>
  <updated>2018-08-24T08:51:28.356Z</updated>
  <id>https://lierabbit.cn/</id>
  
  <author>
    <name>谎话兔</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数组变树</title>
    <link href="https://lierabbit.cn/2018/02/18/%E6%95%B0%E7%BB%84%E5%8F%98%E6%A0%91/"/>
    <id>https://lierabbit.cn/2018/02/18/数组变树/</id>
    <published>2018-02-18T15:43:34.000Z</published>
    <updated>2018-08-24T08:51:28.356Z</updated>
    
    <content type="html"><![CDATA[<p>对于一个没有重复元素的整数数组，请用其中元素构造一棵MaxTree，MaxTree定义为一棵二叉树，其中的节点与数组元素一一对应，同时对于MaxTree的每棵子树，它的根的元素值为子树的最大值。现有一建树方法，对于数组中的每个元素，其在树中的父亲为数组中它左边比它大的第一个数和右边比它大的第一个数中更小的一个。若两边都不存在比它大的数，那么它就是树根。请设计O(n)的算法实现这个方法。<br>给定一个无重复元素的数组A和它的大小n，请返回一个数组，其中每个元素为原数组中对应位置元素在树中的父亲节点的编号，若为根则值为-1。<br>测试样例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[3,1,4,2],4</span><br><span class="line">返回：[2,0,-1,2]</span><br></pre></td></tr></table></figure><p>思路：第一次遍历数组找到左边第一个比当前数大的下标，第二次遍历数组找到右边第一个比当前数大的下标，并和左边第一个比当前数大的数比较，取较小的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] buildMaxTree(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到左边第一个比当前数大的下标</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!stack.empty() &amp;&amp; arr[stack.peek()] &lt; arr[i])</span><br><span class="line">            stack.pop();</span><br><span class="line">        <span class="keyword">if</span> (stack.empty())</span><br><span class="line">            res[i] = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            res[i] = stack.peek();</span><br><span class="line">        stack.push(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stack.clear();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到右边第一个比当前数大的下标，并和左边第一个比当前数大的数比较，取较小的</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!stack.empty() &amp;&amp; arr[stack.peek()] &lt; arr[i])</span><br><span class="line">            stack.pop();</span><br><span class="line">        <span class="keyword">if</span> (!stack.empty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(res[i] == -<span class="number">1</span>)</span><br><span class="line">                res[i] = stack.peek();</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                res[i] = arr[stack.peek()] &lt; arr[res[i]] ? stack.peek() : res[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stack.push(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对于一个没有重复元素的整数数组，请用其中元素构造一棵MaxTree，MaxTree定义为一棵二叉树，其中的节点与数组元素一一对应，同时对于MaxTree的每棵子树，它的根的元素值为子树的最大值。现有一建树方法，对于数组中的每个元素，其在树中的父亲为数组中它左边比它大的第一个
      
    
    </summary>
    
      <category term="直通BAT面试算法" scheme="https://lierabbit.cn/categories/%E7%9B%B4%E9%80%9ABAT%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>滑动窗口</title>
    <link href="https://lierabbit.cn/2018/02/18/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    <id>https://lierabbit.cn/2018/02/18/滑动窗口/</id>
    <published>2018-02-18T15:04:52.000Z</published>
    <updated>2018-08-24T08:47:41.250Z</updated>
    
    <content type="html"><![CDATA[<p>有一个整型数组 arr 和一个大小为 w 的窗口从数组的最左边滑到最右边,窗口每次向右边滑一个位置。 返回一个长度为n-w+1的数组res，res[i]表示每一种窗口状态下的最大值。 以数组为[4,3,5,4,3,3,6,7]，w=3为例。因为第一个窗口[4,3,5]的最大值为5，第二个窗口[3,5,4]的最大值为5，第三个窗口[5,4,3]的最大值为5。第四个窗口[4,3,3]的最大值为4。第五个窗口[3,3,6]的最大值为6。第六个窗口[3,6,7]的最大值为7。所以最终返回[5,5,5,4,6,7]。<br>给定整形数组arr及它的大小n，同时给定w，请返回res数组。保证w小于等于n，同时保证数组大小小于等于500。<br>测试样例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[4,3,5,4,3,3,6,7],8,3</span><br><span class="line">返回：[5,5,5,4,6,7]</span><br></pre></td></tr></table></figure><p>思路：使用双端队列记录访问到的最大值，判断该值是否还在窗口内</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] slide(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> n, <span class="keyword">int</span> w) &#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">int</span> result[] = <span class="keyword">new</span> <span class="keyword">int</span>[n - w + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> resultSize = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 从大到小的队列</span></span><br><span class="line">    Deque&lt;Integer&gt; qMax = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!qMax.isEmpty() &amp;&amp; arr[i] &gt;= arr[qMax.peekLast()])</span><br><span class="line">            qMax.pollLast();</span><br><span class="line">        qMax.add(i);</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= w - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 判断最大值是否在窗口内</span></span><br><span class="line">            <span class="keyword">if</span> (qMax.peekFirst() == i - w)</span><br><span class="line">                qMax.pollFirst();</span><br><span class="line">            result[resultSize++] = arr[qMax.peekFirst()];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有一个整型数组 arr 和一个大小为 w 的窗口从数组的最左边滑到最右边,窗口每次向右边滑一个位置。 返回一个长度为n-w+1的数组res，res[i]表示每一种窗口状态下的最大值。 以数组为[4,3,5,4,3,3,6,7]，w=3为例。因为第一个窗口[4,3,5]的最大
      
    
    </summary>
    
      <category term="直通BAT面试算法" scheme="https://lierabbit.cn/categories/%E7%9B%B4%E9%80%9ABAT%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>双栈排序</title>
    <link href="https://lierabbit.cn/2018/02/18/%E5%8F%8C%E6%A0%88%E6%8E%92%E5%BA%8F/"/>
    <id>https://lierabbit.cn/2018/02/18/双栈排序/</id>
    <published>2018-02-18T13:42:41.000Z</published>
    <updated>2018-08-24T08:42:39.080Z</updated>
    
    <content type="html"><![CDATA[<p>请编写一个程序，按升序对栈进行排序（即最大元素位于栈顶），要求最多只能使用一个额外的栈存放临时数据，但不得将元素复制到别的数据结构中。<br>给定一个int[] numbers(C++中为vector&amp;ltint&gt;)，其中第一个元素为栈顶，请返回排序后的栈。请注意这是一个栈，意味着排序过程中你只能访问到第一个元素。<br>测试样例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1,2,3,4,5]</span><br><span class="line">返回：[5,4,3,2,1]</span><br></pre></td></tr></table></figure><p>思路：用一个排序栈help，大于等于help栈顶则压入，小于则help弹出栈顶，继续比较，直到找到插入的位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">twoStacksSort</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    Stack&lt;Integer&gt; data = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; help = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = numbers.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        data.push(numbers[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!data.empty()) &#123;</span><br><span class="line">        Integer value = data.pop();</span><br><span class="line">        <span class="keyword">if</span> (help.empty())</span><br><span class="line">            help.push(value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (value &lt;= help.peek())</span><br><span class="line">                help.push(value);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> popNumber = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (!help.empty()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (value &gt; help.peek()) &#123;</span><br><span class="line">                        data.push(help.pop());</span><br><span class="line">                        popNumber++;</span><br><span class="line">                    &#125; <span class="keyword">else</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                help.push(value);</span><br><span class="line">                <span class="keyword">while</span> (popNumber != <span class="number">0</span>) &#123;</span><br><span class="line">                    help.push(data.pop());</span><br><span class="line">                    popNumber--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!help.empty()) &#123;</span><br><span class="line">        data.push(help.pop());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (!data.empty()) &#123;</span><br><span class="line">        list.add(data.pop());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;请编写一个程序，按升序对栈进行排序（即最大元素位于栈顶），要求最多只能使用一个额外的栈存放临时数据，但不得将元素复制到别的数据结构中。&lt;br&gt;给定一个int[] numbers(C++中为vector&amp;amp;ltint&amp;gt;)，其中第一个元素为栈顶，请返回排序后的栈。请
      
    
    </summary>
    
      <category term="直通BAT面试算法" scheme="https://lierabbit.cn/categories/%E7%9B%B4%E9%80%9ABAT%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>栈的反转</title>
    <link href="https://lierabbit.cn/2018/02/18/%E6%A0%88%E7%9A%84%E5%8F%8D%E8%BD%AC/"/>
    <id>https://lierabbit.cn/2018/02/18/栈的反转/</id>
    <published>2018-02-18T11:32:33.000Z</published>
    <updated>2018-08-24T08:37:53.261Z</updated>
    
    <content type="html"><![CDATA[<p>实现一个栈的逆序，但是只能用递归函数和这个栈本身的pop操作来实现，而不能自己申请另外的数据结构。<br>给定一个整数数组A即为给定的栈，同时给定它的大小n，请返回逆序后的栈。<br>测试样例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[4,3,2,1],4</span><br><span class="line">返回：[1,2,3,4]</span><br></pre></td></tr></table></figure><p>思路：利用递归获取栈底，弹出-&gt;弹出-&gt;弹出（栈底）-&gt;返回栈底-&gt;返回栈底-&gt;返回栈底，<br>栈底-&gt;栈底-&gt;栈底（最后一个）-&gt;压入栈底-&gt;压入栈底-&gt;压入栈底</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackReverse</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reverseStack(<span class="keyword">int</span>[] A, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            stack.add(A[i]);</span><br><span class="line"></span><br><span class="line">        reverse();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!stack.empty())</span><br><span class="line">            A[index++] = stack.pop();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反转栈</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stack.empty())</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> i = getBottom();</span><br><span class="line">        reverse();</span><br><span class="line">        stack.push(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到栈底元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getBottom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = stack.pop();</span><br><span class="line">        <span class="keyword">if</span> (stack.empty())</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> last = getBottom();</span><br><span class="line">            stack.push(result);</span><br><span class="line">            <span class="keyword">return</span> last;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;实现一个栈的逆序，但是只能用递归函数和这个栈本身的pop操作来实现，而不能自己申请另外的数据结构。&lt;br&gt;给定一个整数数组A即为给定的栈，同时给定它的大小n，请返回逆序后的栈。&lt;br&gt;测试样例：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;ta
      
    
    </summary>
    
      <category term="直通BAT面试算法" scheme="https://lierabbit.cn/categories/%E7%9B%B4%E9%80%9ABAT%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>双栈队列</title>
    <link href="https://lierabbit.cn/2018/02/18/%E5%8F%8C%E6%A0%88%E9%98%9F%E5%88%97/"/>
    <id>https://lierabbit.cn/2018/02/18/双栈队列/</id>
    <published>2018-02-18T11:24:16.000Z</published>
    <updated>2018-08-24T08:33:04.299Z</updated>
    
    <content type="html"><![CDATA[<p>编写一个类,只能用两个栈结构实现队列,支持队列的基本操作(push，pop)。<br>给定一个操作序列ope及它的长度n，其中元素为正数代表push操作，为0代表pop操作，保证操作序列合法且一定含pop操作，请返回pop的结果序列。<br>测试样例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1,2,3,0,4,0],6</span><br><span class="line">返回：[1,2]</span><br></pre></td></tr></table></figure><p>思路：一个栈用来压入，一个栈用来弹出，先压入到压入栈，然后再全部弹出压入弹出栈即可模拟队列，<br>注意：<br>当弹出栈不空时不能压入弹出栈<br>必须一次性将压入栈倒出到弹出栈</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; pushStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; popStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoStack(<span class="keyword">int</span>[] ope, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a : ope) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a != <span class="number">0</span>)</span><br><span class="line">                add(a);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                list.add(pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[list.size()];</span><br><span class="line">        <span class="keyword">int</span> resultLen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> a:list)</span><br><span class="line">            result[resultLen++] = a;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!popStack.empty()) &#123;</span><br><span class="line">            pushStack.add(popStack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        pushStack.add(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!pushStack.empty()) &#123;</span><br><span class="line">            popStack.add(pushStack.pop());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> popStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;编写一个类,只能用两个栈结构实现队列,支持队列的基本操作(push，pop)。&lt;br&gt;给定一个操作序列ope及它的长度n，其中元素为正数代表push操作，为0代表pop操作，保证操作序列合法且一定含pop操作，请返回pop的结果序列。&lt;br&gt;测试样例：&lt;/p&gt;
&lt;figur
      
    
    </summary>
    
      <category term="直通BAT面试算法" scheme="https://lierabbit.cn/categories/%E7%9B%B4%E9%80%9ABAT%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>可查询最值的栈</title>
    <link href="https://lierabbit.cn/2018/02/18/%E5%8F%AF%E6%9F%A5%E8%AF%A2%E6%9C%80%E5%80%BC%E7%9A%84%E6%A0%88/"/>
    <id>https://lierabbit.cn/2018/02/18/可查询最值的栈/</id>
    <published>2018-02-18T11:13:06.000Z</published>
    <updated>2018-08-24T08:30:49.577Z</updated>
    
    <content type="html"><![CDATA[<p>定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的min函数。</p><p>思路：使用2个栈stack和minStack，stack压入所有元素，minStack只压入最小值，弹出元素的时候，stack正常弹出，minStack只有栈顶元素==stack弹出的元素才弹出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stack;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; minStack;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        minStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        stack.add(value);</span><br><span class="line">        <span class="keyword">if</span> (minStack.empty())</span><br><span class="line">            minStack.push(value);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (minStack.peek() &gt;= value)</span><br><span class="line">            minStack.push(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Integer value = stack.pop();</span><br><span class="line">        <span class="keyword">if</span> (value == minStack.peek())</span><br><span class="line">            minStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的min函数。&lt;/p&gt;
&lt;p&gt;思路：使用2个栈stack和minStack，stack压入所有元素，minStack只压入最小值，弹出元素的时候，stack正常弹出，minStack只有栈顶元素==stack弹出的元素
      
    
    </summary>
    
      <category term="直通BAT面试算法" scheme="https://lierabbit.cn/categories/%E7%9B%B4%E9%80%9ABAT%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>最长无重复字符字串</title>
    <link href="https://lierabbit.cn/2018/02/18/%E6%9C%80%E9%95%BF%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E5%AD%97%E4%B8%B2/"/>
    <id>https://lierabbit.cn/2018/02/18/最长无重复字符字串/</id>
    <published>2018-02-18T10:55:23.000Z</published>
    <updated>2018-08-24T08:19:54.321Z</updated>
    
    <content type="html"><![CDATA[<p>对于一个字符串,请设计一个高效算法，找到字符串的最长无重复字符的子串长度。<br>给定一个字符串A及它的长度n，请返回它的最长无重复字符子串长度。保证A中字符全部为小写英文字符，且长度小于等于500。<br>测试样例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;aabcb&quot;,5</span><br><span class="line">返回：3</span><br></pre></td></tr></table></figure><p>思路：使用数组模拟HashMap记录字符上次出现的位置，用pre记录最近重复字符出现最近的位置，则i(当前位置)-pre就是当前字符最长无重复字符的长度，取最大的就是字符串的最长无重复字符的长度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestSubstring</span><span class="params">(String A, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A == <span class="keyword">null</span> || n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)</span><br><span class="line">        map[i] = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>[] chars = A.toCharArray();</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> pre = -<span class="number">1</span>;<span class="comment">//之前出现的地方</span></span><br><span class="line">    <span class="keyword">int</span> cur;<span class="comment">//当前最长无重复字符子串长度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">        pre = Math.max(pre, map[chars[i]]);</span><br><span class="line">        cur = i - pre;</span><br><span class="line">        len = Math.max(len, cur);</span><br><span class="line">        map[chars[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对于一个字符串,请设计一个高效算法，找到字符串的最长无重复字符的子串长度。&lt;br&gt;给定一个字符串A及它的长度n，请返回它的最长无重复字符子串长度。保证A中字符全部为小写英文字符，且长度小于等于500。&lt;br&gt;测试样例：&lt;/p&gt;
&lt;figure class=&quot;highligh
      
    
    </summary>
    
      <category term="直通BAT面试算法" scheme="https://lierabbit.cn/categories/%E7%9B%B4%E9%80%9ABAT%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>合法括号序列判断</title>
    <link href="https://lierabbit.cn/2018/02/18/%E5%90%88%E6%B3%95%E6%8B%AC%E5%8F%B7%E5%BA%8F%E5%88%97%E5%88%A4%E6%96%AD/"/>
    <id>https://lierabbit.cn/2018/02/18/合法括号序列判断/</id>
    <published>2018-02-18T10:37:20.000Z</published>
    <updated>2018-08-24T08:17:16.089Z</updated>
    
    <content type="html"><![CDATA[<p>对于一个字符串，请设计一个算法，判断其是否为一个合法的括号串。<br>给定一个字符串A和它的长度n，请返回一个bool值代表它是否为一个合法的括号串。<br>测试样例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&quot;(()())&quot;,6</span><br><span class="line">返回：true</span><br><span class="line">测试样例：</span><br><span class="line"></span><br><span class="line">&quot;()a()()&quot;,7</span><br><span class="line">返回：false</span><br><span class="line">测试样例：</span><br><span class="line"></span><br><span class="line">&quot;()(()()&quot;,7</span><br><span class="line">返回：false</span><br></pre></td></tr></table></figure><p>思路：用num记录括号出现次数，出现’(‘则+1，出现’)’则-1，若num&lt;0说明’)’出现过多，若遍历完整个数组num不为0说明’(‘过多</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">chkParenthesis</span><span class="params">(String A, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>[] chars = A.toCharArray();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> ch : chars) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">'('</span>)</span><br><span class="line">            num++;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">')'</span>)</span><br><span class="line">            num--;</span><br><span class="line">        <span class="keyword">if</span> (num &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> num == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对于一个字符串，请设计一个算法，判断其是否为一个合法的括号串。&lt;br&gt;给定一个字符串A和它的长度n，请返回一个bool值代表它是否为一个合法的括号串。&lt;br&gt;测试样例：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td c
      
    
    </summary>
    
      <category term="直通BAT面试算法" scheme="https://lierabbit.cn/categories/%E7%9B%B4%E9%80%9ABAT%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>空格替换</title>
    <link href="https://lierabbit.cn/2018/02/18/%E7%A9%BA%E6%A0%BC%E6%9B%BF%E6%8D%A2/"/>
    <id>https://lierabbit.cn/2018/02/18/空格替换/</id>
    <published>2018-02-18T10:28:12.000Z</published>
    <updated>2018-08-24T08:14:45.950Z</updated>
    
    <content type="html"><![CDATA[<p>请编写一个方法，将字符串中的空格全部替换为“%20”。假定该字符串有足够的空间存放新增的字符，并且知道字符串的真实长度(小于等于1000)，同时保证字符串由大小写的英文字母组成。<br>给定一个string iniString 为原始的串，以及串的长度 int len, 返回替换后的string。<br>测试样例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;Mr John Smith”,13</span><br><span class="line">返回：&quot;Mr%20John%20Smith&quot;</span><br><span class="line">”Hello  World”,12</span><br><span class="line">返回：”Hello%20%20World”</span><br></pre></td></tr></table></figure><h2 id="使用replaceAll"><a href="#使用replaceAll" class="headerlink" title="使用replaceAll"></a>使用replaceAll</h2><p>iniString.replaceAll(“ “,”%20”)</p><h2 id="手动实现"><a href="#手动实现" class="headerlink" title="手动实现"></a>手动实现</h2><p>思路：记录空格出现次数，新数组长度等于原数组长度+空格数*2，遍历原数组按规则放入新数组即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(String iniString, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">if</span> (iniString == <span class="keyword">null</span> || iniString.length() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> iniString;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>[] chars = iniString.toCharArray();</span><br><span class="line">    <span class="keyword">int</span> space = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> ch : chars)</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">' '</span>)</span><br><span class="line">            space++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> resultLen = length + space * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">char</span>[] result = <span class="keyword">new</span> <span class="keyword">char</span>[resultLen];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (chars[i] == <span class="string">' '</span>) &#123;</span><br><span class="line">            result[--resultLen] = <span class="string">'0'</span>;</span><br><span class="line">            result[--resultLen] = <span class="string">'2'</span>;</span><br><span class="line">            result[--resultLen] = <span class="string">'%'</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            result[--resultLen] = chars[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> String.valueOf(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;请编写一个方法，将字符串中的空格全部替换为“%20”。假定该字符串有足够的空间存放新增的字符，并且知道字符串的真实长度(小于等于1000)，同时保证字符串由大小写的英文字母组成。&lt;br&gt;给定一个string iniString 为原始的串，以及串的长度 int len, 返
      
    
    </summary>
    
      <category term="直通BAT面试算法" scheme="https://lierabbit.cn/categories/%E7%9B%B4%E9%80%9ABAT%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>拼接最小字典序</title>
    <link href="https://lierabbit.cn/2018/02/18/%E6%8B%BC%E6%8E%A5%E6%9C%80%E5%B0%8F%E5%AD%97%E5%85%B8%E5%BA%8F/"/>
    <id>https://lierabbit.cn/2018/02/18/拼接最小字典序/</id>
    <published>2018-02-18T10:15:44.000Z</published>
    <updated>2018-08-24T08:11:27.769Z</updated>
    
    <content type="html"><![CDATA[<p>对于一个给定的字符串数组，请找到一种拼接顺序，使所有小字符串拼接成的大字符串是所有可能的拼接中字典序最小的。<br>给定一个字符串数组strs，同时给定它的大小，请返回拼接成的串。<br>测试样例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[&quot;abc&quot;,&quot;de&quot;],2</span><br><span class="line">&quot;abcde&quot;</span><br></pre></td></tr></table></figure><p>思路：将字符串数组排序，然后按序拼接。有字符串a和b，若a+b&lt;b+a，则a在前b在后。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">findSmallest</span><span class="params">(String[] strs, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">if</span> (strs == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (strs.length == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    Arrays.sort(strs, (a, b) -&gt; (a + b).compareTo(b + a));</span><br><span class="line">    StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (String str : strs)</span><br><span class="line">        result.append(str);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对于一个给定的字符串数组，请找到一种拼接顺序，使所有小字符串拼接成的大字符串是所有可能的拼接中字典序最小的。&lt;br&gt;给定一个字符串数组strs，同时给定它的大小，请返回拼接成的串。&lt;br&gt;测试样例：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="直通BAT面试算法" scheme="https://lierabbit.cn/categories/%E7%9B%B4%E9%80%9ABAT%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>字符串位移</title>
    <link href="https://lierabbit.cn/2018/02/18/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BD%8D%E7%A7%BB/"/>
    <id>https://lierabbit.cn/2018/02/18/字符串位移/</id>
    <published>2018-02-18T10:12:02.000Z</published>
    <updated>2018-08-24T08:00:41.927Z</updated>
    
    <content type="html"><![CDATA[<p>对于一个字符串，请设计一个算法，将字符串的长度为len的前缀平移到字符串的最后。<br>给定一个字符串A和它的长度，同时给定len，请返回平移后的字符串。<br>测试样例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;ABCDE&quot;,5,3</span><br><span class="line">返回：&quot;DEABC&quot;</span><br></pre></td></tr></table></figure><p>思路：首先将长度为len的字符逆序，再把len之后的字符逆序，最后把整个字符串逆序即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">stringTranslation</span><span class="params">(String A, <span class="keyword">int</span> n, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">char</span>[] chars = A.toCharArray();</span><br><span class="line"></span><br><span class="line">    reverse(chars, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">    reverse(chars, len, n - <span class="number">1</span>);</span><br><span class="line">    reverse(chars, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> String.valueOf(chars);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">char</span>[] chars, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">        swap(chars, start, end);</span><br><span class="line">        start++;</span><br><span class="line">        end--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span>[] chars, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> temp = chars[i];</span><br><span class="line">    chars[i] = chars[j];</span><br><span class="line">    chars[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对于一个字符串，请设计一个算法，将字符串的长度为len的前缀平移到字符串的最后。&lt;br&gt;给定一个字符串A和它的长度，同时给定len，请返回平移后的字符串。&lt;br&gt;测试样例：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td
      
    
    </summary>
    
      <category term="直通BAT面试算法" scheme="https://lierabbit.cn/categories/%E7%9B%B4%E9%80%9ABAT%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>句子的逆序</title>
    <link href="https://lierabbit.cn/2018/02/18/%E5%8F%A5%E5%AD%90%E7%9A%84%E9%80%86%E5%BA%8F/"/>
    <id>https://lierabbit.cn/2018/02/18/句子的逆序/</id>
    <published>2018-02-18T10:04:17.000Z</published>
    <updated>2018-08-24T07:56:00.011Z</updated>
    
    <content type="html"><![CDATA[<p>对于一个字符串，请设计一个算法，只在字符串的单词间做逆序调整，也就是说，字符串由一些由空格分隔的部分组成，你需要将这些部分逆序。<br>给定一个原字符串A和他的长度，请返回逆序后的字符串。<br>测试样例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;dog loves pig&quot;,13</span><br><span class="line">返回：&quot;pig loves dog&quot;</span><br></pre></td></tr></table></figure><p>思路：首先反转整个字符串，接着一个一个的反转局部单词即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">reverseSentence</span><span class="params">(String A, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">char</span>[] chars = A.toCharArray();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反转整个字符串</span></span><br><span class="line">    reverse(chars, <span class="number">0</span>, chars.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> l = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> r = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (chars[i] != <span class="string">' '</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || chars[i - <span class="number">1</span>] == <span class="string">' '</span>)  <span class="comment">// 寻找需要局部反转的单词的起始下标</span></span><br><span class="line">                l = i;</span><br><span class="line">            <span class="keyword">if</span> (i == chars.length - <span class="number">1</span> || chars[i + <span class="number">1</span>] == <span class="string">' '</span>)  <span class="comment">// 寻找需要局部反转的单词的末尾下标</span></span><br><span class="line">                r = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l != -<span class="number">1</span> &amp;&amp; r != -<span class="number">1</span>) &#123;</span><br><span class="line">            reverse(chars, l, r);</span><br><span class="line">            l = -<span class="number">1</span>;</span><br><span class="line">            r = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> String.valueOf(chars);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反转字符串</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">char</span>[] chars, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">        swap(chars, start, end);</span><br><span class="line">        start++;</span><br><span class="line">        end--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span>[] chars, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> temp = chars[i];</span><br><span class="line">    chars[i] = chars[j];</span><br><span class="line">    chars[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对于一个字符串，请设计一个算法，只在字符串的单词间做逆序调整，也就是说，字符串由一些由空格分隔的部分组成，你需要将这些部分逆序。&lt;br&gt;给定一个原字符串A和他的长度，请返回逆序后的字符串。&lt;br&gt;测试样例：&lt;/p&gt;
&lt;figure class=&quot;highlight plai
      
    
    </summary>
    
      <category term="直通BAT面试算法" scheme="https://lierabbit.cn/categories/%E7%9B%B4%E9%80%9ABAT%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>两串旋转</title>
    <link href="https://lierabbit.cn/2018/02/18/%E4%B8%A4%E4%B8%B2%E6%97%8B%E8%BD%AC/"/>
    <id>https://lierabbit.cn/2018/02/18/两串旋转/</id>
    <published>2018-02-18T09:53:37.000Z</published>
    <updated>2018-08-24T07:54:19.640Z</updated>
    
    <content type="html"><![CDATA[<p>如果对于一个字符串A，将A的前面任意一部分挪到后边去形成的字符串称为A的旋转词。比如A=”12345”,A的旋转词有”12345”,”23451”,”34512”,”45123”和”51234”。对于两个字符串A和B，请判断A和B是否互为旋转词。<br>给定两个字符串A和B及他们的长度lena，lenb，请返回一个bool值，代表他们是否互为旋转词。<br>测试样例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;cdab&quot;,4,&quot;abcd&quot;,4</span><br><span class="line">返回：true</span><br></pre></td></tr></table></figure></p><p>思路：如果A，B互为旋转词，则A+A必定包含B<br>例如A=”abcd”，B=”cdab”，则A+A=”abcdabcd”，里面有”abcd”，”bcda”，”cdab”，”dabc”枚举了所有的旋转词</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">chkRotation</span><span class="params">(String A, <span class="keyword">int</span> lena, String B, <span class="keyword">int</span> lenb)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">if</span> (lena == lenb) &#123;</span><br><span class="line">        String C = A + A;</span><br><span class="line">        <span class="keyword">return</span> C.contains(B);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;如果对于一个字符串A，将A的前面任意一部分挪到后边去形成的字符串称为A的旋转词。比如A=”12345”,A的旋转词有”12345”,”23451”,”34512”,”45123”和”51234”。对于两个字符串A和B，请判断A和B是否互为旋转词。&lt;br&gt;给定两个字符串A和B
      
    
    </summary>
    
      <category term="直通BAT面试算法" scheme="https://lierabbit.cn/categories/%E7%9B%B4%E9%80%9ABAT%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>词语变形</title>
    <link href="https://lierabbit.cn/2018/02/18/%E8%AF%8D%E8%AF%AD%E5%8F%98%E5%BD%A2/"/>
    <id>https://lierabbit.cn/2018/02/18/词语变形/</id>
    <published>2018-02-18T09:48:13.000Z</published>
    <updated>2018-08-24T07:46:11.079Z</updated>
    
    <content type="html"><![CDATA[<p>对于两个字符串A和B，如果A和B中出现的字符种类相同且每种字符出现的次数相同，则A和B互为变形词，请设计一个高效算法，检查两给定串是否互为变形词。<br>给定两个字符串A和B及他们的长度，请返回一个bool值，代表他们是否互为变形词。<br>测试样例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;abc&quot;,3,&quot;bca&quot;,3</span><br><span class="line">返回：true</span><br></pre></td></tr></table></figure><p>思路：使用数组模拟hashMap计数，只要字符出现次数一致就互为变形词</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">chkTransform</span><span class="params">(String str1, <span class="keyword">int</span> lena, String str2, <span class="keyword">int</span> lenb)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">if</span> (str1 == <span class="keyword">null</span> || str2 == <span class="keyword">null</span> || lena != lenb)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>[] chars1 = str1.toCharArray();</span><br><span class="line">    <span class="keyword">char</span>[] chars2 = str2.toCharArray();</span><br><span class="line">    <span class="keyword">int</span>[] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> char1 : chars1)</span><br><span class="line">        map[char1]++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> char2 : chars2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map[char2]-- == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对于两个字符串A和B，如果A和B中出现的字符种类相同且每种字符出现的次数相同，则A和B互为变形词，请设计一个高效算法，检查两给定串是否互为变形词。&lt;br&gt;给定两个字符串A和B及他们的长度，请返回一个bool值，代表他们是否互为变形词。&lt;br&gt;测试样例：&lt;/p&gt;
&lt;figur
      
    
    </summary>
    
      <category term="直通BAT面试算法" scheme="https://lierabbit.cn/categories/%E7%9B%B4%E9%80%9ABAT%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>拓扑结构相同子树</title>
    <link href="https://lierabbit.cn/2018/02/18/%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84%E7%9B%B8%E5%90%8C%E5%AD%90%E6%A0%91/"/>
    <id>https://lierabbit.cn/2018/02/18/拓扑结构相同子树/</id>
    <published>2018-02-18T09:33:25.000Z</published>
    <updated>2018-08-24T07:41:54.834Z</updated>
    
    <content type="html"><![CDATA[<p>对于两棵彼此独立的二叉树A和B，请编写一个高效算法，检查A中是否存在一棵子树与B树的拓扑结构完全相同。<br>给定两棵二叉树的头结点A和B，请返回一个bool值，代表A中是否存在一棵同构于B的子树。</p><p>思路：将树序列化成字符串。如果A树中存在一棵子树与B树的拓扑结构完全相同则A序列化后的字符串必定包含B序列化后的字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> TreeNode left = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">public</span> TreeNode right = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">chkIdentical</span><span class="params">(TreeNode A, TreeNode B)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        String AS = treeToStringWithStack(A);</span><br><span class="line">        String BS = treeToStringWithStack(B);</span><br><span class="line">        <span class="keyword">return</span> AS.contains(BS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">treeToStringWithStack</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        stack.add(root);</span><br><span class="line">        TreeNode node;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!stack.empty()) &#123;</span><br><span class="line">            node = stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">                result.append(<span class="string">"#!"</span>);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                result.append(node.val).append(<span class="string">"!"</span>);</span><br><span class="line">                stack.add(node.right);</span><br><span class="line">                stack.add(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归先序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serialByPre</span><span class="params">(TreeNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"#!"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String res = head.val + <span class="string">"!"</span>;</span><br><span class="line">        res += serialByPre(head.left);</span><br><span class="line">        res += serialByPre(head.right);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对于两棵彼此独立的二叉树A和B，请编写一个高效算法，检查A中是否存在一棵子树与B树的拓扑结构完全相同。&lt;br&gt;给定两棵二叉树的头结点A和B，请返回一个bool值，代表A中是否存在一棵同构于B的子树。&lt;/p&gt;
&lt;p&gt;思路：将树序列化成字符串。如果A树中存在一棵子树与B树的拓扑
      
    
    </summary>
    
      <category term="直通BAT面试算法" scheme="https://lierabbit.cn/categories/%E7%9B%B4%E9%80%9ABAT%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>相邻两数最大差值</title>
    <link href="https://lierabbit.cn/2018/02/18/%E7%9B%B8%E9%82%BB%E4%B8%A4%E6%95%B0%E6%9C%80%E5%A4%A7%E5%B7%AE%E5%80%BC/"/>
    <id>https://lierabbit.cn/2018/02/18/相邻两数最大差值/</id>
    <published>2018-02-18T08:24:09.000Z</published>
    <updated>2018-08-24T07:40:49.628Z</updated>
    
    <content type="html"><![CDATA[<p>有一个整形数组A，请设计一个复杂度为O(n)的算法，算出排序后相邻两数的最大差值。<br>给定一个int数组A和A的大小n，请返回最大的差值。保证数组元素多于1个。<br>测试样例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1,2,5,4,6],5</span><br><span class="line">返回：2</span><br></pre></td></tr></table></figure><p>思路：使用2个n+1大小的桶按区间来放置最大和最小数，第n+1个桶单独放置最大值，取每个桶之间的最大差值即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxGap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取数组中最大最小值用来划分桶区间</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        min = Math.min(min, num);</span><br><span class="line">        max = Math.max(max, num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (max == min)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span>[] hasNums = <span class="keyword">new</span> <span class="keyword">boolean</span>[len + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span>[] maxs = <span class="keyword">new</span> <span class="keyword">int</span>[len + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span>[] mins = <span class="keyword">new</span> <span class="keyword">int</span>[len + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> bid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将数放入桶中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        bid = bucket(num, len, min, max);</span><br><span class="line">        mins[bid] = hasNums[bid] ? Math.min(mins[bid], num) : num;</span><br><span class="line">        maxs[bid] = hasNums[bid] ? Math.max(maxs[bid], num) : num;</span><br><span class="line">        hasNums[bid] = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> lastMax = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找第一个不为空的桶</span></span><br><span class="line">    <span class="keyword">while</span> (index &lt;= len) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hasNums[index]) &#123;</span><br><span class="line">            lastMax = maxs[index];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (index &lt;= len) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hasNums[index]) &#123;</span><br><span class="line">            <span class="comment">// 当桶的最小值减去上一个不为空的桶最大值即为2个桶的最大差值</span></span><br><span class="line">            result = Math.max(result, mins[index] - lastMax);</span><br><span class="line">            lastMax = maxs[index];</span><br><span class="line">        &#125;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用long类型是为了防止相乘时溢出</span></span><br><span class="line"><span class="comment">// 根据区间获取桶号</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bucket</span><span class="params">(<span class="keyword">long</span> num, <span class="keyword">long</span> len, <span class="keyword">long</span> min, <span class="keyword">long</span> max)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) ((num - min) * len / (max - min));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有一个整形数组A，请设计一个复杂度为O(n)的算法，算出排序后相邻两数的最大差值。&lt;br&gt;给定一个int数组A和A的大小n，请返回最大的差值。保证数组元素多于1个。&lt;br&gt;测试样例：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;t
      
    
    </summary>
    
      <category term="直通BAT面试算法" scheme="https://lierabbit.cn/categories/%E7%9B%B4%E9%80%9ABAT%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>最短子数组</title>
    <link href="https://lierabbit.cn/2018/02/18/%E6%9C%80%E7%9F%AD%E5%AD%90%E6%95%B0%E7%BB%84/"/>
    <id>https://lierabbit.cn/2018/02/18/最短子数组/</id>
    <published>2018-02-18T08:05:18.000Z</published>
    <updated>2018-08-24T07:35:29.447Z</updated>
    
    <content type="html"><![CDATA[<p>对于一个数组，请设计一个高效算法计算需要排序的最短子数组的长度。<br>给定一个int数组A和数组的大小n，请返回一个二元组，代表所求序列的长度。(原序列位置从0开始标号,若原序列有序，返回0)。保证A中元素均为正整数。<br>测试样例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1,4,6,5,9,10],6</span><br><span class="line">返回：2</span><br></pre></td></tr></table></figure><p>思路：从左往右记录最大值，并记录最大值大于当前遍历数的位置，因为排序后最大值至少在当前位置或者更右的位置。从右往左记录最小值，并记录最小值小于当前遍历数的位置，因为排序后最小值至少在当前位置或者更左的位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shortestSubsequence</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> max = A[maxIndex];</span><br><span class="line">    <span class="keyword">int</span> minIndex = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> min = A[n - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = maxIndex + <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (max &lt;= A[i])</span><br><span class="line">            max = A[i];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            maxIndex = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = minIndex - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (min &gt;= A[i])</span><br><span class="line">            min = A[i];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            minIndex = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (maxIndex == <span class="number">0</span> &amp;&amp; minIndex == n - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> maxIndex - minIndex + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对于一个数组，请设计一个高效算法计算需要排序的最短子数组的长度。&lt;br&gt;给定一个int数组A和数组的大小n，请返回一个二元组，代表所求序列的长度。(原序列位置从0开始标号,若原序列有序，返回0)。保证A中元素均为正整数。&lt;br&gt;测试样例：&lt;/p&gt;
&lt;figure class
      
    
    </summary>
    
      <category term="直通BAT面试算法" scheme="https://lierabbit.cn/categories/%E7%9B%B4%E9%80%9ABAT%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>有序矩阵查找</title>
    <link href="https://lierabbit.cn/2018/02/18/%E6%9C%89%E5%BA%8F%E7%9F%A9%E9%98%B5%E6%9F%A5%E6%89%BE/"/>
    <id>https://lierabbit.cn/2018/02/18/有序矩阵查找/</id>
    <published>2018-02-18T07:57:22.000Z</published>
    <updated>2018-08-24T07:26:53.382Z</updated>
    
    <content type="html"><![CDATA[<p>现在有一个行和列都排好序的矩阵，请设计一个高效算法，快速查找矩阵中是否含有值x。<br>给定一个int矩阵mat，同时给定矩阵大小nxm及待查找的数x，请返回一个bool值，代表矩阵中是否存在x。所有矩阵中数字及x均为int范围内整数。保证n和m均小于等于1000。<br>测试样例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[1,2,3],[4,5,6],[7,8,9]],3,3,10</span><br><span class="line">返回：false</span><br></pre></td></tr></table></figure><p>思路：从右上角开始找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findX</span><span class="params">(<span class="keyword">int</span>[][] mat, <span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> col = m - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (row &lt; n &amp;&amp; col &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mat[row][col] == x)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">// 比它大往左走</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (x &lt;= mat[row][col]) &#123;</span><br><span class="line">                col--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 比它小往下走</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (x &gt;= mat[row][col]) &#123;</span><br><span class="line">                row++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;现在有一个行和列都排好序的矩阵，请设计一个高效算法，快速查找矩阵中是否含有值x。&lt;br&gt;给定一个int矩阵mat，同时给定矩阵大小nxm及待查找的数x，请返回一个bool值，代表矩阵中是否存在x。所有矩阵中数字及x均为int范围内整数。保证n和m均小于等于1000。&lt;br&gt;
      
    
    </summary>
    
      <category term="直通BAT面试算法" scheme="https://lierabbit.cn/categories/%E7%9B%B4%E9%80%9ABAT%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>三色排序</title>
    <link href="https://lierabbit.cn/2018/02/17/%E4%B8%89%E8%89%B2%E6%8E%92%E5%BA%8F/"/>
    <id>https://lierabbit.cn/2018/02/17/三色排序/</id>
    <published>2018-02-17T11:38:54.000Z</published>
    <updated>2018-08-24T07:15:50.052Z</updated>
    
    <content type="html"><![CDATA[<p>有一个只由0，1，2三种元素构成的整数数组，请使用交换、原地排序而不是使用计数进行排序。<br>给定一个只含0，1，2的整数数组A及它的大小，请返回排序后的数组。保证数组大小小于等于500。<br>测试样例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[0,1,1,0,2,2],6</span><br><span class="line">返回：[0,0,1,1,2,2]</span><br></pre></td></tr></table></figure></p><p>思路：类似于快排，小的放左边，大的放右边</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] sortThreeColor(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">int</span> left = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> right = n;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (index &lt; right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[index] == <span class="number">0</span>)</span><br><span class="line">            swap(arr, ++left, index++);  <span class="comment">// 由于前面的数已经遍历过，所以交换后可以后移即(index++)</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arr[index] == <span class="number">2</span>)</span><br><span class="line">            swap(arr, --right, index);  <span class="comment">// 右边的数没有遍历过，所以交换后index不增</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有一个只由0，1，2三种元素构成的整数数组，请使用交换、原地排序而不是使用计数进行排序。&lt;br&gt;给定一个只含0，1，2的整数数组A及它的大小，请返回排序后的数组。保证数组大小小于等于500。&lt;br&gt;测试样例：&lt;br&gt;&lt;figure class=&quot;highlight plai
      
    
    </summary>
    
      <category term="直通BAT面试算法" scheme="https://lierabbit.cn/categories/%E7%9B%B4%E9%80%9ABAT%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>有序数组合并</title>
    <link href="https://lierabbit.cn/2018/02/17/%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E5%90%88%E5%B9%B6/"/>
    <id>https://lierabbit.cn/2018/02/17/有序数组合并/</id>
    <published>2018-02-17T10:48:59.000Z</published>
    <updated>2018-08-24T07:13:44.641Z</updated>
    
    <content type="html"><![CDATA[<p>有两个从小到大排序以后的数组A和B，其中A的末端有足够的缓冲空容纳B。请编写一个方法，将B合并入A并排序。<br>给定两个有序int数组A和B，A中的缓冲空用0填充，同时给定A和B的真实大小int n和int m，请返回合并后的数组。</p><p>思路：从后往前按序填充</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] mergeAB(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B, <span class="keyword">int</span> n, <span class="keyword">int</span> m) &#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">while</span> (m != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            A[m - <span class="number">1</span>] = B[m - <span class="number">1</span>];</span><br><span class="line">            m--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            A[m + n - <span class="number">1</span>] = A[n - <span class="number">1</span>] &gt; B[m - <span class="number">1</span>] ? A[--n] : B[--m];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有两个从小到大排序以后的数组A和B，其中A的末端有足够的缓冲空容纳B。请编写一个方法，将B合并入A并排序。&lt;br&gt;给定两个有序int数组A和B，A中的缓冲空用0填充，同时给定A和B的真实大小int n和int m，请返回合并后的数组。&lt;/p&gt;
&lt;p&gt;思路：从后往前按序填充&lt;
      
    
    </summary>
    
      <category term="直通BAT面试算法" scheme="https://lierabbit.cn/categories/%E7%9B%B4%E9%80%9ABAT%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
