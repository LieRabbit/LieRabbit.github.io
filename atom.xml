<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>谎话兔博客</title>
  
  <subtitle>LieRabbit</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://lierabbit.cn/"/>
  <updated>2018-08-26T14:49:45.324Z</updated>
  <id>https://lierabbit.cn/</id>
  
  <author>
    <name>谎话兔</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>最接近的三数之和</title>
    <link href="https://lierabbit.cn/2018/05/23/%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>https://lierabbit.cn/2018/05/23/最接近的三数之和/</id>
    <published>2018-05-23T07:52:05.000Z</published>
    <updated>2018-08-26T14:49:45.324Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。<br>例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.<br>与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).</p><p>解决方案：确定第一个数，然后通过夹逼算法寻找接近target的数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = nums[<span class="number">0</span>] + nums[<span class="number">1</span>] + nums[<span class="number">2</span>];</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> lo = i + <span class="number">1</span>, hi = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = nums[i] + nums[lo] + nums[hi];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (sum &lt; target)</span><br><span class="line">                lo++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target)</span><br><span class="line">                hi--;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> target;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (Math.abs(target - sum) &lt; Math.abs(target - res))</span><br><span class="line">                res = sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。&lt;br&gt;例如，给定数组 nums = [-1，2，1，-4], 和 target = 1
      
    
    </summary>
    
      <category term="LeetCode算法之旅" scheme="https://lierabbit.cn/categories/LeetCode%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>三数之和</title>
    <link href="https://lierabbit.cn/2018/05/23/%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>https://lierabbit.cn/2018/05/23/三数之和/</id>
    <published>2018-05-23T07:21:13.000Z</published>
    <updated>2018-08-26T14:48:46.326Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。</p><p>注意：答案中不可以包含重复的三元组。<br>例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，<br>满足要求的三元组集合为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [-1, 0, 1],</span><br><span class="line">  [-1, -1, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>解决方案：先确定一个数，则另外两数之和等于该数的相反数，通过夹逼算法寻找两数之和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 跳过前后一样的数字</span></span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span> || nums[i] != nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">int</span> lo = i + <span class="number">1</span>, hi = nums.length - <span class="number">1</span>, sum = -nums[i];</span><br><span class="line">            <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[lo] + nums[hi] == sum) &#123;</span><br><span class="line">                    res.add(Arrays.asList(nums[i], nums[lo], nums[hi]));</span><br><span class="line">                    <span class="comment">// 跳过前后一样的数字</span></span><br><span class="line">                    <span class="keyword">while</span> (lo &lt; hi &amp;&amp; nums[lo] == nums[lo + <span class="number">1</span>])</span><br><span class="line">                        lo++;</span><br><span class="line">                    <span class="keyword">while</span> (lo &lt; hi &amp;&amp; nums[hi] == nums[hi - <span class="number">1</span>])</span><br><span class="line">                        hi--;</span><br><span class="line">                    lo++;</span><br><span class="line">                    hi--;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[lo] + nums[hi] &lt; sum)</span><br><span class="line">                    lo++;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    hi--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。&lt;/p&gt;
&lt;p&gt;注意：答案中不可以包含重复的三元组。&lt;br&gt;例如, 给定数组 nums = [-1, 0, 1,
      
    
    </summary>
    
      <category term="LeetCode算法之旅" scheme="https://lierabbit.cn/categories/LeetCode%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>最长公共前缀</title>
    <link href="https://lierabbit.cn/2018/05/21/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/"/>
    <id>https://lierabbit.cn/2018/05/21/最长公共前缀/</id>
    <published>2018-05-21T06:48:08.000Z</published>
    <updated>2018-08-26T14:46:25.587Z</updated>
    
    <content type="html"><![CDATA[<p>编写一个函数来查找字符串数组中的最长公共前缀。<br>如果不存在公共前缀，返回空字符串 “”。</p><blockquote><p>示例 1:<br>输入: [“flower”,”flow”,”flight”]<br>输出: “fl”<br>示例 2:<br>输入: [“dog”,”racecar”,”car”]<br>输出: “”<br>解释: 输入不存在公共前缀。<br>说明:<br>所有输入只包含小写字母 a-z 。</p></blockquote><p>解决方案（一）：横向匹配所有字符串<br><img src="https://blog-1252204470.cos.ap-guangzhou.myqcloud.com/2018/05/21/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/1.jpg" alt=""><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (strs == <span class="keyword">null</span> || strs.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    String prefix = strs[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (strs[i].indexOf(prefix) != <span class="number">0</span>) &#123;</span><br><span class="line">            prefix = prefix.substring(<span class="number">0</span>, prefix.length() - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (prefix.isEmpty())</span><br><span class="line">                <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> prefix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>解决方案（二）：二分搜索<br><img src="https://blog-1252204470.cos.ap-guangzhou.myqcloud.com/2018/05/21/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/2.jpg" alt=""><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix2</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (strs == <span class="keyword">null</span> || strs.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> minLen = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (String str : strs)</span><br><span class="line">        minLen = Math.min(minLen, str.length());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">1</span>, right = minLen;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> middle = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (isCommonPrefix(strs, middle))</span><br><span class="line">            left = middle + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            right = middle - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> strs[<span class="number">0</span>].substring(<span class="number">0</span>, (left + right) / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCommonPrefix</span><span class="params">(String[] strs, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    String str1 = strs[<span class="number">0</span>].substring(<span class="number">0</span>, len);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!strs[i].startsWith(str1))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;编写一个函数来查找字符串数组中的最长公共前缀。&lt;br&gt;如果不存在公共前缀，返回空字符串 “”。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;示例 1:&lt;br&gt;输入: [“flower”,”flow”,”flight”]&lt;br&gt;输出: “fl”&lt;br&gt;示例 2:&lt;br&gt;输入: [
      
    
    </summary>
    
      <category term="LeetCode算法之旅" scheme="https://lierabbit.cn/categories/LeetCode%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>罗马数字转整数</title>
    <link href="https://lierabbit.cn/2018/05/14/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/"/>
    <id>https://lierabbit.cn/2018/05/14/罗马数字转整数/</id>
    <published>2018-05-14T13:44:33.000Z</published>
    <updated>2018-08-26T14:43:42.805Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">罗马数字包含以下七种字符：I， V， X， L，C，D 和 M。</span><br><span class="line">字符          数值</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure><p>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。<br>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p><ul><li>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。</li><li>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 </li><li>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。</li></ul><p>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p><blockquote><p>示例 1:<br>输入: “III”<br>输出: 3<br>示例 2:<br>输入: “IV”<br>输出: 4<br>示例 3:<br>输入: “IX”<br>输出: 9<br>示例 4:<br>输入: “LVIII”<br>输出: 58<br>解释: C = 100, L = 50, XXX = 30, III = 3.<br>示例 5:<br>输入: “MCMXCIV”<br>输出: 1994<br>解释: M = 1000, CM = 900, XC = 90, IV = 4.</p></blockquote><p>解决方案：如果当前字符代表的数字小于下一个字符代表的数字，则做减法，反之加法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">'I'</span>, <span class="number">1</span>);</span><br><span class="line">    map.put(<span class="string">'V'</span>, <span class="number">5</span>);</span><br><span class="line">    map.put(<span class="string">'X'</span>, <span class="number">10</span>);</span><br><span class="line">    map.put(<span class="string">'L'</span>, <span class="number">50</span>);</span><br><span class="line">    map.put(<span class="string">'C'</span>, <span class="number">100</span>);</span><br><span class="line">    map.put(<span class="string">'D'</span>, <span class="number">500</span>);</span><br><span class="line">    map.put(<span class="string">'M'</span>, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.get(s.charAt(i)) &lt; map.get(s.charAt(i + <span class="number">1</span>)))</span><br><span class="line">            sum -= map.get(s.charAt(i));</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            sum += map.get(s.charAt(i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sum += map.get(s.charAt(s.length() - <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
      <category term="LeetCode算法之旅" scheme="https://lierabbit.cn/categories/LeetCode%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>整数转罗马数字</title>
    <link href="https://lierabbit.cn/2018/05/14/%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/"/>
    <id>https://lierabbit.cn/2018/05/14/整数转罗马数字/</id>
    <published>2018-05-14T08:39:40.000Z</published>
    <updated>2018-08-26T14:42:11.144Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。</span><br><span class="line">字符          数值</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure><p>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。<br>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p><ul><li>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。</li><li>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 </li><li>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。</li></ul><p>给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。</p><blockquote><p>示例 1:<br>输入: 3<br>输出: “III”<br>示例 2:<br>输入: 4<br>输出: “IV”<br>示例 3:<br>输入: 9<br>输出: “IX”<br>示例 4:<br>输入: 58<br>输出: “LVIII”<br>解释: C = 100, L = 50, XXX = 30, III = 3.<br>示例 5:<br>输入: 1994<br>输出: “MCMXCIV”<br>解释: M = 1000, CM = 900, XC = 90, IV = 4.</p></blockquote><p>解决方案：直接储存各个位上的字符🙃</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    String M[] = &#123;<span class="string">""</span>, <span class="string">"M"</span>, <span class="string">"MM"</span>, <span class="string">"MMM"</span>&#125;;</span><br><span class="line">    String C[] = &#123;<span class="string">""</span>, <span class="string">"C"</span>, <span class="string">"CC"</span>, <span class="string">"CCC"</span>, <span class="string">"CD"</span>, <span class="string">"D"</span>, <span class="string">"DC"</span>, <span class="string">"DCC"</span>, <span class="string">"DCCC"</span>, <span class="string">"CM"</span>&#125;;</span><br><span class="line">    String X[] = &#123;<span class="string">""</span>, <span class="string">"X"</span>, <span class="string">"XX"</span>, <span class="string">"XXX"</span>, <span class="string">"XL"</span>, <span class="string">"L"</span>, <span class="string">"LX"</span>, <span class="string">"LXX"</span>, <span class="string">"LXXX"</span>, <span class="string">"XC"</span>&#125;;</span><br><span class="line">    String I[] = &#123;<span class="string">""</span>, <span class="string">"I"</span>, <span class="string">"II"</span>, <span class="string">"III"</span>, <span class="string">"IV"</span>, <span class="string">"V"</span>, <span class="string">"VI"</span>, <span class="string">"VII"</span>, <span class="string">"VIII"</span>, <span class="string">"IX"</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> M[num / <span class="number">1000</span>] + C[num % <span class="number">1000</span> / <span class="number">100</span>] + X[num % <span class="number">100</span> / <span class="number">10</span>] + I[num % <span class="number">10</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
      <category term="LeetCode算法之旅" scheme="https://lierabbit.cn/categories/LeetCode%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>盛最多水的容器</title>
    <link href="https://lierabbit.cn/2018/05/14/%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/"/>
    <id>https://lierabbit.cn/2018/05/14/盛最多水的容器/</id>
    <published>2018-05-14T08:06:24.000Z</published>
    <updated>2018-08-26T14:38:57.088Z</updated>
    
    <content type="html"><![CDATA[<p>给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。画 n 条垂直线，使得垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><p>解决方案：从头和尾开始找起，一开始就获得了最大长度，由于面积是取较小的高度，所以移动高度较小的索引以期待能获得更高的高度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = height.length - <span class="number">1</span>, max = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        max = Math.max(max, (r - l) * Math.min(height[l], height[r]));</span><br><span class="line">        <span class="keyword">if</span> (height[l] &lt; height[r])</span><br><span class="line">            l++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            r--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。画 n 条垂直线，使得垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。&lt;/p&gt;
&lt;p&gt;解决方案：从头和
      
    
    </summary>
    
      <category term="LeetCode算法之旅" scheme="https://lierabbit.cn/categories/LeetCode%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式匹配</title>
    <link href="https://lierabbit.cn/2018/05/14/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D-1/"/>
    <id>https://lierabbit.cn/2018/05/14/正则表达式匹配-1/</id>
    <published>2018-05-14T07:19:01.000Z</published>
    <updated>2018-08-26T14:37:45.716Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个字符串 (s) 和一个字符模式 (p)。实现支持 ‘.’ 和 ‘<em>‘ 的正则表达式匹配。<br>‘.’ 匹配任意单个字符。<br>‘</em>‘ 匹配零个或多个前面的元素。<br>匹配应该覆盖整个字符串 (s) ，而不是部分字符串。</p><blockquote><p>说明:<br>s 可能为空，且只包含从 a-z 的小写字母。<br>p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 <em>。<br>示例 1:<br>输入:<br>s = “aa”<br>p = “a”<br>输出: false<br>解释: “a” 无法匹配 “aa” 整个字符串。<br>示例 2:<br>输入:<br>s = “aa”<br>p = “a</em>“<br>输出: true<br>解释: ‘<em>‘ 代表可匹配零个或多个前面的元素, 即可以匹配 ‘a’ 。因此, 重复 ‘a’ 一次, 字符串可变为 “aa”。<br>示例 3:<br>输入:<br>s = “ab”<br>p = “.</em>“<br>输出: true<br>解释: “.<em>“ 表示可匹配零个或多个(‘</em>‘)任意字符(‘.’)。<br>示例 4:<br>输入:<br>s = “aab”<br>p = “c<em>a</em>b”<br>输出: true<br>解释: ‘c’ 可以不被重复, ‘a’ 可以被重复一次。因此可以匹配字符串 “aab”。<br>示例 5:<br>输入:<br>s = “mississippi”<br>p = “mis<em>is</em>p*.”<br>输出: false</p></blockquote><p>解决方案：</p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>当模式中的第二个字符是“*”时：<br>如果字符串第一个字符跟模式第一个字符不匹配，则模式后移2个字符，继续匹配。如果字符串第一个字符跟模式第一个字符匹配，可以有2种匹配方式： </p><ul><li>模式后移2字符，相当于x*被忽略</li><li>字符串后移1字符，模式不变，即继续匹配字符下一位，因为<em>可以匹配多位<br>当模式中的第二个字符不是“</em>”时：</li><li>如果字符串第一个字符和模式中的第一个字符相匹配，那么字符串和模式都后移一个字符，然后匹配剩余的</li><li>如果字符串第一个字符和模式中的第一个字符相不匹配，直接返回false</li></ul><p>这里需要注意的是：要时刻检验数组是否越界</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || p == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isMatchCore(s, <span class="number">0</span>, p, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatchCore</span><span class="params">(String s, <span class="keyword">int</span> sIndex, String p, <span class="keyword">int</span> pIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 有效性检验：str到尾，pattern到尾，匹配成功</span></span><br><span class="line">    <span class="keyword">if</span> (s.length() == sIndex &amp;&amp; p.length() == pIndex)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// pattern先到尾，匹配失败</span></span><br><span class="line">    <span class="keyword">if</span> (p.length() == pIndex)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 模式后一个字符是*，且字符串第1个跟模式第1个匹配,分2种匹配模式。如不匹配，模式后移2位</span></span><br><span class="line">    <span class="keyword">if</span> (pIndex + <span class="number">1</span> &lt; p.length() &amp;&amp; p.charAt(pIndex + <span class="number">1</span>) == <span class="string">'*'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sIndex &lt; s.length() &amp;&amp; (s.charAt(sIndex) == p.charAt(pIndex) || p.charAt(pIndex) == <span class="string">'.'</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> isMatchCore(s, sIndex + <span class="number">1</span>, p, pIndex) || <span class="comment">// x*匹配1个字符，再匹配str中的下一个</span></span><br><span class="line">                    isMatchCore(s, sIndex, p, pIndex + <span class="number">2</span>); <span class="comment">// 模式后移2位，视为x*匹配0个字符</span></span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> isMatchCore(s, sIndex, p, pIndex + <span class="number">2</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 模式后一个字符不是*，且字符串第1个跟模式第1个匹配，则都后移1位，否则直接返回false</span></span><br><span class="line">        <span class="keyword">if</span> (sIndex &lt; s.length() &amp;&amp; (s.charAt(sIndex) == p.charAt(pIndex) || p.charAt(pIndex) == <span class="string">'.'</span>))</span><br><span class="line">            <span class="keyword">return</span> isMatchCore(s, sIndex + <span class="number">1</span>, p, pIndex + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>只需要注意后一个字符是否为<em>即可，<br>第一个字符直接进行对比判断，当第二个字符为</em>时，有2种情况</p><ul><li>0个字符匹配，模式直接往后跳2位</li><li>1个字符匹配，字符串往后跳1位<br>没*的话直接对比匹配即可</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch2</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p.isEmpty())</span><br><span class="line">        <span class="keyword">return</span> s.isEmpty();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> firstMatch = !s.isEmpty() &amp;&amp; (s.charAt(<span class="number">0</span>) == p.charAt(<span class="number">0</span>) || p.charAt(<span class="number">0</span>) == <span class="string">'.'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p.length() &gt; <span class="number">1</span> &amp;&amp; p.charAt(<span class="number">1</span>) == <span class="string">'*'</span>)</span><br><span class="line">        <span class="keyword">return</span> isMatch2(s, p.substring(<span class="number">2</span>)) || (firstMatch &amp;&amp; isMatch2(s.substring(<span class="number">1</span>), p));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> firstMatch &amp;&amp; isMatch2(s.substring(<span class="number">1</span>), p.substring(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定一个字符串 (s) 和一个字符模式 (p)。实现支持 ‘.’ 和 ‘&lt;em&gt;‘ 的正则表达式匹配。&lt;br&gt;‘.’ 匹配任意单个字符。&lt;br&gt;‘&lt;/em&gt;‘ 匹配零个或多个前面的元素。&lt;br&gt;匹配应该覆盖整个字符串 (s) ，而不是部分字符串。&lt;/p&gt;
&lt;blockquo
      
    
    </summary>
    
      <category term="LeetCode算法之旅" scheme="https://lierabbit.cn/categories/LeetCode%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>回文数</title>
    <link href="https://lierabbit.cn/2018/05/09/%E5%9B%9E%E6%96%87%E6%95%B0/"/>
    <id>https://lierabbit.cn/2018/05/09/回文数/</id>
    <published>2018-05-09T04:28:24.000Z</published>
    <updated>2018-08-26T14:34:46.657Z</updated>
    
    <content type="html"><![CDATA[<p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p><blockquote><p>示例 1:<br>输入: 121<br>输出: true<br>示例 2:<br>输入: -121<br>输出: false<br>解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。<br>示例 3:<br>输入: 10<br>输出: false<br>解释: 从右向左读, 为 01 。因此它不是一个回文数。<br>进阶: 你能不将整数转为字符串来解决这个问题吗？</p></blockquote><p>解决方案：</p><ul><li>如果是负数则不是回文数</li><li>如果个位为0则不是回文数，0除外，因为如果个位为0则首位必须为0，然而除了0之外没有首位为0的数</li><li>反转数的一半，例如x=12321，则x=12，reverse=123则x=reverse/10</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span> || (x % <span class="number">10</span> == <span class="number">0</span> &amp;&amp; x != <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> reverse = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 反转数字的一半</span></span><br><span class="line">    <span class="keyword">while</span> (x &gt; reverse) &#123;</span><br><span class="line">        reverse = reverse * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x == reverse || reverse / <span class="number">10</span> == x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;示例 1:&lt;br&gt;输入: 121&lt;br&gt;输出: true&lt;br&gt;示例 2:&lt;br&gt;输入: -121&lt;br&gt;输出: false&lt;br&gt;解释: 从左
      
    
    </summary>
    
      <category term="LeetCode算法之旅" scheme="https://lierabbit.cn/categories/LeetCode%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>字符串转整数</title>
    <link href="https://lierabbit.cn/2018/05/09/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%95%B4%E6%95%B0/"/>
    <id>https://lierabbit.cn/2018/05/09/字符串转整数/</id>
    <published>2018-05-09T03:42:42.000Z</published>
    <updated>2018-08-26T14:32:56.200Z</updated>
    
    <content type="html"><![CDATA[<p>实现 atoi，将字符串转为整数。<br>在找到第一个非空字符之前，需要移除掉字符串中的空格字符。如果第一个非空字符是正号或负号，选取该符号，并将其与后面尽可能多的连续的数字组合起来，这部分字符即为整数的值。如果第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。<br>字符串可以在形成整数的字符后面包括多余的字符，这些字符可以被忽略，它们对于函数没有影响。<br>当字符串中的第一个非空字符序列不是个有效的整数；或字符串为空；或字符串仅包含空白字符时，则不进行转换。<br>若函数不能执行有效的转换，返回 0。</p><blockquote><p>说明：<br>假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231,  231 − 1]。如果数值超过可表示的范围，则返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。<br>示例 1:<br>输入: “42”<br>输出: 42<br>示例 2:<br>输入: “   -42”<br>输出: -42<br>解释: 第一个非空白字符为 ‘-‘, 它是一个负号。我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。<br>示例 3:<br>输入: “4193 with words”<br>输出: 4193<br>解释: 转换截止于数字 ‘3’ ，因为它的下一个字符不为数字。<br>示例 4:<br>输入: “words and 987”<br>输出: 0<br>解释: 第一个非空字符是 ‘w’, 但它不是数字或正、负号。因此无法执行有效的转换。<br>示例 5:<br>输入: “-91283472332”<br>输出: -2147483648<br>解释: 数字 “-91283472332” 超过 32 位有符号整数范围。 因此返回 INT_MIN (−231) 。</p></blockquote><p>解决方案：只需要注意4个地方</p><ul><li>字符串前面的空格</li><li>符号位</li><li>只要连续的数字</li><li>溢出判断</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span> || str.length() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>, base = <span class="number">0</span>, sign = <span class="number">1</span>, len = str.length();</span><br><span class="line">    <span class="comment">// 跳过空格</span></span><br><span class="line">    <span class="keyword">while</span> (index &lt; len &amp;&amp; str.charAt(index) == <span class="string">' '</span>)</span><br><span class="line">        index++;</span><br><span class="line">    <span class="comment">// 获取符号位</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; len &amp;&amp; (str.charAt(index) == <span class="string">'+'</span> || str.charAt(index) == <span class="string">'-'</span>))</span><br><span class="line">        sign = <span class="number">1</span> - <span class="number">2</span> * ((str.charAt(index++) == <span class="string">'-'</span>) ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 只取数字，碰到非数字退出循环</span></span><br><span class="line">    <span class="keyword">while</span> (index &lt; len &amp;&amp; str.charAt(index) &gt;= <span class="string">'0'</span> &amp;&amp; str.charAt(index) &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line">        <span class="comment">// 溢出判断，MAX_VALUE的个位为7</span></span><br><span class="line">        <span class="keyword">if</span> (base &gt; Integer.MAX_VALUE / <span class="number">10</span> || (base == Integer.MAX_VALUE / <span class="number">10</span> &amp;&amp; str.charAt(index) - <span class="string">'0'</span> &gt; <span class="number">7</span>))</span><br><span class="line">            <span class="keyword">if</span> (sign == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">        base = base * <span class="number">10</span> + str.charAt(index++) - <span class="string">'0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sign * base;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;实现 atoi，将字符串转为整数。&lt;br&gt;在找到第一个非空字符之前，需要移除掉字符串中的空格字符。如果第一个非空字符是正号或负号，选取该符号，并将其与后面尽可能多的连续的数字组合起来，这部分字符即为整数的值。如果第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，
      
    
    </summary>
    
      <category term="LeetCode算法之旅" scheme="https://lierabbit.cn/categories/LeetCode%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>反转整数</title>
    <link href="https://lierabbit.cn/2018/05/09/%E5%8F%8D%E8%BD%AC%E6%95%B4%E6%95%B0/"/>
    <id>https://lierabbit.cn/2018/05/09/反转整数/</id>
    <published>2018-05-09T02:52:29.000Z</published>
    <updated>2018-08-26T14:31:13.300Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个 32 位有符号整数，将整数中的数字进行反转。</p><blockquote><p>示例 1:<br>输入: 123<br>输出: 321<br>示例 2:<br>输入: -123<br>输出: -321<br>示例 3:<br>输入: 120<br>输出: 21<br>注意:假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−2<sup>31</sup>,  2<sup>31 − 1</sup>]。根据这个假设，如果反转后的整数溢出，则返回 0。</p></blockquote><p>解决方案：如果有溢出则无法回退到之前的结果！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> remainder = x % <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> newRes = res * <span class="number">10</span> + remainder;</span><br><span class="line">        <span class="keyword">if</span> ((newRes - remainder) / <span class="number">10</span> != res) <span class="comment">// 如果有溢出则无法回退到原来的结果</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        res = newRes;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定一个 32 位有符号整数，将整数中的数字进行反转。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;示例 1:&lt;br&gt;输入: 123&lt;br&gt;输出: 321&lt;br&gt;示例 2:&lt;br&gt;输入: -123&lt;br&gt;输出: -321&lt;br&gt;示例 3:&lt;br&gt;输入: 120&lt;br&gt;输出: 2
      
    
    </summary>
    
      <category term="LeetCode算法之旅" scheme="https://lierabbit.cn/categories/LeetCode%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Z字形变换</title>
    <link href="https://lierabbit.cn/2018/05/09/Z%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/"/>
    <id>https://lierabbit.cn/2018/05/09/Z字形变换/</id>
    <published>2018-05-09T02:17:52.000Z</published>
    <updated>2018-08-26T14:28:36.627Z</updated>
    
    <content type="html"><![CDATA[<p>将字符串 “PAYPALISHIRING” 以Z字形排列成给定的行数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">P   A   H   N</span><br><span class="line">A P L S I I G</span><br><span class="line">Y   I   R</span><br></pre></td></tr></table></figure></p><p>之后从左往右，逐行读取字符：”PAHNAPLSIIGYIR”<br>实现一个将字符串进行指定行数变换的函数:<br>string convert(string s, int numRows);</p><blockquote><p>示例 1:<br>输入: s = “PAYPALISHIRING”, numRows = 3<br>输出: “PAHNAPLSIIGYIR”<br>示例 2:<br>输入: s = “PAYPALISHIRING”, numRows = 4<br>输出: “PINALSIGYAHRPI”<br>解释:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">P     I    N</span><br><span class="line">A   L S  I G</span><br><span class="line">Y A   H R</span><br><span class="line">P     I</span><br></pre></td></tr></table></figure><p>解决方案：观察示例可知，往下走要走numRows步，往上走要走numRows-2步（除去头尾，因为和往下走重叠），这个结果可得出以下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">convert</span><span class="params">(String s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (numRows &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">    StringBuilder[] sbs = <span class="keyword">new</span> StringBuilder[numRows];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numRows; i++)</span><br><span class="line">        sbs[i] = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>, len = s.length();</span><br><span class="line">    <span class="keyword">while</span> (index &lt; len) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; numRows &amp;&amp; index &lt; len; row++) <span class="comment">// 往下走</span></span><br><span class="line">            sbs[row].append(s.charAt(index++));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = numRows - <span class="number">2</span>; row &gt; <span class="number">0</span> &amp;&amp; index &lt; len; row--) <span class="comment">// 往上走</span></span><br><span class="line">            sbs[row].append(s.charAt(index++));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">1</span>; row &lt; numRows; row++)</span><br><span class="line">        sbs[<span class="number">0</span>].append(sbs[row]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sbs[<span class="number">0</span>].toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;将字符串 “PAYPALISHIRING” 以Z字形排列成给定的行数：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;
      
    
    </summary>
    
      <category term="LeetCode算法之旅" scheme="https://lierabbit.cn/categories/LeetCode%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>最长回文子串</title>
    <link href="https://lierabbit.cn/2018/05/08/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
    <id>https://lierabbit.cn/2018/05/08/最长回文子串/</id>
    <published>2018-05-08T07:43:48.000Z</published>
    <updated>2018-08-26T14:25:33.373Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为1000。</p><blockquote><p>示例 1：<br>输入: “babad”<br>输出: “bab”<br>注意: “aba”也是一个有效答案。<br>示例 2：<br>输入: “cbbd”<br>输出: “bb”</p></blockquote><p>解决方案：首先，我们通过在字母之间插入特殊字符’＃’来将输入字符串S转换为另一个字符串T，这么做的原因很快就会很快清楚。<br>例如：S =“abaaba”，T =“＃a＃b＃a＃a＃b＃a＃”。<br>为了找到最长的回文子串，我们需要在每个T<sub>i</sub>周围扩展，使得T<sub>i-d</sub> … T<sub>i + d</sub>形成回文。你应该马上看到d是以T<sub>i</sub>为中心的回文的长度。<br>我们将中间结果存储在数组P中，其中P[i]等于在T<sub>i</sub>处的回文中心的长度。最长的回文子串将成为P中的最大元素。<br>使用上面的例子，我们填充P如下（从左到右）：<br>|序号|0|1|2|3|4|5|6|7|8|9|10|11|12|<br>| :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |<br>|T|#|a|#|b|#|a|#|a|#|b|#|a|#|<br>|P|0|1|0|3|0|1|6|1|0|3|0|1|0|<br>看着P，我们立即看到最长的回文是“abaaba”，如P<sub>6</sub> = 6所示。<br>您是否注意到通过在字母之间插入特殊字符（＃），这两个长度均为偶数的回文是否被优雅地处理？（请注意：这是为了更容易地演示这个想法，并不一定需要对算法进行编码。）<br>现在，想象你在回文中心“abaaba”绘制一条想象的垂直线。你有没有注意到P中的数字是围绕这个中心对称的？不仅如此，请尝试使用另一个回文“aba”，这些数字也反映了类似的对称性。这是巧合吗？答案是肯定的，不是。这仅仅是一个条件，但无论如何，我们有很大的进步，因为我们可以消除P[i]的重新计算部分。<br>让我们继续讨论一个稍微复杂的例子，其中有更多的重叠回文，其中S =“babcbabcbaccba”。<br><img src="https://blog-1252204470.cos.ap-guangzhou.myqcloud.com/2018/05/08/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/1.jpg" alt=""><br>上图显示T由S =“babcbabcbaccba”转化而来。假设你达到了表P部分完成的状态。垂直的实线表示回文“abcbabcba”的中心（C）。两条虚线垂直线分别表示其左（L）和右（R）边缘。您处于索引i处，其围绕C的镜像索引是i’。你如何有效地计算P [i]？<br>假设我们已经到达指数i = 13，并且我们需要计算P [13]（由问号？表示）。我们首先看一下它在回文中心C周围的镜像索引i’，索引i’= 9。<br><img src="https://blog-1252204470.cos.ap-guangzhou.myqcloud.com/2018/05/08/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/2.jpg" alt=""><br>上面的两条绿色实线表示以i和i’为中心的两个回文序列覆盖的区域。我们看一下C周围的镜像索引，它是索引i’。P [i’] = P [9] = 1.由于回文在其中心附近具有对称性，因此P [i]必须也是1。<br>正如你在上面看到的那样，P [i] = P [i’] = 1是非常明显的，由于回文中心周围的对称性，这一定是正确的。事实上，C之后的所有三个元素都遵循对称性（即P [12] = P [10] = 0，P [13] = P [9] = 1，P [14] = P [8] = 0）。<br><img src="https://blog-1252204470.cos.ap-guangzhou.myqcloud.com/2018/05/08/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/3.jpg" alt=""><br>现在我们处于索引i = 15，其C上的镜像索引是i’= 7。P [15] = P [7] = 7？<br>现在我们处于索引i = 15处。P [i]的价值是什么？如果我们遵循对称性，P [i]的值应该与P [i’] = 7相同，但这是错误的。如果我们在T<sub>15</sub>围绕中心展开，它形成回文“A·B·C·B·一”，这实际上是比什么是它的对称对应显示短。为什么？<br><img src="https://blog-1252204470.cos.ap-guangzhou.myqcloud.com/2018/05/08/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/4.jpg" alt=""><br>在索引i和i’中央围绕着彩色线条。绿色实线表示由于C周围的对称性而必须匹配两侧的区域。红色实线表示可能不匹配两侧的区域。绿色虚线显示穿过中心的区域。<br>很显然，由两条实线表示的区域中的两个子串必须完全匹配。中心区域（用绿色虚线表示）也必须是对称的。注意P [i’]是7，并且它一直扩展到回文的左边缘（L）（用红色实线表示），它不再落在回文的对称属性之下。我们所知道的是P [i] ≥5，并且为了找到P [i]的实际值，我们必须通过扩展右边缘（R）来进行字符匹配。在这种情况下，由于P [21]≠P <a href="https://blog-1252204470.cos.ap-guangzhou.myqcloud.com/2018/05/08/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/1.jpg" target="_blank" rel="noopener">1</a>，我们得出结论P [i] = 5。<br>我们总结一下这个算法的关键部分如下：</p><blockquote><p>如果 P [i’]≤R-i，<br>则 P [i]←P [i’]<br>否则 P [i]≥P[i’]。（我们必须扩展到右边缘（R）以找到P [i]。</p></blockquote><p>看看它有多优雅？如果你能够充分掌握上述总结，那么你已经获得了这个算法的本质，这也是最难的部分。<br>最后一部分是确定我们应该在何时将C的位置与R一起移动到右侧，这很容易：</p><blockquote><p>如果以i为中心的回文确实扩展到R，我们将C更新为i（这个新回文的中心），并将R延伸到新回文的右边。</p></blockquote><p>在每一步中，都有两种可能性。如果P [i]≤R-i，我们将P [i]设置为P [i’]，这只需要一步。否则，我们试图通过从右边缘R开始将回文中心改为i。扩展R（内部while循环）总共最多需要N个步骤，并且定位和测试每个中心总共需要N步太。因此，该算法确保在至多2 * N步完成，给出线性时间解决方案。<br><a href="https://articles.leetcode.com/longest-palindromic-substring-part-ii/" target="_blank" rel="noopener">Manacher(马拉车)算法</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 改造字符串</span></span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">"^"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, len = s.length(); i &lt; len; i++)</span><br><span class="line">        sb.append(<span class="string">"#"</span>).append(s.charAt(i));</span><br><span class="line">    sb.append(<span class="string">"#$"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">0</span>, r = <span class="number">0</span>, len = sb.length(), centerIndex = <span class="number">0</span>, maxLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] p = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> iMirror = <span class="number">2</span> * c - i; <span class="comment">// 相当于 c - (i - c)</span></span><br><span class="line"></span><br><span class="line">        p[i] = r &gt; i ? Math.min(r - i, p[iMirror]) : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 基于当前点为中心扩展寻找回文</span></span><br><span class="line">        <span class="keyword">while</span> (sb.charAt(i - <span class="number">1</span> - p[i]) == sb.charAt(i + <span class="number">1</span> + p[i]))</span><br><span class="line">            p[i]++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果扩展后的右边界值大于当前右边界值则更新</span></span><br><span class="line">        <span class="keyword">if</span> (i + p[i] &gt; r) &#123;</span><br><span class="line">            c = i;</span><br><span class="line">            r = i + p[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 寻找最大值与中心点</span></span><br><span class="line">        <span class="keyword">if</span> (p[i] &gt; maxLen) &#123;</span><br><span class="line">            maxLen = p[i];</span><br><span class="line">            centerIndex = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> beginIndex = (centerIndex - <span class="number">1</span> - maxLen) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s.substring(beginIndex, beginIndex + maxLen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为1000。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;示例 1：&lt;br&gt;输入: “babad”&lt;br&gt;输出: “bab”&lt;br&gt;注意: “aba”也是一个有效答案。&lt;br&gt;示例 2：&lt;br&gt;输入: “
      
    
    </summary>
    
      <category term="LeetCode算法之旅" scheme="https://lierabbit.cn/categories/LeetCode%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>两个排序数组的中位数</title>
    <link href="https://lierabbit.cn/2018/04/30/%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    <id>https://lierabbit.cn/2018/04/30/两个排序数组的中位数/</id>
    <published>2018-04-30T09:01:15.000Z</published>
    <updated>2018-08-26T14:07:44.747Z</updated>
    
    <content type="html"><![CDATA[<p>给定两个大小为 m 和 n 的有序数组 nums1 和 nums2 。<br>请找出这两个有序数组的中位数。要求算法的时间复杂度为 O(log (m+n)) 。</p><blockquote><p>示例 1:<br>nums1 = [1, 3]<br>nums2 = [2]<br>中位数是 2.0<br>示例 2:<br>nums1 = [1, 2]<br>nums2 = [3, 4]<br>中位数是 (2 + 3)/2 = 2.5</p></blockquote><p>解决方案：首先，让我们以一种非常规的方式看到’中位数’的概念。那是：<br>“ 如果我们将排序后的数组切割成等于两半的等长，则平均数为最大值（lower_half）和最小值（upper_half）的平均值，即紧靠切割的两个数字 ”。<br>例如，对于[2 3 5 7]，我们在3和5之间进行剪切：[2 3 / 5 7]<br>那么中位数=（3 + 5）/ 2。请注意，在本文中，我将使用’/‘来表示剪辑和（数字/数字）来表示通过数字进行的剪辑。<br>对于[2 3 4 5 6]，我们这样做了4：[2 3（4/4）5 7]<br>由于我们把4分成两半，所以我们说现在子单元的下部和上部都包含4个。这个概念也导致了正确的答案：（4 + 4）/ 2 = 4;为了方便起见，我们使用L来表示立即留给切割的数字，R表示正确的对应数字。例如[2 3 5 7]，我们分别有L = 3和R = 5。我们观察到L和R的索引与数组N的长度有下列关系：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">N      Index of L / R</span><br><span class="line">1               0 / 0</span><br><span class="line">2               0 / 1</span><br><span class="line">3               1 / 1  </span><br><span class="line">4               1 / 2      </span><br><span class="line">5               2 / 2</span><br><span class="line">6               2 / 3</span><br><span class="line">7               3 / 3</span><br><span class="line">8               3 / 4</span><br></pre></td></tr></table></figure></p><p>不难断定L =（N-1）/ 2的指数，并且R在N / 2。因此，中位数可以表示为(L + R)/2 = (A[(N-1)/2] + A[N/2])/2<br>为了准备好两个数组的情况，我们在数字之间添加一些想象的“位置”（表示为＃），并将数字视为“位置”。<br>[6 9 13 18]  -&gt;   [# 6 # 9 # 13 # 18 #]    (N = 4)<br>position index     0 1 2 3 4 5  6 7  8     (N_Position = 9)<br>[6 9 11 13 18]-&gt;   [# 6 # 9 # 11 # 13 # 18 #]   (N = 5)<br>position index      0 1 2 3 4 5  6 7  8 9 10    (N_Position = 11)<br>正如你所看到的，不管长度为N，总有正好2 * N + 1’的位置。因此，中间切割应该总是在第N个位置（基于0的位置）进行。在这种情况下，由于指数（L）=（N-1）/ 2和指数（R）= N / 2，我们可以推断指数（L）=（CutPosition-1）/ 2，指数（R）= ）/ 2。<br>现在对于两个数组的情况：<br>A1: [# 1 # 2 # 3 # 4 # 5 #]    (N1 = 5, N1_positions = 11)<br>A2: [# 1 # 1 # 1 # 1 #]     (N2 = 4, N2_positions = 9)<br>类似于单数组问题，我们需要找到一个将两个数组分成两半的切割<br>“左半部分的任何数字”&lt;=“右半部分的任何数字”。<br>我们也可以提出以下意见：</p><ol><li>共有2个N1 + 2个 N2 + 2个位置。因此，在切割的每一边必须有N1 + N2的位置，并且直接在切割处有2个位置。</li><li>因此，当我们在A2中的位置C2 = K处切割时，A1中的切割位置必须是C1 = N1 + N2-k。例如，如果C2 = 2，那么我们必须有C1 = 4 + 5 - C2 = 7。<br>[# 1 # 2 # 3 # (4/4) # 5 #]<br>[# 1 / 1 # 1 # 1 #]   </li><li>裁剪完成后，我们会有两个L和两个R。他们是<br>L1 = A1[(C1-1)/2]; R1 = A1[C1/2];<br>L2 = A2[(C2-1)/2]; R2 = A2[C2/2];<br>在上面的例子中，<br>L1 = A1[(7-1)/2] = A1[3] = 4; R1 = A1[7/2] = A1[3] = 4;<br>L2 = A2[(2-1)/2] = A2[0] = 1; R2 = A1[2/2] = A1[1] = 1;<br>现在我们该如何决定这个剪辑是否是我们想要的剪辑？因为L1，L2是左边最大的数字，而R1，R2是右边最小的数字，所以我们只需要L1 &lt;= R1 &amp;&amp; L1 &lt;= R2 &amp;&amp; L2 &lt;= R1 &amp;&amp; L2 &lt;= R2<br>确保下半部分的任何数字&lt;=上半部分的任何数字。事实上，因为L1 &lt;= R1和L2 &lt;= R2是自然保证的，因为A1和A2是分类的，我们只需要确保：L1 &lt;= R2且L2 &lt;= R1。<br>现在我们可以使用简单的二分查找来找出结果。<br>如果我们有L1&gt; R2，这意味着在A1的左半部分有太多的大数字，那么我们必须将C1向左移动（即向右移动C2）。<br>如果L2&gt; R1，那么A2的左半部分有太多的大数字，我们必须将C2移到左边。<br>否则，这一切是正确的。<br>在我们找到剪切后，介质可以计算为（max（L1，L2）+ min（R1，R2））/ 2;<br>两面说明：<br>A.由于C1和C2可以相互确定，我们可以先移动其中一个，然后相应地计算另一个。但是，首先将C2（较短阵列上的一个）移动更为实用。原因是，在较短的阵列上，所有位置都可能是中位数的切割位置，但在较长的阵列上，左右位置过于靠后的位置对于合法切割根本不可能。例如，[1]，[2 3 4 5 6 7 8]。很显然，2和3之间的切割是不可能的，因为如果你用这种方式进行切割，较短的阵列没有那么多元素来平衡[3 4 5 6 7 8]部分。因此，要将较长的阵列用作第一次切割的基础，必须执行范围检查。在较短的阵列上执行操作会更容易，因此无需进行任何检查。也，<br>B.唯一的边缘情况是当切割落在第0（第一）或第2 （最后）位置时。例如，如果C2 = 2N2，则R2 = A2 [2 * N2 / 2] = A2 [N2]，其超出阵列的边界。为了解决这个问题，我们可以想象，A1和A2实际上有两个额外的元素，INT_MAX在A [-1]和INT_MAX在A [N]。这些添加不会改变结果，但会使实现更容易：如果任何L落在数组的左边界之外，则L = INT_MIN，并且如果有任何R落在右边界之外，则R = INT_MAX。<br>我知道这不是很容易理解，但所有上述推理最终归结为以下简洁的代码：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n1 = nums1.length;</span><br><span class="line">    <span class="keyword">int</span> n2 = nums2.length;</span><br><span class="line">    <span class="keyword">if</span> (n1 &lt; n2)</span><br><span class="line">        <span class="keyword">return</span> findMedianSortedArrays(nums2, nums1); <span class="comment">// 确保nums2为短数组</span></span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>, hi = n2 * <span class="number">2</span>; <span class="comment">//</span></span><br><span class="line">    <span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">        <span class="keyword">int</span> c2 = (lo + hi) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> c1 = n1 + n2 - c2;</span><br><span class="line">        <span class="keyword">double</span> L1 = (c1 == <span class="number">0</span>) ? Integer.MIN_VALUE : nums1[(c1 - <span class="number">1</span>) / <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">double</span> L2 = (c2 == <span class="number">0</span>) ? Integer.MIN_VALUE : nums2[(c2 - <span class="number">1</span>) / <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">double</span> R1 = (c1 == n1 * <span class="number">2</span>) ? Integer.MAX_VALUE : nums1[c1 / <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">double</span> R2 = (c2 == n2 * <span class="number">2</span>) ? Integer.MAX_VALUE : nums2[c2 / <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (L1 &gt; R2)</span><br><span class="line">            lo = c2 + <span class="number">1</span>; <span class="comment">// 增大c2，减小c1，向右移动c2</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (L2 &gt; R1)</span><br><span class="line">            hi = c2 - <span class="number">1</span>; <span class="comment">// 减小c2，增大c1，向左移动c2</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> (Math.max(L1, L2) + Math.min(R1, R2)) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定两个大小为 m 和 n 的有序数组 nums1 和 nums2 。&lt;br&gt;请找出这两个有序数组的中位数。要求算法的时间复杂度为 O(log (m+n)) 。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;示例 1:&lt;br&gt;nums1 = [1, 3]&lt;br&gt;nums2 = [
      
    
    </summary>
    
      <category term="LeetCode算法之旅" scheme="https://lierabbit.cn/categories/LeetCode%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>无重复字符的最长子串</title>
    <link href="https://lierabbit.cn/2018/04/24/%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
    <id>https://lierabbit.cn/2018/04/24/无重复字符的最长子串/</id>
    <published>2018-04-24T03:24:58.000Z</published>
    <updated>2018-08-26T13:58:42.473Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个字符串，找出不含有重复字符的最长子串的长度。</p><blockquote><p>示例：<br>给定 “abcabcbb” ，没有重复字符的最长子串是 “abc” ，那么长度就是3。<br>给定 “bbbbb” ，最长的子串就是 “b” ，长度是1。<br>给定 “pwwkew” ，最长子串是 “wke” ，长度是3。请注意答案必须是一个子串，”pwke” 是 子序列  而不是子串。</p></blockquote><p>思路：使用HashMap记录字符上次出现的位置，用pre记录最近重复字符出现的位置，则i(当前位置)-pre就是当前字符最长无重复字符的长度，取最大的就是字符串的最长无重复字符的长度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span> || str.length() &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录字符上次出现的位置</span></span><br><span class="line">    HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 最近出现重复字符的位置</span></span><br><span class="line">    <span class="keyword">int</span> pre = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, strLen = str.length(); i &lt; strLen; i++) &#123;</span><br><span class="line">        Character ch = str.charAt(i);</span><br><span class="line">        Integer index = map.get(ch);</span><br><span class="line">        <span class="keyword">if</span> (index != <span class="keyword">null</span>)</span><br><span class="line">            pre = Math.max(pre, index);</span><br><span class="line">        max = Math.max(max, i - pre);</span><br><span class="line">        map.put(ch, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定一个字符串，找出不含有重复字符的最长子串的长度。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;示例：&lt;br&gt;给定 “abcabcbb” ，没有重复字符的最长子串是 “abc” ，那么长度就是3。&lt;br&gt;给定 “bbbbb” ，最长的子串就是 “b” ，长度是1。&lt;br&gt;给定
      
    
    </summary>
    
      <category term="LeetCode算法之旅" scheme="https://lierabbit.cn/categories/LeetCode%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>两数相加</title>
    <link href="https://lierabbit.cn/2018/04/23/%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"/>
    <id>https://lierabbit.cn/2018/04/23/两数相加/</id>
    <published>2018-04-23T04:15:27.000Z</published>
    <updated>2018-08-26T13:55:31.294Z</updated>
    
    <content type="html"><![CDATA[<p>给定两个非空链表来表示两个非负整数。位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。<br>你可以假设除了数字 0 之外，这两个数字都不会以零开头。</p><blockquote><p>示例：<br>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>输出：7 -&gt; 0 -&gt; 8<br>原因：342 + 465 = 807</p></blockquote><p>思路：遍历链表对应相加即可，注意进位</p><h2 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 为方便操作加入的头结点</span></span><br><span class="line">    ListNode res = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 当前结点</span></span><br><span class="line">    ListNode cur = res;</span><br><span class="line">    <span class="comment">// 进位标志</span></span><br><span class="line">    <span class="keyword">boolean</span>[] flag = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 两链表对应位置相加</span></span><br><span class="line">    <span class="keyword">while</span> (l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ListNode node = add(l1.val, l2.val, flag);</span><br><span class="line">        cur.next = node;</span><br><span class="line">        cur = node;</span><br><span class="line"></span><br><span class="line">        l1 = l1.next;</span><br><span class="line">        l2 = l2.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果l1链表有剩余，则剩下的与0相加</span></span><br><span class="line">    <span class="keyword">while</span> (l1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ListNode node = add(l1.val, <span class="number">0</span>, flag);</span><br><span class="line">        cur.next = node;</span><br><span class="line">        cur = node;</span><br><span class="line">        l1 = l1.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果l2链表有剩余，则剩下的与0相加</span></span><br><span class="line">    <span class="keyword">while</span> (l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ListNode node = add(<span class="number">0</span>, l2.val, flag);</span><br><span class="line">        cur.next = node;</span><br><span class="line">        cur = node;</span><br><span class="line">        l2 = l2.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果链表末尾相加有进位则添加一个进位节点作为尾节点</span></span><br><span class="line">    <span class="keyword">if</span> (flag[<span class="number">0</span>])</span><br><span class="line">        cur.next = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">add</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2, <span class="keyword">boolean</span>[] flag)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = v1 + v2;</span><br><span class="line">    <span class="comment">// 如果有进位则和+1</span></span><br><span class="line">    <span class="keyword">if</span> (flag[<span class="number">0</span>]) &#123;</span><br><span class="line">        sum++;</span><br><span class="line">        flag[<span class="number">0</span>] = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 产生进位</span></span><br><span class="line">    <span class="keyword">if</span> (sum &gt; <span class="number">9</span>)</span><br><span class="line">        flag[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 获取个位上的数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法二：基于方法一的改进"><a href="#方法二：基于方法一的改进" class="headerlink" title="方法二：基于方法一的改进"></a>方法二：基于方法一的改进</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers2</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 为方便操作加入的头节点</span></span><br><span class="line">    ListNode res = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 当前节点</span></span><br><span class="line">    ListNode cur = res;</span><br><span class="line">    <span class="comment">// 进位</span></span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 两链表对应相加</span></span><br><span class="line">    <span class="keyword">while</span> (l1 != <span class="keyword">null</span> || l2 != <span class="keyword">null</span> || carry != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = (l1 != <span class="keyword">null</span> ? l1.val : <span class="number">0</span>) + (l2 != <span class="keyword">null</span> ? l2.val : <span class="number">0</span>) + carry;</span><br><span class="line">        <span class="comment">// 获取进位</span></span><br><span class="line">        carry = sum / <span class="number">10</span>;</span><br><span class="line">        <span class="comment">// 获取个位上的数</span></span><br><span class="line">        ListNode node = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">        cur.next = node;</span><br><span class="line">        cur = node;</span><br><span class="line">        l1 = l1 != <span class="keyword">null</span> ? l1.next : <span class="keyword">null</span>;</span><br><span class="line">        l2 = l2 != <span class="keyword">null</span> ? l2.next : <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定两个非空链表来表示两个非负整数。位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。&lt;br&gt;你可以假设除了数字 0 之外，这两个数字都不会以零开头。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;示例：&lt;br&gt;输入：(2 -&amp;gt; 4 -&amp;gt;
      
    
    </summary>
    
      <category term="LeetCode算法之旅" scheme="https://lierabbit.cn/categories/LeetCode%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>两数之和</title>
    <link href="https://lierabbit.cn/2018/04/22/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>https://lierabbit.cn/2018/04/22/两数之和/</id>
    <published>2018-04-22T04:19:19.000Z</published>
    <updated>2018-08-26T13:52:13.273Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。<br>你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。</p><blockquote><p>示例:<br>给定 nums = [2, 7, 11, 15], target = 9<br>因为 nums[0] + nums[1] = 2 + 7 = 9<br>所以返回 [0, 1]</p></blockquote><p>思路：若a + b = c，则 c - a = b。所以只需记录所有遍历过的数，然后利用预期值-当前值得出的值查询是否已有记录，如果有则退出循环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// 记录遍历过的数和索引</span></span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 获取target-nums[i]，看是否存在，存在则表明可以相加为target</span></span><br><span class="line">        Integer value = map.get(target - nums[i]);</span><br><span class="line">        <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">            res[<span class="number">0</span>] = value;</span><br><span class="line">            res[<span class="number">1</span>] = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 用键保存遍历过的数，用值保存遍历过的索引</span></span><br><span class="line">        map.put(nums[i], i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。&lt;br&gt;你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;示例:&lt;br&gt;给定 nums = [2, 7, 11, 15], target = 9&lt;br&gt;因为 n
      
    
    </summary>
    
      <category term="LeetCode算法之旅" scheme="https://lierabbit.cn/categories/LeetCode%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>机器人的运动范围</title>
    <link href="https://lierabbit.cn/2018/04/21/%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/"/>
    <id>https://lierabbit.cn/2018/04/21/机器人的运动范围/</id>
    <published>2018-04-21T05:16:59.000Z</published>
    <updated>2018-08-26T13:45:22.727Z</updated>
    
    <content type="html"><![CDATA[<p>地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？</p><p>思路：使用二维数组isVisit保存访问过的格子，按上下左右方向依次递归访问各个格子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 记录访问过的点</span></span><br><span class="line">    <span class="keyword">boolean</span>[][] isVisit = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows][cols];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> movingCountCore(threshold, rows, cols, <span class="number">0</span>, <span class="number">0</span>, isVisit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCountCore</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> y, <span class="keyword">int</span> x, <span class="keyword">boolean</span>[][] isVisit)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 排除非法点以及访问过的点</span></span><br><span class="line">    <span class="keyword">if</span> (y &gt;= rows || y &lt; <span class="number">0</span> || x &gt;= cols || x &lt; <span class="number">0</span> || isVisit[y][x] || calcXY(x, y) &gt; threshold)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置当前点已访问</span></span><br><span class="line">    isVisit[y][x] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按上下左右方向访问</span></span><br><span class="line">    <span class="keyword">return</span> movingCountCore(threshold, rows, cols, y + <span class="number">1</span>, x, isVisit)</span><br><span class="line">            + movingCountCore(threshold, rows, cols, y - <span class="number">1</span>, x, isVisit)</span><br><span class="line">            + movingCountCore(threshold, rows, cols, y, x - <span class="number">1</span>, isVisit)</span><br><span class="line">            + movingCountCore(threshold, rows, cols, y, x + <span class="number">1</span>, isVisit)</span><br><span class="line">            + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算坐标为（x，y）的点的数位之和</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">calcXY</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> calc(x) + calc(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算value的数位之和</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (value != <span class="number">0</span>) &#123;</span><br><span class="line">        res += value % <span class="number">10</span>;</span><br><span class="line">        value /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,
      
    
    </summary>
    
      <category term="剑指Offer" scheme="https://lierabbit.cn/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>矩阵中的路径</title>
    <link href="https://lierabbit.cn/2018/04/20/%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/"/>
    <id>https://lierabbit.cn/2018/04/20/矩阵中的路径/</id>
    <published>2018-04-20T03:15:08.000Z</published>
    <updated>2018-08-26T13:42:49.310Z</updated>
    
    <content type="html"><![CDATA[<p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 例如 a b c e s f c s a d e e 矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。</p><p>思路：用一个状态数组保存之前访问过的字符，然后再分别按上下左右方向寻找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPath</span><span class="params">(<span class="keyword">char</span>[] matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">char</span>[] str)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 记录位置是否已访问</span></span><br><span class="line">    <span class="keyword">boolean</span>[] flags = <span class="keyword">new</span> <span class="keyword">boolean</span>[matrix.length];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; rows; x++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; cols; y++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hasPathCore(matrix, rows, cols, x, y, str, <span class="number">0</span>, flags))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathCore</span><span class="params">(<span class="keyword">char</span>[] matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">char</span>[] str, <span class="keyword">int</span> k, <span class="keyword">boolean</span>[] flags)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 计算当前坐标</span></span><br><span class="line">    <span class="keyword">int</span> index = x * cols + y;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非法判断</span></span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= rows || y &lt; <span class="number">0</span> || y &gt;= cols || matrix[index] != str[k] || flags[index])</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 匹配完成</span></span><br><span class="line">    <span class="keyword">if</span> (k == str.length - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前点已访问</span></span><br><span class="line">    flags[index] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 往后寻找</span></span><br><span class="line">    k++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按上下左右方向寻找</span></span><br><span class="line">    <span class="keyword">if</span> (hasPathCore(matrix, rows, cols, x - <span class="number">1</span>, y, str, k, flags)</span><br><span class="line">            || hasPathCore(matrix, rows, cols, x + <span class="number">1</span>, y, str, k, flags)</span><br><span class="line">            || hasPathCore(matrix, rows, cols, x, y - <span class="number">1</span>, str, k, flags)</span><br><span class="line">            || hasPathCore(matrix, rows, cols, x, y + <span class="number">1</span>, str, k, flags))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 未找到还原当前点为未访问</span></span><br><span class="line">    flags[index] = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 未找到</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 例如 a b c e s f c s a 
      
    
    </summary>
    
      <category term="剑指Offer" scheme="https://lierabbit.cn/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>滑动窗口的最大值</title>
    <link href="https://lierabbit.cn/2018/04/19/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
    <id>https://lierabbit.cn/2018/04/19/滑动窗口的最大值/</id>
    <published>2018-04-19T06:06:04.000Z</published>
    <updated>2018-08-26T13:40:29.320Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。</p><p>思路：使用双端队列记录访问到的最大值，判断该值是否还在窗口内</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">maxInWindows</span><span class="params">(<span class="keyword">int</span>[] num, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    Deque&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num.length; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty() &amp;&amp; num[queue.peekLast()] &lt; num[i])</span><br><span class="line">            queue.pollLast();</span><br><span class="line">        queue.add(i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= size - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 判断最大值是否在窗口内</span></span><br><span class="line">            <span class="keyword">if</span> (queue.peekFirst() == i - size)</span><br><span class="line">                queue.pollFirst();</span><br><span class="line">            res.add(num[queue.peekFirst()]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： 
      
    
    </summary>
    
      <category term="剑指Offer" scheme="https://lierabbit.cn/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据流中的中位数</title>
    <link href="https://lierabbit.cn/2018/04/18/%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    <id>https://lierabbit.cn/2018/04/18/数据流中的中位数/</id>
    <published>2018-04-18T03:21:29.000Z</published>
    <updated>2018-08-26T13:37:03.238Z</updated>
    
    <content type="html"><![CDATA[<p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p><p>思路：使用2个堆，一个小根堆放大的数，一个大根堆放小的数，当数据流中数据个数为偶数加入大根堆，奇数加入小根堆。若当前数据量为奇数则中位数为大根堆的堆顶，若当前数据量为偶数则为小根堆与大根堆的堆顶和再➗2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 数据流中的中位数 </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; minHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; maxHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;((v1, v2) -&gt; v2 - v1);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(Integer num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((count++ &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            minHeap.add(num);</span><br><span class="line">            maxHeap.add(minHeap.poll());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            maxHeap.add(num);</span><br><span class="line">            minHeap.add(maxHeap.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">GetMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((count &amp; <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> (minHeap.peek() + maxHeap.peek()) / <span class="number">2.0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> Double.valueOf(maxHeap.peek());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。&lt;/p&gt;
&lt;p&gt;思路：使用2个堆，一个小根堆放大的数，一个大根堆放小的数，当数据流中数据
      
    
    </summary>
    
      <category term="剑指Offer" scheme="https://lierabbit.cn/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="算法" scheme="https://lierabbit.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
